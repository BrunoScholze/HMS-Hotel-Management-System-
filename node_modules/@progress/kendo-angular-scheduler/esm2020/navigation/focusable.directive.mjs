/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Directive, ElementRef, Input, Renderer2 } from '@angular/core';
import { isDocumentAvailable, isVisible } from '@progress/kendo-angular-common';
import { FocusService } from './focus.service';
import * as i0 from "@angular/core";
import * as i1 from "./focus.service";
/**
 * @hidden
 */
export class FocusableDirective {
    constructor(element, renderer, focusService) {
        this.element = element;
        this.renderer = renderer;
        this.focusService = focusService;
        /**
         * The order of the element with respect to the other focusable elements.
         * If multiple elements share the same value, their relative to each other order follows their position in the component tree.
         */
        this.focusIndex = 0;
        this.containerType = 'content';
        this.toggle(false);
    }
    get visible() {
        return this.element.nativeElement.style.display !== 'none';
    }
    get enabled() {
        return !this.element.nativeElement.disabled;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        const isViewSelector = element.closest('.k-scheduler-views-wrapper');
        if (!isViewSelector || !isDocumentAvailable()) {
            return;
        }
        // eslint-disable-next-line no-unused-expressions
        isVisible(element) ? this.focusService.register(this) : this.focusService.unregister(this);
    }
    ngOnInit() {
        this.focusService.register(this);
    }
    ngOnDestroy() {
        this.focusService.unregister(this);
    }
    toggle(active) {
        if (active !== this.active) {
            const index = active ? '0' : '-1';
            this.renderer.setAttribute(this.element.nativeElement, 'tabIndex', index);
            this.active = active;
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    focus() {
        this.element.nativeElement.focus();
    }
    toggleFocus(value) {
        const element = this.element.nativeElement;
        const focusedClass = element.matches('.k-button-group .k-button') ? 'k-focus' : 'k-selected';
        const renderedEvents = this.element.nativeElement.ownerDocument.querySelectorAll('.k-event');
        const method = value ? 'addClass' : 'removeClass';
        this.renderer[method](element, focusedClass);
        if (renderedEvents.length > 0) {
            const ariaLabel = element.getAttribute('aria-label');
            renderedEvents.forEach((event) => {
                if (event.getAttribute('aria-label') === ariaLabel) {
                    this.renderer[method](event, 'k-selected');
                }
            });
        }
        const selectable = element.matches('.k-scheduler-agendaview .k-scheduler-content .k-selected');
        if (selectable) {
            element.closest('.k-scheduler-agendaview').querySelector('[aria-selected="true"]')?.removeAttribute('aria-selected');
            this.renderer.setAttribute(element, 'aria-selected', value.toString());
        }
    }
}
FocusableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1.FocusService }], target: i0.ɵɵFactoryTarget.Directive });
FocusableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: FocusableDirective, isStandalone: true, selector: "[kendoSchedulerFocusIndex]", inputs: { focusIndex: ["kendoSchedulerFocusIndex", "focusIndex"], containerType: "containerType" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerFocusIndex]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1.FocusService }]; }, propDecorators: { focusIndex: [{
                type: Input,
                args: ['kendoSchedulerFocusIndex']
            }], containerType: [{
                type: Input
            }] } });
