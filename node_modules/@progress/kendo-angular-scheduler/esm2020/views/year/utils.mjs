/**-----------------------------------------------------------------------------------------
* Copyright Â© 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { intersects, toUTCDate, toUTCDateTime } from '../utils';
import { sortTasksByTime } from '../../common/util';
import { addDays } from '@progress/kendo-date-math';
/**
 * @hidden
 */
export const createTasks = (periodStart, periodEnd, items, ranges) => {
    const tasks = [];
    const utcStart = toUTCDateTime(periodStart);
    const utcEnd = toUTCDateTime(periodEnd);
    for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const data = {};
        const startTime = item.start.toUTCDate();
        const end = item.end;
        const endTime = (item.end.getTime() !== end.getTime() ? end.addDays(1) : end).toUTCDate();
        if (intersects(startTime, endTime, utcStart, utcEnd)) {
            for (let rangeIdx = 0; rangeIdx < ranges.length; rangeIdx++) {
                const range = ranges[rangeIdx];
                const rangeStart = toUTCDate(range);
                const rangeEnd = toUTCDate(addDays(range, 1));
                if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
                    const task = {
                        index,
                        startTime: startTime > rangeStart ? startTime : rangeStart,
                        endTime: endTime < rangeEnd ? endTime : rangeEnd,
                        start: item.start,
                        end: item.end,
                        event: item.event,
                        isAllDay: item.event.isAllDay,
                        rangeIndex: rangeIdx,
                        data: data
                    };
                    task.head = endTime > rangeEnd && startTime > rangeStart;
                    task.tail = startTime < rangeStart && endTime < rangeEnd;
                    task.mid = endTime > rangeEnd && startTime < rangeStart;
                    task.isMultiDay = task.head || task.mid || task.tail;
                    tasks.push(task);
                }
            }
        }
    }
    return sortTasksByTime(tasks);
};
/**
 * @hidden
 */
export const noop = (_) => { };
/**
 * @hidden
 */
export const yearEnd = (year) => new Date(year, 11, 31, 23, 59, 59, 999);
/**
 * @hidden
 */
export const yearStart = (year) => new Date(year, 0, 1, 0, 0, 0, 0);
