/**-----------------------------------------------------------------------------------------
* Copyright © 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { Directive, Optional, Injectable, EventEmitter, Input, Inject, isDevMode, Component, HostBinding, Output, forwardRef, ViewChild, ViewChildren, ChangeDetectionStrategy, NgZone, ViewContainerRef, ContentChild, ContentChildren, HostListener, LOCALE_ID, ElementRef, TemplateRef, Pipe, NgModule } from '@angular/core';
import * as i1$1 from '@progress/kendo-angular-l10n';
import { LocalizationService, L10N_PREFIX, RTL, ComponentMessages } from '@progress/kendo-angular-l10n';
import * as i7 from '@progress/kendo-angular-common';
import { hasObservers, isDocumentAvailable, isVisible as isVisible$1, scrollbarWidth, isChanged, Keys, ResizeSensorComponent, shouldShowValidationUI, anyChanged, WatermarkOverlayComponent, guid, ResizeBatchService } from '@progress/kendo-angular-common';
import { isEqualDate, ZonedDate, toLocalDate, getDate, timezoneNames, Day, MS_PER_DAY as MS_PER_DAY$1, addDays, firstDayOfMonth, lastDayOfMonth, firstDayInWeek, addMonths, addWeeks, addYears } from '@progress/kendo-date-math';
import { auditTime, buffer, filter, map, debounceTime, take, distinctUntilChanged, switchMap, tap } from 'rxjs/operators';
import { validatePackage } from '@progress/kendo-licensing';
import { PreventableEvent as PreventableEvent$1, DatePickerComponent, DatePickerCustomMessagesComponent, DateTimePickerComponent, DateTimePickerCustomMessagesComponent, CalendarComponent, CalendarCustomMessagesComponent, MultiViewCalendarComponent, MonthCellTemplateDirective, CalendarDOMService, CenturyViewService, DecadeViewService, MonthViewService, YearViewService, NavigationService, TimePickerDOMService, HoursService, MinutesService, SecondsService, MillisecondsService, DayPeriodService } from '@progress/kendo-angular-dateinputs';
import { Subject, BehaviorSubject, fromEvent, Subscription, combineLatest, merge } from 'rxjs';
import * as i4 from '@angular/forms';
import { NG_VALUE_ACCESSOR, NgControl, ReactiveFormsModule, FormControl, FormGroup } from '@angular/forms';
import * as i1 from '@progress/kendo-angular-dialog';
import { DialogCloseResult, DialogComponent, DialogActionsComponent, DialogContainerService, DialogService, WindowService, WindowContainerService } from '@progress/kendo-angular-dialog';
import * as i1$2 from '@progress/kendo-angular-intl';
import { formatDate, DatePipe, parseDate } from '@progress/kendo-angular-intl';
import { MultiSelectComponent, ItemTemplateDirective, TagTemplateDirective, DropDownListComponent, ComboBoxComponent } from '@progress/kendo-angular-dropdowns';
import { NgIf, NgStyle, NgFor, NgTemplateOutlet, AsyncPipe, NgClass } from '@angular/common';
import { saveIcon, cancelOutlineIcon, caretAltLeftIcon, caretAltRightIcon, calendarIcon, filePdfIcon, arrowRotateCwIcon, arrowsNoRepeatIcon, xIcon, moreHorizontalIcon, clockIcon, caretAltUpIcon, caretAltDownIcon } from '@progress/kendo-svg-icons';
import { Button, ButtonGroupComponent, ButtonComponent } from '@progress/kendo-angular-buttons';
import { NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, FormFieldComponent, TextBoxDirective, CheckBoxDirective, TextAreaDirective } from '@progress/kendo-angular-inputs';
import { parseRule, serializeRule, expand } from '@progress/kendo-recurrence';
import { LabelComponent, LabelDirective } from '@progress/kendo-angular-label';
import * as i1$3 from '@progress/kendo-angular-popup';
import { PopupService } from '@progress/kendo-angular-popup';
import { IconWrapperComponent, IconsService } from '@progress/kendo-angular-icons';
import { drawDOM, exportPDF } from '@progress/kendo-drawing';
import { saveAs } from '@progress/kendo-file-saver';
import { orderBy, groupBy } from '@progress/kendo-data-query';
import { Draggable } from '@progress/kendo-draggable';
import { TooltipDirective } from '@progress/kendo-angular-tooltip';

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-scheduler',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1728372694,
    version: '16.11.0',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

/**
 * Arguments for the `dateChange` event.
 */
class DateChangeEvent {
    /**
     * @hidden
     */
    constructor(sender, selectedDate, dateRange) {
        this.sender = sender;
        this.selectedDate = selectedDate;
        this.dateRange = dateRange;
    }
}

/**
 * Arguments for the `navigate` event.
 */
class NavigateEvent extends PreventableEvent$1 {
    /**
     * @hidden
     */
    constructor(sender, action) {
        super();
        this.sender = sender;
        this.action = action;
    }
}

/**
 * Arguments for `slotClick` and `slotDblClick` events.
 */
class SlotClickEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `eventClick` and `eventDblClick` events.
 */
class EventClickEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `eventKeydown` event.
 */
class EventKeydownEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `create` event.
 */
class CreateEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * @hidden
 */
class PreventableEvent {
    constructor() {
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * Arguments for the `dragEnd` event.
 */
class DragEndEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `drag` event.
 */
class DragEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `dragStart` event.
 */
class DragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `remove` event.
 */
class RemoveEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `resizeEnd` event.
 */
class ResizeEndEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `resize` event.
 */
class ResizeEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `resizeStart` event.
 */
class ResizeStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * @hidden
 *
 * Maps the name of the event to the argument type of the event.
 */
const VIEW_EVENT_MAP = {
    slotClick: SlotClickEvent,
    slotDblClick: SlotClickEvent,
    eventClick: EventClickEvent,
    eventDblClick: EventClickEvent,
    eventKeydown: EventKeydownEvent,
    create: CreateEvent,
    remove: RemoveEvent,
    resizeStart: ResizeStartEvent,
    resize: ResizeEvent,
    resizeEnd: ResizeEndEvent,
    dragStart: DragStartEvent,
    drag: DragEvent,
    dragEnd: DragEndEvent
};

/**
 * @hidden
 */
class EditEventBase {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `cancel` event.
 */
class CancelEvent extends EditEventBase {
}

/**
 * Arguments for the `save` event.
 */
class SaveEvent extends EditEventBase {
}

/**
 * Arguments for the `edit` event of the editing directives.
 */
class EditEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `add` event of the editing directives.
 */
class AddEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `slotDragStart` event.
 * The event is preventable and if prevented, subsequent `slotDrag`, `slotDragEnd`, and `slotSelectionChange` will not be fired.
 */
class SlotDragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        super();
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `slotDrag` event.
 */
class SlotDragEvent {
    /**
     * @hidden
     */
    constructor(sender, args) {
        this.sender = sender;
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `slotDragEnd` event.
 */
class SlotDragEndEvent extends SlotDragEvent {
}

/**
 * Represents the toolbar template of the Scheduler. To define a toolbar
 * template, nest an `<ng-template kendoSchedulerToolbarTemplate>` tag
 * inside `<kendo-scheduler>`. For more information and examples, refer to the article on
 * [customizing the toolbar]({% slug toolbar_scheduler %}) of the Scheduler.
 *
 * The template context receives the following template variables:
 * * `selectedDate`&mdash;The currently selected date.
 * * `dateRange`&mdash;The currently selected [`DateRange`]({% slug api_scheduler_daterange %}).
 * * `views`&mdash;A [`SchedulerView`]({% slug api_scheduler_schedulerview %}) array with the available views.
 * * `selectedView`&mdash;The currently selected [`SchedulerView`]({% slug api_scheduler_schedulerview %}).
 *
 * You can declare either of the following built-in navigation components in the toolbar template:
 * * `kendoSchedulerToolbarNavigation`&mdash;Renders navigation buttons, a calendar, and a date-range label.
 * * `kendoSchedulerToolbarViewSelector`&mdash;Renders the buttons for selecting the view.
 *
 * To emit navigation events, the components inside the toolbar can inject
 * the [`ToolbarService`]({% slug api_scheduler_toolbarservice %}).
 */
class ToolbarTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
ToolbarTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
ToolbarTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: ToolbarTemplateDirective, isStandalone: true, selector: "[kendoSchedulerToolbarTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerToolbarTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * A service for communication with the toolbar controls
 * which is used by the toolbar components for publishing navigation actions
 * ([see example]({% slug toolbar_scheduler %}#toc-using-the-toolbar-service)).
 */
class ToolbarService {
    /** @hidden */
    constructor() {
        this.actionSource = new Subject();
        this.action = this.actionSource.asObservable();
    }
    /**
     * Emits the specified navigation action.
     *
     * @param action - The navigation action that will be executed.
     */
    navigate(action) {
        this.actionSource.next(action);
    }
}
ToolbarService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ToolbarService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

/**
 * An abstract class which contains meta information about a Scheduler view.
 */
class SchedulerView {
}

/**
 * The selected edit mode during the update or removal of events.
 * For non-recurring events, set to `Event`.
 */
var EditMode;
(function (EditMode) {
    /**
     * Edits the selected event.
     */
    EditMode[EditMode["Event"] = 0] = "Event";
    /**
     * Edits the selected occurrence.
     */
    EditMode[EditMode["Occurrence"] = 1] = "Occurrence";
    /**
     * Edits all events in the series.
     */
    EditMode[EditMode["Series"] = 2] = "Series";
})(EditMode || (EditMode = {}));

/**
 * The selected CRUD operation when the user edits or removes recurring events.
 */
var CrudOperation;
(function (CrudOperation) {
    /**
     * The user edits the selected recurring event.
     */
    CrudOperation[CrudOperation["Edit"] = 0] = "Edit";
    /**
     * The user removes the selected recurring event.
     */
    CrudOperation[CrudOperation["Remove"] = 1] = "Remove";
})(CrudOperation || (CrudOperation = {}));

/**
 * The arguments for the [`isSlotSelected`]({% slug api_scheduler_schedulercomponent %}#toc-isslotselected) callback.
 */
class IsSlotSelectedArgs {
}
/**
 * @hidden
 */
var slotDragEventName;
(function (slotDragEventName) {
    slotDragEventName["initDragSelect"] = "initDragSelect";
    slotDragEventName["dragSelect"] = "dragSelect";
    slotDragEventName["refreshSlotSelection"] = "refreshSlotSelection";
    slotDragEventName["dragSelectRelease"] = "dragSelectRelease";
})(slotDragEventName || (slotDragEventName = {}));

/**
 * Represents the template which renders the date header in the **Agenda** view.
 * To define the date template, nest an `<ng-template>` tag with the `kendoSchedulerAgendaDateTemplate`
 * directive inside the `<kendo-scheduler-agenda-view>` or `<kendo-scheduler>` components ([see example](slug:templates_scheduler#toc-agenda-dates)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The header date.
 */
class AgendaDateTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
AgendaDateTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaDateTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
AgendaDateTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: AgendaDateTemplateDirective, isStandalone: true, selector: "[kendoSchedulerAgendaDateTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaDateTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerAgendaDateTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template which renders the time header in the **Agenda** view.
 * To define the time template, nest an `<ng-template>` tag with the `kendoSchedulerAgendaTimeTemplate`
 * directive inside the `<kendo-scheduler>` or in the `<kendo-scheduler-agenda-view>` component ([see example](slug:templates_scheduler#toc-agenda-times)).
 *
 * The available fields in the template context are:
 * - `start`&mdash;The start date of the event.
 * - `end`&mdash;The end date of the event.
 * - `title`&mdash;The title of the event.
 * - `description`&mdash;The description of the event.
 * - `isAllDay`&mdash;A Boolean value which indicates if the event is all-day.
 * - `resources`&mdash;The resources of the event.
 */
class AgendaTimeTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
AgendaTimeTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaTimeTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
AgendaTimeTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: AgendaTimeTemplateDirective, isStandalone: true, selector: "[kendoSchedulerAgendaTimeTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaTimeTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerAgendaTimeTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for and assists the content customization of all-day events.
 * To define the all-day event template, nest an `<ng-template>` tag with the `kendoSchedulerAllDayEventTemplate`
 * directive inside the `<kendo-scheduler>`, `<kendo-scheduler-day-view>`, or `<kendo-scheduler-week-view>` component ([see example](slug:templates_scheduler#toc-all-day-events)).
 *
 * The available fields in the template context are:
 * - `event`&mdash;The event that is associated with the item.
 * - `resources`&mdash;The resources of the event.
 */
class AllDayEventTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
AllDayEventTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AllDayEventTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
AllDayEventTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: AllDayEventTemplateDirective, isStandalone: true, selector: "[kendoSchedulerAllDayEventTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AllDayEventTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerAllDayEventTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for and assists the content customization of all-day slots.
 * To define the all-day slot template, nest an `<ng-template>` tag with the `kendoSchedulerAllDaySlotTemplate`
 * directive inside the `<kendo-scheduler>`, `<kendo-scheduler-day-view>`, or `<kendo-scheduler-week-view>` component ([see example](slug:templates_scheduler#toc-all-day-slots)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the slot.
 * - `resources`&mdash;The resources of the slot.
 */
class AllDaySlotTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
AllDaySlotTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AllDaySlotTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
AllDaySlotTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: AllDaySlotTemplateDirective, isStandalone: true, selector: "[kendoSchedulerAllDaySlotTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AllDaySlotTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerAllDaySlotTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template which renders the date header in the **Day**, **Week**, and **Timeline** views.
 * To define the day template, nest an `<ng-template>` tag with the `kendoSchedulerDateHeaderTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-day-view>`, `<kendo-scheduler-week-view>`,
 * `<kendo-scheduler-timeline-view>`, `<kendo-scheduler-timeline-week-view>`, and `<kendo-scheduler-timeline-month-view>` components ([see example](slug:templates_scheduler#toc-date-headers)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The header date.
 */
class DateHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
DateHeaderTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DateHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
DateHeaderTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: DateHeaderTemplateDirective, isStandalone: true, selector: "[kendoSchedulerDateHeaderTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DateHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerDateHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for and assists the content customization of the Scheduler events.
 * To define the event template, nest an `<ng-template>` tag with the `kendoSchedulerEventTemplate`
 * directive inside the `<kendo-scheduler>`, or in the view components ([see example](slug:templates_scheduler#toc-event-rendering)).
 *
 * The available fields in the template context are:
 * - `event`&mdash;The event that is associated with the item.
 * - `resources`&mdash;The resources of the event.
 */
class EventTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
EventTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EventTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
EventTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: EventTemplateDirective, isStandalone: true, selector: "[kendoSchedulerEventTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EventTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerEventTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template which renders the resource group header in the **Day**, **Week**, and **Timeline** views.
 * To define the template, nest an `<ng-template>` tag with the `kendoSchedulerGroupHeaderTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-day-view>`, `<kendo-scheduler-week-view>`,
 * `<kendo-scheduler-timeline-view>`, `<kendo-scheduler-timeline-week-view>`, and `<kendo-scheduler-timeline-month-view>` components ([see example](slug:templates_scheduler#toc-group-headers)).
 *
 * The available fields in the template context are:
 * - `resource`&mdash;The resource item.
 */
class GroupHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
GroupHeaderTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: GroupHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
GroupHeaderTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: GroupHeaderTemplateDirective, isStandalone: true, selector: "[kendoSchedulerGroupHeaderTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: GroupHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerGroupHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for the major-time headers in the **Day** and **Week** views.
 * To define the major-time header template, nest an `<ng-template>` tag with the `kendoSchedulerMajorTimeHeaderTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-day-view>` and `<kendo-scheduler-week-view>` components ([see example](slug:templates_scheduler#toc-major-time-headers)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the header.
 */
class MajorTimeHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
MajorTimeHeaderTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MajorTimeHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MajorTimeHeaderTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: MajorTimeHeaderTemplateDirective, isStandalone: true, selector: "[kendoSchedulerMajorTimeHeaderTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MajorTimeHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerMajorTimeHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for the minor-time headers in the **Day** and **Week** views.
 * To define the minor-time header template, nest an `<ng-template>` tag with the `kendoSchedulerMinorTimeHeaderTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-day-view>` and `<kendo-scheduler-week-view>` components ([see example](slug:templates_scheduler#toc-minor-time-headers)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the header.
 */
class MinorTimeHeaderTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
MinorTimeHeaderTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MinorTimeHeaderTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MinorTimeHeaderTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: MinorTimeHeaderTemplateDirective, isStandalone: true, selector: "[kendoSchedulerMinorTimeHeaderTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MinorTimeHeaderTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerMinorTimeHeaderTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for rendering the day slots in the **Month** view.
 * To define the day template, nest an `<ng-template>` tag with the `kendoSchedulerMonthDaySlotTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-month-view>` component ([see example](slug:templates_scheduler#toc-month-slots)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the slot.
 * - `resources`&mdash;The resources of the slot.
 */
class MonthDaySlotTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
MonthDaySlotTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthDaySlotTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MonthDaySlotTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: MonthDaySlotTemplateDirective, isStandalone: true, selector: "[kendoSchedulerMonthDaySlotTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthDaySlotTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerMonthDaySlotTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for rendering the day slots in the **Month** view.
 * To define the day template, nest an `<ng-template>` tag with the `kendoSchedulerMultiWeekDaySlotTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-month-view>` component ([see example](slug:templates_scheduler#toc-multi-week-slots)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the slot.
 * - `resources`&mdash;The resources of the slot.
 *
 */
class MultiWeekDaySlotTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
MultiWeekDaySlotTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiWeekDaySlotTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
MultiWeekDaySlotTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: MultiWeekDaySlotTemplateDirective, isStandalone: true, selector: "[kendoSchedulerMultiWeekDaySlotTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiWeekDaySlotTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerMultiWeekDaySlotTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Represents the template for the time-slot renderer in the **Day**, **Week**, and **Timeline** views.
 * To define the time-slot template, nest an `<ng-template>` tag with the `kendoSchedulerTimeSlotTemplate`
 * directive inside the `<kendo-scheduler>`, or in the `<kendo-scheduler-day-view>`, `<kendo-scheduler-week-view>`,
 * `<kendo-scheduler-timeline-view>`, `<kendo-scheduler-timeline-week-view>`, and `<kendo-scheduler-timeline-month-view>` components ([see example](slug:templates_scheduler#toc-time-slots)).
 *
 * The available fields in the template context are:
 * - `date`&mdash;The date of the slot.
 * - `resources`&mdash;The resources of the slot.
 */
class TimeSlotTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
TimeSlotTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeSlotTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
TimeSlotTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: TimeSlotTemplateDirective, isStandalone: true, selector: "[kendoSchedulerTimeSlotTemplate]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeSlotTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerTimeSlotTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * A service which publishes information from the Scheduler to the views.
 * Views subscribe to changes in the context (selected date, event, and resource data) through this service.
 */
class ViewContextService {
    constructor() {
        this.actionSource = new Subject();
        this.itemsSource = new BehaviorSubject([]);
        this.selectedDateSource = new BehaviorSubject(null);
        this.resizeSource = new Subject();
        this.optionsChangeSource = new BehaviorSubject({});
        this.executeSource = new Subject();
        this.action = this.actionSource.asObservable();
        this.items = this.itemsSource.asObservable();
        this.selectedDate = this.selectedDateSource.asObservable();
        this.resize = this.resizeSource.asObservable();
        this.optionsChange = this.optionsChangeSource.asObservable();
        this.execute = this.executeSource.asObservable();
    }
    /**
     * An internal method which is used by the Scheduler to publish unhandled navigation actions.
     *
     * @hidden
     */
    notifyAction(action) {
        this.actionSource.next(action);
    }
    /**
     * An internal method which is used by the Scheduler to publish the current set of items.
     *
     * @hidden
     */
    notifyItems(items) {
        this.itemsSource.next(items);
    }
    /**
     * An internal method which is used by the Scheduler to publish the currently selected date.
     *
     * @hidden
     */
    notifySelectedDate(date) {
        this.selectedDateSource.next(date);
    }
    /**
     * An internal method which is used by the Scheduler to notify that the size changed.
     *
     * @hidden
     */
    notifyResize() {
        this.resizeSource.next();
    }
    /**
     * An internal method which is used by the Scheduler to notify that the options changed.
     *
     * @hidden
     */
    notifyOptionsChange(changes) {
        this.optionsChangeSource.next(changes);
    }
    /**
     * An internal method which is used by the Scheduler to execute a view method.
     *
     * @hidden
     */
    executeMethod(name, args) {
        let result;
        this.executeSource.next({ name, args, result: (r) => {
                result = r;
            } });
        return result;
    }
}
ViewContextService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewContextService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ViewContextService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewContextService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewContextService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

const emptyDateRange = () => ({
    start: new Date(0),
    end: new Date(0),
    text: '',
    shortText: ''
});
/**
 * A service for publishing the view state and actions to the Scheduler.
 */
class ViewStateService {
    constructor() {
        /**
         * @hidden
         */
        this.toggleWorkHours = new Subject();
        /**
         * @hidden
         */
        this.toolbarVisibilityByView = new Map();
        this.dateRangeSource = new BehaviorSubject(emptyDateRange());
        this.nextDateSource = new Subject();
        this.navigateSource = new Subject();
        this.viewEventSource = new Subject();
        this.layoutEndSource = new Subject();
        this.optionsChangeSource = new Subject();
        this.slotSelectionStartSource = new Subject();
        this.slotSelectionStartDragSource = new Subject();
        this.slotSelectionStartEndSource = new Subject();
        this.dateRange = this.dateRangeSource.asObservable();
        this.nextDate = this.nextDateSource.asObservable();
        this.navigate = this.navigateSource.asObservable();
        this.viewEvent = this.viewEventSource.asObservable();
        this.layoutEnd = this.layoutEndSource.asObservable();
        this.optionsChange = this.optionsChangeSource.asObservable();
        this.slotSelectionStart = this.slotSelectionStartSource.asObservable();
        this.slotSelectionDrag = this.slotSelectionStartDragSource.asObservable();
        this.slotSelectionEnd = this.slotSelectionStartEndSource.asObservable();
    }
    /**
     * Publishes the date that will be displayed by the Scheduler
     * typically as a result from processing a navigation action.
     */
    notifyNextDate(date) {
        this.nextDateSource.next(date);
    }
    /**
     * Publishes the visible date range of the view.
     * The view will calculate and set the new data range when
     * the selected date changes.
     */
    notifyDateRange(range) {
        this.dateRangeSource.next(range);
    }
    /**
     * Notifies the Scheduler that the view has completed its layout.
     */
    notifyLayoutEnd() {
        this.layoutEndSource.next();
    }
    /**
     * Navigates to another view.
     */
    navigateTo(args) {
        this.navigateSource.next(args);
    }
    /**
     * Notifies the Scheduler that the view options have been changed.
     */
    notifyOptionsChange(changes) {
        this.optionsChangeSource.next(changes);
    }
    /**
     * Emits a DOM event to the Scheduler.
     */
    emitEvent(name, args) {
        this.viewEventSource.next({
            name: name,
            args: args
        });
    }
    /** @hidden */
    notifySlotSelectionStart(selection) {
        this.slotSelectionStartSource.next(selection);
    }
    /** @hidden */
    notifySlotSelectionDrag(selection) {
        this.slotSelectionStartDragSource.next(selection);
    }
    /** @hidden */
    notifySlotSelectionEnd(selection) {
        this.slotSelectionStartEndSource.next(selection);
    }
}
ViewStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewStateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ViewStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewStateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

const FIELD_REGEX$1 = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
const getterCache = {};
getterCache['undefined'] = () => undefined;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
function getter(field) {
    if (getterCache[field]) {
        return getterCache[field];
    }
    const fields = [];
    field.replace(FIELD_REGEX$1, function (_match, index, indexAccessor, fieldName) {
        fields.push(index !== undefined ? index : (indexAccessor || fieldName));
    });
    getterCache[field] = function (obj) {
        let result = obj;
        for (let idx = 0; idx < fields.length && result; idx++) {
            result = result[fields[idx]];
        }
        return result;
    };
    return getterCache[field];
}

const FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
const setterCache = {};
setterCache['undefined'] = obj => obj;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
function setter(field) {
    if (setterCache[field]) {
        return setterCache[field];
    }
    const fields = [];
    field.replace(FIELD_REGEX, function (_match, index, indexAccessor, fieldName) {
        fields.push(index !== undefined ? index : (indexAccessor || fieldName));
    });
    setterCache[field] = function (obj, value) {
        let root = obj;
        const depth = fields.length - 1;
        for (let idx = 0; idx < depth && root; idx++) {
            root = root[fields[idx]] = root[fields[idx]] || {};
        }
        root[fields[depth]] = value;
    };
    return setterCache[field];
}

/**
 * @hidden
 */
const OCCURRENCE_ID = 0;

/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const capitalize = (value) => value.charAt(0).toUpperCase() + value.slice(1);
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isBlank = (value) => value === null || value === undefined;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isArray = (value) => Array.isArray(value);
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isTruthy = (value) => !!value;
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isNullOrEmptyString = (value) => isBlank(value) || (value.trim && value.trim().length === 0);
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isNumber = (value) => typeof value === "number" && !isNaN(value);
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isString = (value) => typeof value === 'string';
/**
 * @hidden
 *
 * TODO: Move to @progress/kendo-common
 */
const isObject = (value) => typeof value === 'object';
/**
 * @hidden
 */
const isRecurring = (event, fields) => {
    const recurrenceId = getter(fields.recurrenceId)(event);
    const recurrenceRule = getter(fields.recurrenceRule)(event);
    return !!(recurrenceRule || recurrenceId);
};
/**
 * @hidden
 */
const isException = (event, fields) => {
    const id = getter(fields.id)(event);
    const recurrenceId = getter(fields.recurrenceId)(event);
    return isPresent(id) && id !== OCCURRENCE_ID && isPresent(recurrenceId);
};
/**
 * @hidden
 */
const copyResources = (event, resources) => {
    if (resources) {
        for (let idx = 0; idx < resources.length; idx++) {
            assignField(event, event.dataItem, resources[idx].field);
        }
    }
};
/**
 * @hidden
 */
const readEvent = (dataItem, fields, resources) => {
    const result = {
        id: getter(fields.id)(dataItem),
        start: getter(fields.start)(dataItem),
        startTimezone: getter(fields.startTimezone)(dataItem),
        end: getter(fields.end)(dataItem),
        endTimezone: getter(fields.endTimezone)(dataItem),
        isAllDay: getter(fields.isAllDay)(dataItem),
        title: getter(fields.title)(dataItem),
        description: getter(fields.description)(dataItem),
        recurrenceRule: getter(fields.recurrenceRule)(dataItem),
        recurrenceExceptions: getter(fields.recurrenceExceptions)(dataItem),
        recurrenceId: getter(fields.recurrenceId)(dataItem),
        dataItem
    };
    copyResources(result, resources);
    return result;
};
/**
 * @hidden
 */
const isRecurrenceMaster$1 = (event) => event.recurrenceRule && !isPresent(event.recurrenceId);
/**
 * @hidden
 */
function groupResources(group, resources) {
    const result = [];
    if (group && group.resources && group.resources.length) {
        const groups = group.resources;
        for (let idx = 0; idx < groups.length; idx++) {
            const resource = resources.find(r => r.name === groups[idx]);
            resource ? result.push(resource) : null;
        }
    }
    return result;
}
/**
 * @hidden
 */
const getField = (obj, field) => getter(field)(obj);
/**
 * @hidden
 */
const setField = (obj, field, value) => setter(field)(obj, value);
/**
 * @hidden
 */
function assignField(target, source, field) {
    setField(target, field, getField(source, field));
}
/**
 * @hidden
 */
function assignFields(target, source, ...fields) {
    for (let idx = 0; idx < fields.length; idx++) {
        assignField(target, source, fields[idx]);
    }
}
/**
 * @hidden
 */
function assignValues(target, source) {
    cloneTo(source, target);
    return target;
}
/**
 * @hidden
 */
function cloneTo(obj, result) {
    for (const field in obj) {
        if (obj.hasOwnProperty(field)) {
            const value = obj[field];
            if (Array.isArray(value)) {
                result[field] = value.slice(0);
            }
            else if (value && typeof value === 'object' && !(value instanceof Date)) {
                result[field] = result[field] || {};
                cloneTo(value, result[field]);
            }
            else {
                result[field] = value;
            }
        }
    }
}
/**
 * @hidden
 */
function clone(obj) {
    const result = {};
    cloneTo(obj, result);
    return result;
}
/** @hidden */
const iterator = getIterator();
// TODO: Move to kendo-common
function getIterator() {
    if (typeof Symbol === 'function' && Symbol.iterator) {
        return Symbol.iterator;
    }
    const keys = Object.getOwnPropertyNames(Map.prototype);
    const proto = Map.prototype;
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key !== 'entries' && key !== 'size' && proto[key] === proto.entries) {
            return key;
        }
    }
}
/**
 * @hidden
 */
function fromClick(element) {
    return fromEvent(element, 'click');
}
/**
 * @hidden
 */
function fromDoubleClick(element) {
    const DBLCLICK_DELAY = 250;
    const clicks = fromClick(element);
    const endSequence = clicks.pipe(auditTime(DBLCLICK_DELAY));
    return clicks.pipe(buffer(endSequence), filter(sequence => sequence.length === 2), filter((sequence) => sequence[1].target === sequence[0].target), map(sequence => sequence[1]));
}
/**
 * @hidden
 */
function sortTasksByTime(tasks) {
    tasks.sort((a, b) => (a.startTime - b.startTime) || (b.endTime - a.endTime));
    return tasks;
}

// const toSimilarDate = (date: ZonedDate): Date => new Date(
//     date.getFullYear(), date.getMonth(), date.getDay(),
//     date.getHours(), date.getMinutes(), date.getSeconds(),
//     date.getMilliseconds()
//   );
// const toUTCDateTime = (localDate: Date): Date => new Date(Date.UTC(
//       localDate.getFullYear(),
//       localDate.getMonth(),
//       localDate.getDate(),
//       localDate.getHours(),
//       localDate.getMinutes(),
//       localDate.getSeconds(),
//       localDate.getMilliseconds()
//     ));
/**
 * @hidden
 */
class EditService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.changes = new EventEmitter();
        this.changedSource = new Subject();
        this.changed = this.changedSource.asObservable().pipe(debounceTime(0));
    }
    endEdit() {
        const formGroup = this.hasNewEvent ? this.newEventGroup.group : this.editedEvent.formGroup;
        this.changes.emit({ action: 'cancel', formGroup });
    }
    removeEvent(dataItem) {
        this.changes.emit({ action: 'remove', dataItem });
    }
    addEvent(formGroup) {
        this.newEventGroup = { formGroup };
        this.onChanged();
    }
    editEvent(dataItem, formGroup = undefined, mode) {
        this.editedEvent = { dataItem, formGroup, mode };
        this.onChanged();
    }
    close() {
        this.newEventGroup = this.editedEvent = null;
        this.onChanged();
    }
    save() {
        const { dataItem, formGroup } = this.context;
        this.changes.emit({
            action: 'save',
            dataItem,
            formGroup,
            isNew: this.hasNewEvent,
            mode: this.occurrenceEditMode
        });
    }
    isEditing() {
        return isPresent(this.context);
    }
    get occurrenceEditMode() {
        if (this.hasNewEvent) {
            return EditMode.Series;
        }
        else {
            return this.editedEvent.mode || EditMode.Event;
        }
    }
    get hasNewEvent() {
        return isPresent(this.newEventGroup);
    }
    get newEvent() {
        if (this.hasNewEvent) {
            return this.newEventGroup.group.value;
        }
        return {};
    }
    get context() {
        if (this.hasNewEvent) {
            return this.newEventGroup;
        }
        return this.editedEvent;
    }
    onChanged() {
        this.ngZone.runOutsideAngular(() => {
            this.changedSource.next();
        });
    }
}
EditService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditService, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
EditService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

/**
 * Represents the template for the edit dialog of the Scheduler.
 * To define the template, nest an `<ng-template>` tag
 * with the `kendoSchedulerEditDialogTemplate` directive inside the `<kendo-scheduler>` tag ([see example](slug:custom_reactive_editing_scheduler)).
 *
 * The template context is set to the current event and then the following additional fields are passed:
 * - `event`&mdash;The currently edited event. Represents the default context that will be assigned to any template variable which utilizes the `let-x` syntax&mdash;for example, `let-event`.
 * - `formGroup`&mdash;The current [`FormGroup`](https://angular.io/docs/ts/latest/api/forms/index/FormGroup-class.html).
 * - `editMode`&mdash;The current edit mode.
 * - `isNew`&mdash;The state of the current event.
 */
class EditDialogTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
EditDialogTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditDialogTemplateDirective, deps: [{ token: i0.TemplateRef, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
EditDialogTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: EditDialogTemplateDirective, isStandalone: true, selector: "[kendoSchedulerEditDialogTemplate]", inputs: { autoFocusedElement: "autoFocusedElement" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditDialogTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerEditDialogTemplate]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { autoFocusedElement: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalDataChangesService {
    constructor() {
        this.changes = new EventEmitter();
    }
}
LocalDataChangesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LocalDataChangesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LocalDataChangesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LocalDataChangesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LocalDataChangesService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class DomEventsService {
    constructor() {
        this.focus = new EventEmitter();
        this.focusIn = new EventEmitter();
        this.focusOut = new EventEmitter();
        this.click = new EventEmitter();
        this.keydown = new EventEmitter();
        this.windowBlur = new EventEmitter();
    }
}
DomEventsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DomEventsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DomEventsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DomEventsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DomEventsService, decorators: [{
            type: Injectable
        }] });

/**
 * @hidden
 */
class FocusService {
    constructor(renderer, wrapper, domEvents, zone) {
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.domEvents = domEvents;
        this.zone = zone;
        this.items = new Set();
        this.elementMap = new WeakMap();
        this.subs = new Subscription();
        this.hasContentRendered = false;
        this.subs.add(this.domEvents.focus.subscribe(e => this.onFocusIn(e)));
        this.subs.add(this.domEvents.focusOut.subscribe(() => this.onFocusOut()));
    }
    get activeElement() {
        if (this.activeItem) {
            return this.activeItem.element;
        }
    }
    get focusableItems() {
        return this.items;
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    register(item) {
        if (!this.activeItem) {
            this.activeItem = item;
            item.toggle(true);
        }
        const items = Array.from(this.focusableItems);
        if (item.containerType !== 'content') {
            this.items.add(item);
        }
        else {
            const newContentIndex = items.map(item => item.containerType).lastIndexOf('content') + 1;
            const hasFooter = items.find(item => item.containerType === 'footer');
            if (newContentIndex > 0) {
                // ensure that new events are positioned after the rest of the events for correct navigation sequence
                items.splice(newContentIndex, 0, item);
                this.items = new Set(items);
            }
            else if (hasFooter) {
                // ensure that the first event is before the footer
                items.splice(items.length - 1, 0, item);
                this.items = new Set(items);
            }
            else {
                this.items.add(item);
            }
            // activate the first content element if there is one; otherwise, keep the toolbar or footer active
            if (!this.hasContentRendered) {
                this.activeItem.toggle(false);
                this.activeItem = item;
                item.toggle(true);
                this.hasContentRendered = true;
            }
        }
        this.elementMap.set(item.element.nativeElement, item);
        this.toggleWrapper();
    }
    unregister(item) {
        if (item === this.activeItem) {
            this.activateNext();
        }
        this.items.delete(item);
        this.elementMap.delete(item.element.nativeElement);
        this.toggleWrapper();
    }
    focus() {
        if (this.activeItem) {
            this.activeItem.focus();
        }
        else {
            this.focusContent();
        }
    }
    focusContent() {
        const items = Array.from(this.focusableItems);
        const activeItemContainer = this.activeItem?.containerType;
        const focusableContent = activeItemContainer === 'content' ? this.activeItem : items.find(item => item.containerType === 'content');
        const focusableTool = activeItemContainer === 'toolbar' ? this.activeItem : items.find(item => item.containerType === 'toolbar');
        const itemToFocus = focusableContent || focusableTool;
        itemToFocus.focus();
        this.activeItem = itemToFocus;
    }
    focusToolbar() {
        const items = Array.from(this.focusableItems);
        const firstFocusableTool = items.find(item => item.containerType === 'toolbar');
        // eslint-disable-next-line no-unused-expressions
        firstFocusableTool && firstFocusableTool.focus();
        this.activeItem = firstFocusableTool;
    }
    focusNext(options) {
        const currentItem = this.activeItem;
        this.activateNext(options);
        if (this.activeItem) {
            this.activeItem.focus();
        }
        return this.activeItem !== currentItem;
    }
    focusByIndex(index) {
        const item = Array.from(this.items.values())[index];
        if (!item) {
            return;
        }
        this.activate(item);
        this.focus();
        this.zone.onStable.pipe(take(1)).subscribe(() => {
            const itemToFocus = Array.from(this.items.values())[index];
            if (!itemToFocus) {
                return;
            }
        });
    }
    activate(next) {
        this.items.forEach(item => {
            item.toggle(item === next);
        });
        this.activeItem = next;
    }
    activateNext(position) {
        const next = this.findNext(position);
        this.activeItem = next;
        this.activeItem?.focus();
    }
    findNext(position) {
        const { offset, nowrap } = { nowrap: false, offset: 1, ...position };
        const items = Array.from(this.items.values())
            .filter(item => item.canFocus())
            .sort((a, b) => a.focusIndex - b.focusIndex);
        if (items.length === 0) {
            return null;
        }
        if (!this.activeItem) {
            return nowrap ? null : items[0];
        }
        const index = items.indexOf(this.activeItem);
        let nextIndex = index + offset;
        if (nowrap) {
            nextIndex = Math.max(0, Math.min(items.length - 1, nextIndex));
        }
        else {
            nextIndex = nextIndex % items.length;
            if (nextIndex < 0) {
                nextIndex = items.length - 1;
            }
        }
        return items[nextIndex];
    }
    toggleWrapper() {
        if (this.wrapper) {
            this.renderer.setAttribute(this.wrapper.nativeElement, 'tabindex', this.activeItem ? '-1' : '0');
        }
    }
    onFocusIn(e) {
        const item = this.elementMap.get(e.target);
        if (!item || item === this.focusedItem) {
            return;
        }
        if (this.focusedItem) {
            this.focusedItem.toggleFocus(false);
        }
        this.activate(item);
        item.toggleFocus(true);
        this.focusedItem = item;
    }
    onFocusOut() {
        if (!this.focusedItem) {
            return;
        }
        this.focusedItem.toggleFocus(false);
        this.focusedItem = null;
    }
}
FocusService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusService, deps: [{ token: i0.Renderer2, optional: true }, { token: i0.ElementRef, optional: true }, { token: DomEventsService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
FocusService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Renderer2, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef, decorators: [{
                    type: Optional
                }] }, { type: DomEventsService }, { type: i0.NgZone }]; } });

/**
 * @hidden
 */
class DialogsService {
    constructor(dialogService, localization, changeDetector, focusService, viewState) {
        this.dialogService = dialogService;
        this.localization = localization;
        this.changeDetector = changeDetector;
        this.focusService = focusService;
        this.viewState = viewState;
        this.isOpen = false;
    }
    openRemoveConfirmationDialog() {
        const dialog = this.dialogService.open({
            title: this.textFor('deleteDialogTitle'),
            content: this.textFor('deleteConfirmation'),
            actions: [
                { text: this.textFor('cancel'), value: false },
                { text: this.textFor('destroy'), value: true }
            ],
            appendTo: this.container,
            autoFocusedElement: 'button:nth-child(2)'
        });
        this.isOpen = true;
        this.changeDetector.markForCheck();
        return dialog.result.pipe(map((result) => {
            this.isOpen = false;
            if (result instanceof DialogCloseResult) {
                this.focusService.focus();
                return false;
            }
            this.viewState.layoutEnd.pipe(take(1)).subscribe(() => this.focusService.focus());
            const res = result;
            return res.value;
        }));
    }
    openRecurringConfirmationDialog(operation) {
        const dialog = this.dialogService.open({
            actions: [
                {
                    text: operation === CrudOperation.Edit ? this.textFor('editOccurrence') : this.textFor('deleteOccurrence'),
                    value: EditMode.Occurrence
                },
                {
                    text: operation === CrudOperation.Edit ? this.textFor('editSeries') : this.textFor('deleteSeries'),
                    value: EditMode.Series
                }
            ],
            appendTo: this.container,
            autoFocusedElement: 'button:nth-child(1)',
            content: operation === CrudOperation.Edit ? this.textFor('editRecurringConfirmation') : this.textFor('deleteRecurringConfirmation'),
            title: operation === CrudOperation.Edit ? this.textFor('editRecurringDialogTitle') : this.textFor('deleteRecurringDialogTitle')
        });
        this.isOpen = true;
        this.changeDetector.markForCheck();
        return dialog.result.pipe(map((result) => {
            this.isOpen = false;
            this.focusService.focus();
            if (result instanceof DialogCloseResult) {
                return undefined;
            }
            const res = result;
            return res.value;
        }));
    }
    textFor(key) {
        return this.localization.get(key);
    }
}
DialogsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DialogsService, deps: [{ token: i1.DialogService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: FocusService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Injectable });
DialogsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DialogsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DialogsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.DialogService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: FocusService }, { type: ViewStateService }]; } });

/**
 * @hidden
 */
class SchedulerLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl) {
        super(prefix, messageService, _rtl);
    }
}
SchedulerLocalizationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerLocalizationService, deps: [{ token: L10N_PREFIX }, { token: i1$1.MessageService, optional: true }, { token: RTL, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
SchedulerLocalizationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerLocalizationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerLocalizationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [L10N_PREFIX]
                }] }, { type: i1$1.MessageService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RTL]
                }] }]; } });

/**
 * @hidden
 */
const defaultModelFields = {
    id: 'id',
    start: 'start',
    startTimezone: 'startTimezone',
    end: 'end',
    endTimezone: 'endTimezone',
    isAllDay: 'isAllDay',
    title: 'title',
    description: 'description',
    recurrenceRule: 'recurrenceRule',
    recurrenceId: 'recurrenceId',
    recurrenceExceptions: 'recurrenceExceptions'
};

/**
 * @hidden
 */
class PDFService {
    constructor() {
        this.createElement = new EventEmitter();
        this.exportClick = new EventEmitter();
        this.done = new EventEmitter();
        this.elementReady = new EventEmitter();
    }
    save() {
        if (!hasObservers(this.elementReady)) {
            if (isDevMode()) {
                throw new Error('Creating PDF requires including the PDFModule and adding the <kendo-scheduler-pdf> component.');
            }
            return;
        }
        if (!hasObservers(this.createElement)) {
            if (isDevMode()) {
                throw new Error('No active Scheduler view to export.');
            }
            return;
        }
        this.createElement.emit();
    }
}
PDFService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
PDFService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFService, decorators: [{
            type: Injectable
        }] });

/**
 * The arguments for the `pdfExport` event.
 */
class PDFExportEvent extends PreventableEvent {
}

/**
 * @hidden
 */
class LoadingComponent {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
        this.hostClasses = true;
    }
    get display() {
        return this.loading || this.force ? 'block' : 'none';
    }
    toggle(value) {
        this.force = value;
        this.renderer.setStyle(this.element.nativeElement, 'display', this.display);
    }
}
LoadingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LoadingComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
LoadingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: LoadingComponent, isStandalone: true, selector: "[kendoSchedulerLoading]", inputs: { loading: "loading" }, host: { properties: { "class.k-loading-mask": "this.hostClasses", "style.display": "this.display" } }, ngImport: i0, template: `
        <div class="k-loading-image"></div>
        <div class="k-loading-color"></div>
    `, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LoadingComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerLoading]',
                    template: `
        <div class="k-loading-image"></div>
        <div class="k-loading-color"></div>
    `,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-loading-mask']
            }], loading: [{
                type: Input
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }] } });

/**
 * @hidden
 */
class FocusableDirective {
    constructor(element, renderer, focusService) {
        this.element = element;
        this.renderer = renderer;
        this.focusService = focusService;
        /**
         * The order of the element with respect to the other focusable elements.
         * If multiple elements share the same value, their relative to each other order follows their position in the component tree.
         */
        this.focusIndex = 0;
        this.containerType = 'content';
        this.toggle(false);
    }
    get visible() {
        return this.element.nativeElement.style.display !== 'none';
    }
    get enabled() {
        return !this.element.nativeElement.disabled;
    }
    ngAfterViewChecked() {
        const element = this.element.nativeElement;
        const isViewSelector = element.closest('.k-scheduler-views-wrapper');
        if (!isViewSelector || !isDocumentAvailable()) {
            return;
        }
        // eslint-disable-next-line no-unused-expressions
        isVisible$1(element) ? this.focusService.register(this) : this.focusService.unregister(this);
    }
    ngOnInit() {
        this.focusService.register(this);
    }
    ngOnDestroy() {
        this.focusService.unregister(this);
    }
    toggle(active) {
        if (active !== this.active) {
            const index = active ? '0' : '-1';
            this.renderer.setAttribute(this.element.nativeElement, 'tabIndex', index);
            this.active = active;
        }
    }
    canFocus() {
        return this.visible && this.enabled;
    }
    focus() {
        this.element.nativeElement.focus();
    }
    toggleFocus(value) {
        const element = this.element.nativeElement;
        const focusedClass = element.matches('.k-button-group .k-button') ? 'k-focus' : 'k-selected';
        const renderedEvents = this.element.nativeElement.ownerDocument.querySelectorAll('.k-event');
        const method = value ? 'addClass' : 'removeClass';
        this.renderer[method](element, focusedClass);
        if (renderedEvents.length > 0) {
            const ariaLabel = element.getAttribute('aria-label');
            renderedEvents.forEach((event) => {
                if (event.getAttribute('aria-label') === ariaLabel) {
                    this.renderer[method](event, 'k-selected');
                }
            });
        }
        const selectable = element.matches('.k-scheduler-agendaview .k-scheduler-content .k-selected');
        if (selectable) {
            element.closest('.k-scheduler-agendaview').querySelector('[aria-selected="true"]')?.removeAttribute('aria-selected');
            this.renderer.setAttribute(element, 'aria-selected', value.toString());
        }
    }
}
FocusableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusableDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: FocusService }], target: i0.ɵɵFactoryTarget.Directive });
FocusableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: FocusableDirective, isStandalone: true, selector: "[kendoSchedulerFocusIndex]", inputs: { focusIndex: ["kendoSchedulerFocusIndex", "focusIndex"], containerType: "containerType" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: FocusableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerFocusIndex]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: FocusService }]; }, propDecorators: { focusIndex: [{
                type: Input,
                args: ['kendoSchedulerFocusIndex']
            }], containerType: [{
                type: Input
            }] } });

// TODO: Move to @progress/kendo-common
const toClassList = (classNames) => String(classNames).trim().split(' ');
/**
 * @hidden
 */
const hasClasses = (element, classNames) => {
    const namesList = toClassList(classNames);
    return Boolean(toClassList(element.className).find((className) => namesList.indexOf(className) >= 0));
};
/**
 * @hidden
 */
const matchesClasses = (classNames) => (element) => hasClasses(element, classNames);
/**
 * @hidden
 */
const closest = (node, predicate) => {
    while (node && !predicate(node)) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
const firstElementChild = (node) => {
    const children = node.children;
    const length = children.length;
    for (let idx = 0; idx < length; idx++) {
        if (children[idx].nodeType === 1) {
            return children[idx];
        }
    }
};
/**
 * @hidden
 */
const closestInScope = (node, predicate, scope) => {
    while (node && node !== scope && !predicate(node)) {
        node = node.parentNode;
    }
    if (node !== scope) {
        return node;
    }
};
/**
 * @hidden
 */
const wheelDeltaY = (e) => {
    const deltaY = e.wheelDeltaY;
    if (e.wheelDelta && (deltaY === undefined || deltaY)) {
        return e.wheelDelta;
    }
    else if (e.detail && e.axis === e.VERTICAL_AXIS) {
        return (-e.detail) * 10;
    }
    return 0;
};
/**
 * @hidden
 */
const preventLockedScroll = el => event => {
    const delta = wheelDeltaY(event);
    const scrollTop = el.scrollTop;
    const allowScroll = (scrollTop === 0 && 0 < delta) || (el.scrollHeight <= el.offsetHeight + scrollTop && delta < 0);
    if (!allowScroll) {
        event.preventDefault();
    }
};
/**
 * @hidden
 */
function hasScrollbar(element, type) {
    const sizeField = type === 'vertical' ? 'Height' : 'Width';
    return (element[`scroll${sizeField}`] > element[`client${sizeField}`]) && (scrollbarWidth() > 0);
}
/**
 * @hidden
 */
function rtlScrollPosition(element, position) {
    const initial = element.scrollLeft;
    let result = position;
    element.scrollLeft = -1;
    if (element.scrollLeft < 0) {
        result = -position;
    }
    else if (initial > 0) {
        result = element.scrollWidth - element.offsetWidth - position;
    }
    return result;
}
/**
 * @hidden
 */
const isVisible = (element) => {
    const rect = element.getBoundingClientRect();
    const hasSize = rect.width > 0 && rect.height > 0;
    const hasPosition = rect.x !== 0 && rect.y !== 0;
    // Elements can have zero size due to styling, but they will still count as visible.
    // For example, the selection checkbox has no size, but is made visible through styling.
    return (hasSize || hasPosition) && window.getComputedStyle(element).visibility !== 'hidden';
};

/** @hidden */
const intersects = (startTime, endTime, periodStart, periodEnd) => (startTime < periodStart && endTime > periodEnd) ||
    (periodStart <= startTime && startTime < periodEnd) ||
    (periodStart < endTime && endTime <= periodEnd && startTime < endTime);
/** @hidden */
const dateInRange = (date, start, end) => start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
/** @hidden */
const roundAllDayEnd = ({ start, end }) => {
    const startDate = start.stripTime();
    const endDate = end.stripTime();
    return endDate.getTime() !== end.getTime() || startDate.getTime() === endDate.getTime() ? endDate.addDays(1) : endDate;
};
/** @hidden */
function toInvariantTime(date) {
    const staticDate = new Date(1980, 0, 1, 0, 0, 0);
    if (date) {
        staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
    }
    return staticDate;
}
/**
 * @hidden
 * TODO Move to date-math
 */
const addUTCDays = (date, offset) => {
    const newDate = new Date(date.getTime());
    newDate.setUTCDate(newDate.getUTCDate() + offset);
    return newDate;
};
/**
 * @hidden
 */
function timeOnDate(date, hours = 0, minutes = 0, seconds = 0, ms = 0) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes, seconds, ms);
}
// TODO: name? move to date-math
/** @hidden */
function toUTCTime(localDate, localTime) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localTime.getHours(), localTime.getMinutes(), localTime.getSeconds(), localTime.getMilliseconds()));
}
//  TODO: move to date-math
/** @hidden */
function toUTCDate(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate()));
}
// TODO: move to date-math
/** @hidden */
function getUTCDate(utcDate) {
    return new Date(Date.UTC(utcDate.getUTCFullYear(), utcDate.getUTCMonth(), utcDate.getUTCDate()));
}
// TODO: move to date-math
/** @hidden */
function toUTCDateTime(localDate) {
    return new Date(Date.UTC(localDate.getFullYear(), localDate.getMonth(), localDate.getDate(), localDate.getHours(), localDate.getMinutes(), localDate.getSeconds(), localDate.getMilliseconds()));
}
/** @hidden */
function dateWithTime(target, time) {
    return new Date(target.getFullYear(), target.getMonth(), target.getDate(), time.getHours(), time.getMinutes());
}
/**
 * @hidden
 * Flips the start and end values of a slot selection based on whether
 * the last dragged-over slot is before or after the slot where the selection began.
 */
function normaliseRangeStartAndEnd(selectionOrigin, currentSlot) {
    let start;
    let end;
    if (currentSlot.end <= selectionOrigin.end) {
        end = selectionOrigin.end;
        start = currentSlot.start;
    }
    else {
        start = selectionOrigin.start;
        end = currentSlot.end;
    }
    return { start, end };
}
function getDataIdx(value, resource) {
    const data = resource.data;
    for (let dataIdx = 0; dataIdx < data.length; dataIdx++) {
        if (getField(data[dataIdx], resource.valueField) === value) {
            return dataIdx;
        }
    }
    return -1;
}
function resourceItem(value, resource) {
    const index = getDataIdx(value, resource);
    return index >= 0 ? resource.data[index] : {};
}
function resourceItems(values, resource) {
    return values.map(value => resourceItem(value, resource));
}
function cloneResources(arr) {
    const result = [];
    for (let idx = 0; idx < arr.length; idx++) {
        const clone = Object.assign({}, arr[idx]);
        clone.resources = clone.resources.slice(0);
        result.push(clone);
    }
    return result;
}
/** @hidden */
function resourceItemByValue(event, resource) {
    const value = getField(event, resource.field);
    if (Array.isArray(value)) {
        return resourceItems(value, resource);
    }
    return resourceItem(value, resource);
}
function addNotGroupedResources(event, resources, allResources) {
    for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
        const current = resources[resourceIdx];
        for (let idx = 0; idx < allResources.length; idx++) {
            const item = allResources[idx];
            if (!current.resources[idx] && item.data) {
                current.resources[idx] = resourceItemByValue(event, item);
            }
        }
    }
}
/** @hidden */
function eventResources(event, { taskResources, hasGroups, spans, allResources = [] }) {
    let resources = [];
    for (let resourceIdx = 0; resourceIdx < taskResources.length; resourceIdx++) {
        const resource = taskResources[resourceIdx];
        if (!resource.data) {
            resources = [{ leafIdx: 0, resources: [] }];
            continue;
        }
        const resourceIndex = allResources.indexOf(resource);
        let values = getField(event, resource.field);
        if (!Array.isArray(values)) {
            values = [values];
        }
        const expandedResources = [];
        for (let valueIdx = 0; valueIdx < values.length; valueIdx++) {
            const dataIdx = getDataIdx(values[valueIdx], resource);
            if (dataIdx < 0) {
                if (hasGroups) {
                    // No match for this resource, but the event might still match other resources.
                    continue;
                }
                return [{ leafIdx: 0, resources: [] }];
            }
            const item = resource.data[dataIdx];
            // has groups - need all copies of the multiple resource
            // no groups - just the first
            if (resourceIdx === 0 && (hasGroups || valueIdx === 0)) {
                const resourceItems = [];
                resourceItems[resourceIndex] = resource.multiple && !hasGroups ? [item] : item;
                resources.push({
                    leafIdx: hasGroups ? dataIdx * spans[resourceIdx] : 0,
                    color: getField(item, resource.colorField),
                    resources: resourceItems
                });
            }
            else if (hasGroups) { // don't create multiple resource groups if no groups for multiple resources
                let currentResources = resources;
                if (values.length > 1) {
                    currentResources = cloneResources(resources);
                    expandedResources.push(...currentResources);
                }
                for (let currentIdx = 0; currentIdx < currentResources.length; currentIdx++) {
                    currentResources[currentIdx].leafIdx += dataIdx * spans[resourceIdx];
                    currentResources[currentIdx].resources[resourceIndex] = item;
                }
            }
            else if (valueIdx > 0) {
                for (let idx = 0; idx < resources.length; idx++) {
                    resources[idx].resources[resourceIndex].push(item);
                }
            }
        }
        if (expandedResources.length) {
            resources = expandedResources;
        }
    }
    addNotGroupedResources(event, resources, allResources);
    return resources;
}
/** @hidden */
function assignTasksResources(tasks, options) {
    for (let idx = 0; idx < tasks.length; idx++) {
        const task = tasks[idx];
        task.resources = eventResources(task.event, options);
    }
}
/**
 * @hidden
 */
function isEmptyResource(resources) {
    return Array.isArray(resources) && resources.length === 1 && resources[0] === undefined;
}
/**
 * @hidden
 */
function resourcesMatch(res1, res2) {
    if (res1.length !== res2.length) {
        return false;
    }
    if (isEmptyResource(res1) && isEmptyResource(res2)) {
        return true;
    }
    return res1.every(r1 => res2.some(r2 => r2.value === r1.value));
}
/**
 * @hidden
 */
function isSameRange(range1, range2) {
    return (range1.start.getTime() === range2.start.getTime() &&
        range1.end.getTime() === range2.end.getTime() &&
        range1.isAllDay === range2.isAllDay &&
        resourcesMatch(range1.resources, range2.resources));
}
/** @hidden */
function findRowIndex(events, data) {
    if (data.rowIndex !== undefined) {
        return data.rowIndex;
    }
    for (let idx = 0; idx < events.length; idx++) {
        if (!events[idx]) {
            return idx;
        }
    }
    return events.length;
}
/** @hidden */
function isRecurrence(task) {
    return Boolean(task.event && task.event.recurrenceRule);
}
/** @hidden */
function isRecurrenceException(task) {
    return task.event && isPresent(task.event.recurrenceId) && !task.event.recurrenceRule;
}
/** @hidden */
const rectContains = (rect, left, top, scaleX = 1) => rect.left * scaleX <= left && left <= rect.left * scaleX + rect.width * scaleX && rect.top * scaleX <= top && top <= rect.top * scaleX + rect.height * scaleX;
/** @hidden */
const rectContainsX = (rect, left, scaleX = 1) => rect.left * scaleX <= left && left <= rect.left * scaleX + rect.width * scaleX;
/** @hidden */
const toPx = value => `${value}px`;
/** @hidden */
const elementOffset = (element) => {
    if (!element) {
        return null;
    }
    const box = element.getBoundingClientRect();
    const documentElement = document.documentElement;
    return {
        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
        width: box.width,
        height: box.height
    };
};
/** @hidden */
const pointDistance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
/** @hidden */
const ignoreContentChild = child => child.nodeName === 'KENDO-RESIZE-SENSOR' || hasClasses(child, 'k-loading-mask');
/** @hidden */
const setCoordinates = (element, coordinates) => {
    for (const field in coordinates) {
        if (coordinates.hasOwnProperty(field)) {
            element.style[field] = toPx(coordinates[field]);
        }
    }
};
/** @hidden */
const convertNgClassBindings = (bindingValues) => {
    const result = [];
    if (isString(bindingValues)) {
        result.push(bindingValues);
    }
    else if (isArray(bindingValues)) {
        result.push(...bindingValues);
    }
    else if (isObject(bindingValues)) {
        for (const field in bindingValues) {
            if (bindingValues.hasOwnProperty(field) && bindingValues[field]) {
                result.push(field);
            }
        }
    }
    return result;
};
/**
 * @hidden
 */
function formatEventTime(start, end, isAllDay, localeId) {
    const dateFormat = { skeleton: 'yMMMMEEEEd' };
    const timeFormat = 't';
    const startFormat = formatEventStart(start, dateFormat, timeFormat, isAllDay, localeId);
    const endFormat = formatEventEnd(start, end, dateFormat, timeFormat, localeId);
    return isAllDay ?
        `${startFormat}` :
        `${startFormat}-${endFormat}`;
}
/**
 * @hidden
 */
function formValueOrDefault(group, field, defaultValue) {
    const control = group.get(field);
    if (!control) {
        return defaultValue;
    }
    return control.value || defaultValue;
}
/**
 * @hidden
 */
const isWorkWeekDay = (day, start, end) => {
    if (end < start) {
        return day <= end || start <= day;
    }
    return start <= day && day <= end;
};
/**
 * @hidden
 */
const alwaysFalse = () => false;
/**
 * @hidden
 */
const formatEventStart = (start, dateFormat, timeFormat, isAllDay, localeId) => {
    let startFormat = `${formatDate(start, dateFormat, localeId)}`;
    // the time is relevant only when the event isn't an all day event
    if (!isAllDay) {
        startFormat += `, ${formatDate(start, timeFormat, localeId)}`;
    }
    return startFormat;
};
/**
 * @hidden
 */
const formatEventEnd = (start, end, dateFormat, timeFormat, localeId) => {
    let endFormat = '';
    // the end date is relevant only when the event ends on a different day from when it starts
    if (!isEqualDate(start, end)) {
        endFormat = `${formatDate(end, dateFormat, localeId)}, `;
    }
    endFormat += `${formatDate(end, timeFormat, localeId)}`;
    return endFormat;
};

/**
 * @hidden
 */
class ResourceEditorBase {
    constructor() {
        this.valueChange = new EventEmitter();
        this.getField = getField;
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
    }
    /**
     * @hidden
     */
    writeValue(newValue) {
        this.resourceValue = newValue;
    }
    getResourceStyle(dataItem) {
        return {
            'background-color': getField(dataItem, this.resource.colorField),
            'margin-right': isPresent(getField(dataItem, this.resource.valueField)) ? '8px' : '4px'
        };
    }
    onResourceValueChange(newValue) {
        this.resourceValue = newValue;
        this.emitChange(this.resourceValue);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    emitChange(value) {
        this.onChangeCallback(value);
        this.valueChange.emit(value);
    }
}
ResourceEditorBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResourceEditorBase, deps: [], target: i0.ɵɵFactoryTarget.Directive });
ResourceEditorBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: ResourceEditorBase, inputs: { resource: "resource" }, outputs: { valueChange: "valueChange" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResourceEditorBase, decorators: [{
            type: Directive
        }], propDecorators: { resource: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const MULTIPLE_RESOURCE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => MultipleResourceEditorComponent)
};
/**
 * @hidden
 */
class MultipleResourceEditorComponent extends ResourceEditorBase {
    getTagStyle(dataItem) {
        return {
            'background-color': dataItem[this.resource.colorField]
        };
    }
    focus() {
        this.resourceMultiSelect.focus();
    }
}
MultipleResourceEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultipleResourceEditorComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
MultipleResourceEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MultipleResourceEditorComponent, isStandalone: true, selector: "kendo-multiple-resource-editor", providers: [
        MULTIPLE_RESOURCE_VALUE_ACCESSOR
    ], viewQueries: [{ propertyName: "resourceMultiSelect", first: true, predicate: ["resourceMultiSelect"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
        <kendo-multiselect
            #resourceMultiSelect
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
            <ng-template kendoMultiSelectTagTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getTagStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-multiselect>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiSelectComponent, selector: "kendo-multiselect", inputs: ["showStickyHeader", "focusableId", "autoClose", "loading", "data", "value", "valueField", "textField", "tabindex", "tabIndex", "size", "rounded", "fillMode", "placeholder", "adaptiveMode", "title", "subtitle", "disabled", "itemDisabled", "checkboxes", "readonly", "filterable", "virtual", "popupSettings", "listHeight", "valuePrimitive", "clearButton", "tagMapper", "allowCustom", "valueNormalizer", "inputAttributes"], outputs: ["filterChange", "valueChange", "open", "opened", "close", "closed", "focus", "blur", "inputFocus", "inputBlur", "removeTag"], exportAs: ["kendoMultiSelect"] }, { kind: "directive", type: ItemTemplateDirective, selector: "[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TagTemplateDirective, selector: "[kendoMultiSelectTagTemplate],[kendoMultiSelectTreeTagTemplate]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultipleResourceEditorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        MULTIPLE_RESOURCE_VALUE_ACCESSOR
                    ],
                    selector: 'kendo-multiple-resource-editor',
                    template: `
        <kendo-multiselect
            #resourceMultiSelect
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
            <ng-template kendoMultiSelectTagTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getTagStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-multiselect>
    `,
                    standalone: true,
                    imports: [MultiSelectComponent, ItemTemplateDirective, NgIf, NgStyle, TagTemplateDirective]
                }]
        }], propDecorators: { resourceMultiSelect: [{
                type: ViewChild,
                args: ['resourceMultiSelect', { static: true }]
            }] } });

/**
 * @hidden
 */
const SINGLE_RESOURCE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SingleResourceEditorComponent)
};
/**
 * @hidden
 */
class SingleResourceEditorComponent extends ResourceEditorBase {
    focus() {
        this.resourceDropDown.focus();
    }
}
SingleResourceEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SingleResourceEditorComponent, deps: null, target: i0.ɵɵFactoryTarget.Component });
SingleResourceEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: SingleResourceEditorComponent, isStandalone: true, selector: "kendo-single-resource-editor", providers: [
        SINGLE_RESOURCE_VALUE_ACCESSOR
    ], viewQueries: [{ propertyName: "resourceDropDown", first: true, predicate: ["resourceDropDown"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
        <kendo-dropdownlist
            #resourceDropDown
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-dropdownlist>
    `, isInline: true, dependencies: [{ kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "directive", type: ItemTemplateDirective, selector: "[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SingleResourceEditorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        SINGLE_RESOURCE_VALUE_ACCESSOR
                    ],
                    selector: 'kendo-single-resource-editor',
                    template: `
        <kendo-dropdownlist
            #resourceDropDown
            [data]='resource.data'
            [textField]='resource.textField'
            [valueField]='resource.valueField'
            [valuePrimitive]='true'
            [value]='resourceValue'
            (valueChange)='onResourceValueChange($event)'
        >
            <ng-template kendoDropDownListItemTemplate let-dataItem>
                <span *ngIf="resource.colorField" class="k-scheduler-mark"
                [ngStyle]="getResourceStyle(dataItem)"></span>
                {{ getField(dataItem, resource.textField) }}
            </ng-template>
        </kendo-dropdownlist>
    `,
                    standalone: true,
                    imports: [DropDownListComponent, ItemTemplateDirective, NgIf, NgStyle]
                }]
        }], propDecorators: { resourceDropDown: [{
                type: ViewChild,
                args: ['resourceDropDown', { static: true }]
            }] } });

// eslint-disable no-bitwise
/**
 * @hidden
 */
var Modifiers;
(function (Modifiers) {
    Modifiers[Modifiers["None"] = 0] = "None";
    Modifiers[Modifiers["AltKey"] = 1] = "AltKey";
    Modifiers[Modifiers["CtrlKey"] = 2] = "CtrlKey";
    Modifiers[Modifiers["ShiftKey"] = 4] = "ShiftKey";
    Modifiers[Modifiers["MetaKey"] = 8] = "MetaKey";
})(Modifiers || (Modifiers = {}));
/**
 * @hidden
 */
function withModifiers(e, modifiers) {
    return e.altKey === ((modifiers & Modifiers.AltKey) === Modifiers.AltKey) &&
        e.ctrlKey === ((modifiers & Modifiers.CtrlKey) === Modifiers.CtrlKey) &&
        e.shiftKey === ((modifiers & Modifiers.ShiftKey) === Modifiers.ShiftKey) &&
        e.metaKey === ((modifiers & Modifiers.MetaKey) === Modifiers.MetaKey);
}
/**
 * @hidden
 */
function noModifiers(e) {
    return withModifiers(e, Modifiers.None);
}

let uniqueIdCounter = 0;
const offsetPositions = ['first', 'second', 'third', 'fourth', 'last'];
const frequencies = ['never', 'daily', 'weekly', 'monthly', 'yearly'];
/**
 * @hidden
 */
const dayRule = [
    { day: 0, offset: 0 },
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 },
    { day: 6, offset: 0 }
];
/**
 * @hidden
 */
const weekdayRule = [
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 }
];
/**
 * @hidden
 */
const weekendRule = [
    { day: 0, offset: 0 },
    { day: 6, offset: 0 }
];
/**
 * @hidden
 *
 * The internal service for handling changes in the RecurrenceEditor component.
 */
class RecurrenceService {
    constructor(intl, localization) {
        this.intl = intl;
        this.localization = localization;
        this.change = new EventEmitter();
        this.endRuleChange = new EventEmitter();
        this.frequencyChange = new EventEmitter();
        this.repeatOnRuleChange = new EventEmitter();
    }
    init(rrule = "", start, timezone, weekStart) {
        this.start = start;
        this.timezone = timezone;
        this.weekStart = weekStart;
        this.rrule = parseRule({
            recurrenceRule: rrule,
            weekStart: weekStart
        });
    }
    /**
     * @hidden
     */
    getUniqueId() {
        return uniqueIdCounter++;
    }
    get frequencies() {
        return frequencies.map((freq) => ({
            value: freq,
            text: this.localization.get('frequencies' + capitalize(freq))
        }));
    }
    get frequency() {
        if (isPresent(this.rrule) && !isNullOrEmptyString(this.rrule.freq)) {
            return this.rrule.freq;
        }
        return 'never';
    }
    setFrequency(freq) {
        this.rrule = {};
        this.rrule.freq = freq;
        this.rrule.interval = 1;
        if (freq === 'weekly') {
            this.rrule.byWeekDay = [{
                    day: this.start.getDay(),
                    offset: 0
                }];
        }
        if (freq === 'monthly' || freq === 'yearly') {
            this.rrule.byMonthDay = [this.start.getDate()];
        }
        if (freq === 'yearly') {
            this.rrule.byMonth = [this.start.getMonth() + 1];
        }
        this.frequencyChange.emit();
        this.onChange();
    }
    set interval(newInterval) {
        this.rrule.interval = newInterval;
        this.onChange();
    }
    set count(newCount) {
        this.rrule.count = newCount;
        this.onChange();
    }
    set until(newUntil) {
        this.rrule.until = ZonedDate.fromLocalDate(newUntil, this.timezone);
        this.onChange();
    }
    get until() {
        if (isPresent(this.rrule.until)) {
            return toLocalDate(this.rrule.until);
        }
    }
    setWeekDays(newWeekDays) {
        this.rrule.byWeekDay = newWeekDays;
        this.onChange();
    }
    set monthDays(newMonthDays) {
        this.rrule.byMonthDay = newMonthDays;
        this.onChange();
    }
    set positions(newPositions) {
        this.rrule.bySetPosition = newPositions;
        this.onChange();
    }
    setMonths(newMonths) {
        this.rrule.byMonth = newMonths;
        this.onChange();
    }
    get months() {
        return this.intl.dateFormatNames({
            type: 'months',
            nameType: 'wide'
        }).map((month, idx) => ({
            text: month,
            value: idx + 1
        }));
    }
    /*
        ToDo Refactor weekDays and extendedWeekDays getters into a single method
    */
    get weekDays() {
        const firstDay = this.weekStart;
        const abbrNames = this.intl.dateFormatNames({
            type: 'days',
            nameType: 'abbreviated'
        }).map((day, idx) => ({
            text: day,
            value: idx
        }));
        /* Sorting according to first week day */
        return (abbrNames.slice(firstDay)).concat(abbrNames.slice(0, firstDay));
    }
    get extendedWeekDays() {
        const firstDay = this.weekStart;
        const wideNames = this.intl.dateFormatNames({
            type: 'days',
            nameType: 'wide'
        }).map((day, idx) => ({
            text: day,
            value: idx
        }));
        const sortedWideNames = (wideNames.slice(firstDay)).concat(wideNames.slice(0, firstDay));
        const specialRules = [
            { text: this.localization.get('weekdaysDay'), value: 'day' },
            { text: this.localization.get('weekdaysWeekday'), value: 'weekday' },
            { text: this.localization.get('weekdaysWeekendday'), value: 'weekend' }
        ];
        return specialRules.concat(sortedWideNames);
    }
    get offsetPositions() {
        const values = [1, 2, 3, 4, -1];
        return offsetPositions.map((offset, idx) => ({
            text: this.localization.get('offsetPositions' + capitalize(offset)),
            value: values[idx]
        }));
    }
    get endRule() {
        if (isPresent(this.rrule.count)) {
            return 'count';
        }
        else if (isPresent(this.rrule.until)) {
            return 'until';
        }
        else {
            return 'never';
        }
    }
    set endRule(endRule) {
        if (endRule === 'count') {
            this.rrule.until = null;
        }
        else if (endRule === 'until') {
            this.rrule.count = null;
        }
        else {
            /* never */
            this.rrule.count = null;
            this.rrule.until = null;
        }
        this.endRuleChange.emit(endRule);
        this.onChange();
    }
    get repeatOnRule() {
        if (isPresent(this.rrule.byWeekDay)) {
            return 'weekday';
        }
        else if (isPresent(this.rrule.byMonthDay)) {
            return 'monthday';
        }
        return null;
    }
    set repeatOnRule(repeatOnRule) {
        if (repeatOnRule === 'monthday') {
            this.rrule.byWeekDay = null;
            this.rrule.bySetPosition = null;
        }
        else {
            /* weekDays */
            this.rrule.byMonthDay = null;
        }
        this.repeatOnRuleChange.emit(repeatOnRule);
        this.onChange();
    }
    onChange() {
        if (this.frequency === 'never') {
            this.change.emit(null);
        }
        else {
            this.change.emit(serializeRule(this.rrule, this.timezone));
        }
    }
}
RecurrenceService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceService, deps: [{ token: i1$2.IntlService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Injectable });
RecurrenceService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: i1$1.LocalizationService }]; } });

/**
 * @hidden
 */
class RecurrenceLocalizationService extends LocalizationService {
    constructor(prefix, messageService, _rtl, schedulerLocalization) {
        super(prefix, messageService, _rtl);
        this.schedulerLocalization = schedulerLocalization;
    }
    get(shortKey) {
        if (this.schedulerLocalization) {
            return this.schedulerLocalization.get('recurrenceEditor' + capitalize(shortKey));
        }
        return super.get(shortKey);
    }
}
RecurrenceLocalizationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceLocalizationService, deps: [{ token: L10N_PREFIX }, { token: i1$1.MessageService, optional: true }, { token: RTL, optional: true }, { token: SchedulerLocalizationService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
RecurrenceLocalizationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceLocalizationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceLocalizationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [L10N_PREFIX]
                }] }, { type: i1$1.MessageService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RTL]
                }] }, { type: SchedulerLocalizationService, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [SchedulerLocalizationService]
                }] }]; } });

/**
 * @hidden
 */
class EndRuleRadioButtonDirective {
    constructor(el, renderer, recurrence, changeDetector) {
        this.el = el;
        this.renderer = renderer;
        this.recurrence = recurrence;
        this.changeDetector = changeDetector;
        this.type = 'radio';
        this.radioClass = true;
        this.radioSizeClass = true;
        this.destroyClick = this.renderer.listen(this.elem, 'click', this.onClick.bind(this));
    }
    ngOnInit() {
        this.endRule = this.endRuleId.split('-')[2];
        this.renderer.setAttribute(this.elem, 'id', this.endRuleId);
        this.renderer.setAttribute(this.elem, 'name', `end-${this.endRuleId.split('-').pop()}`);
    }
    ngAfterContentChecked() {
        this.setCheckedState();
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
    }
    onClick() {
        if (this.elem.checked) {
            this.recurrence.endRule = this.endRule;
            this.changeDetector.markForCheck();
        }
    }
    setCheckedState() {
        const isChecked = this.endRule === this.recurrence.endRule;
        this.renderer.setProperty(this.elem, 'checked', isChecked);
    }
    get elem() {
        return this.el.nativeElement;
    }
}
EndRuleRadioButtonDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EndRuleRadioButtonDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: RecurrenceService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
EndRuleRadioButtonDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: EndRuleRadioButtonDirective, isStandalone: true, selector: "[kendoRecurrenceEndRuleRadioButton]", inputs: { endRuleId: ["kendoRecurrenceEndRuleRadioButton", "endRuleId"] }, host: { properties: { "attr.type": "this.type", "class.k-radio": "this.radioClass", "class.k-radio-md": "this.radioSizeClass" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EndRuleRadioButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoRecurrenceEndRuleRadioButton]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: RecurrenceService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { type: [{
                type: HostBinding,
                args: ['attr.type']
            }], radioClass: [{
                type: HostBinding,
                args: ['class.k-radio']
            }], radioSizeClass: [{
                type: HostBinding,
                args: ['class.k-radio-md']
            }], endRuleId: [{
                type: Input,
                args: ["kendoRecurrenceEndRuleRadioButton"]
            }] } });

/**
 * @hidden
 */
class RecurrenceEndRuleEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
        this.cssClass = true;
        this.numericOptions = {
            min: 1,
            format: '#',
            autoCorrect: true,
            step: 1,
            spinners: true
        };
        this.datePickerOptions = {
            activeView: 'month',
            bottomView: 'month',
            topView: 'century',
            disabledDatesValidation: true,
            navigation: true,
            format: 'd'
        };
        this.uniqueId = this.recurrence.getUniqueId();
        this.setInitialValues();
        this.subscribeChanges();
    }
    set userNumericOptions(options) {
        this.numericOptions = { ...this.numericOptions, ...options };
    }
    set userDatePickerOptions(options) {
        this.datePickerOptions = { ...this.datePickerOptions, ...options };
    }
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    setEndRule(endRule) {
        if (endRule === 'count') {
            this.recurrence.rrule.count = this.countValue;
        }
        else if (endRule === 'until') {
            this.recurrence.until = this.untilValue;
        }
    }
    get rrule() {
        return this.recurrence.rrule;
    }
    get isCountDisabled() {
        return this.recurrence.endRule !== 'count';
    }
    get isUntilDisabled() {
        return this.recurrence.endRule !== 'until';
    }
    onCountChange(value) {
        if (isPresent(value)) {
            this.recurrence.count = value;
        }
    }
    onCountBlur() {
        if (!isPresent(this.countValue)) {
            this.recurrence.count = this.countValue = 1;
        }
    }
    onUntilChange(value) {
        if (isPresent(value)) {
            this.recurrence.until = this.createUntil(value);
        }
    }
    onUntilBlur() {
        if (!isPresent(this.untilValue)) {
            this.recurrence.until = this.untilValue = this.createUntil(this.recurrence.start);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onEndLabelClick() {
        const selected = this.endRuleRadioButtons.toArray().find(r => r.elem.checked);
        if (selected) {
            selected.elem.focus();
        }
    }
    setInitialValues() {
        this.countValue = this.rrule.count || 1;
        const currentUntil = this.recurrence.until;
        const currentStart = this.recurrence.start;
        this.untilValue = isPresent(currentUntil) ? currentUntil : this.createUntil(currentStart);
    }
    subscribeChanges() {
        this.subscriptions = this.recurrence.endRuleChange.subscribe((endRule) => {
            this.setEndRule(endRule);
        });
        this.subscriptions.add(this.recurrence.frequencyChange.subscribe(() => {
            this.setInitialValues();
        }));
    }
    createUntil(until) {
        // Read the until date as UTC date parts to avoid interfering with the local time zone.
        const untilDate = toUTCDate(until);
        // Set the time to the end of the day
        untilDate.setUTCHours(23);
        untilDate.setUTCMinutes(59);
        untilDate.setUTCSeconds(59);
        // Convert to the scheduler time zone.
        return ZonedDate.fromUTCDate(untilDate, this.recurrence.timezone).toLocalDate();
    }
}
RecurrenceEndRuleEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEndRuleEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceEndRuleEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceEndRuleEditorComponent, isStandalone: true, selector: "kendo-recurrence-end-rule-editor", inputs: { userNumericOptions: "userNumericOptions", userDatePickerOptions: "userDatePickerOptions" }, host: { properties: { "class.k-scheduler-recurrence-end-rule-editor": "this.cssClass" } }, viewQueries: [{ propertyName: "endRuleRadioButtons", predicate: EndRuleRadioButtonDirective, descendants: true }], ngImport: i0, template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('endLabel')"
                (click)="onEndLabelClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-never-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-never-{{uniqueId}}'>{{ textFor('endNever') }}</label>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-count-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-count-{{uniqueId}}'>{{ textFor('endAfter') }}</label>
                        <kendo-numerictextbox
                            #afterOccurances
                            class="k-recur-count"
                            [style.width.px]='70'
                            [autoCorrect]='numericOptions.autoCorrect'
                            [decimals]='0'
                            [disabled]='isCountDisabled'
                            [format]="numericOptions.format"
                            [min]='numericOptions.min'
                            [max]="numericOptions.max"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [(value)]='countValue'
                            (blur)="onCountBlur()"
                            (valueChange)='onCountChange($event)'
                        >
                            <kendo-numerictextbox-messages
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                        <span>{{ textFor('endOccurrence') }}</span>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-until-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-until-{{uniqueId}}'>{{ textFor('endOn') }}</label>
                        <kendo-datepicker
                            class="k-recur-until"
                            [style.width.px]='150'
                            [clearButton]="true"
                            [disabled]='isUntilDisabled'
                            [activeView]="datePickerOptions.activeView"
                            [bottomView]="datePickerOptions.bottomView"
                            [disabledDatesValidation]="datePickerOptions.disabledDatesValidation"
                            [focusedDate]="datePickerOptions.focusedDate"
                            [format]="datePickerOptions.format"
                            [formatPlaceholder]="datePickerOptions.formatPlaceHolder"
                            [max]="datePickerOptions.max"
                            [min]="datePickerOptions.min"
                            [navigation]="datePickerOptions.navigation"
                            [placeholder]="datePickerOptions.placeholder"
                            [readOnlyInput]="datePickerOptions.readOnlyInput"
                            [readonly]="datePickerOptions.readonly"
                            [title]="datePickerOptions.title"
                            [topView]="datePickerOptions.topView"
                            [weekNumber]="datePickerOptions.weekNumber"
                            [disabledDates]="datePickerOptions.disabledDates"
                            [popupSettings]="datePickerOptions.popupSettings"
                            [(value)]='untilValue'
                            (blur)="onUntilBlur()"
                            (valueChange)='onUntilChange($event)'
                        >
                            <kendo-datepicker-messages
                                [today]="textFor('dateInputsToday')"
                                [toggle]="textFor('dateInputsToggle')"
                                [parentViewButtonTitle]="textFor('dateInputsParentViewButton')"
                            >
                            </kendo-datepicker-messages>
                        </kendo-datepicker>
                    </li>
                </ul>
            </div>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "directive", type: EndRuleRadioButtonDirective, selector: "[kendoRecurrenceEndRuleRadioButton]", inputs: ["kendoRecurrenceEndRuleRadioButton"] }, { kind: "directive", type: LabelDirective, selector: "label[for]", inputs: ["for", "labelClass"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "title", "subtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEndRuleEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-recurrence-end-rule-editor',
                    template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('endLabel')"
                (click)="onEndLabelClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-never-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-never-{{uniqueId}}'>{{ textFor('endNever') }}</label>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-count-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-count-{{uniqueId}}'>{{ textFor('endAfter') }}</label>
                        <kendo-numerictextbox
                            #afterOccurances
                            class="k-recur-count"
                            [style.width.px]='70'
                            [autoCorrect]='numericOptions.autoCorrect'
                            [decimals]='0'
                            [disabled]='isCountDisabled'
                            [format]="numericOptions.format"
                            [min]='numericOptions.min'
                            [max]="numericOptions.max"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [(value)]='countValue'
                            (blur)="onCountBlur()"
                            (valueChange)='onCountChange($event)'
                        >
                            <kendo-numerictextbox-messages
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                        <span>{{ textFor('endOccurrence') }}</span>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceEndRuleRadioButton='k-endrule-until-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-endrule-until-{{uniqueId}}'>{{ textFor('endOn') }}</label>
                        <kendo-datepicker
                            class="k-recur-until"
                            [style.width.px]='150'
                            [clearButton]="true"
                            [disabled]='isUntilDisabled'
                            [activeView]="datePickerOptions.activeView"
                            [bottomView]="datePickerOptions.bottomView"
                            [disabledDatesValidation]="datePickerOptions.disabledDatesValidation"
                            [focusedDate]="datePickerOptions.focusedDate"
                            [format]="datePickerOptions.format"
                            [formatPlaceholder]="datePickerOptions.formatPlaceHolder"
                            [max]="datePickerOptions.max"
                            [min]="datePickerOptions.min"
                            [navigation]="datePickerOptions.navigation"
                            [placeholder]="datePickerOptions.placeholder"
                            [readOnlyInput]="datePickerOptions.readOnlyInput"
                            [readonly]="datePickerOptions.readonly"
                            [title]="datePickerOptions.title"
                            [topView]="datePickerOptions.topView"
                            [weekNumber]="datePickerOptions.weekNumber"
                            [disabledDates]="datePickerOptions.disabledDates"
                            [popupSettings]="datePickerOptions.popupSettings"
                            [(value)]='untilValue'
                            (blur)="onUntilBlur()"
                            (valueChange)='onUntilChange($event)'
                        >
                            <kendo-datepicker-messages
                                [today]="textFor('dateInputsToday')"
                                [toggle]="textFor('dateInputsToggle')"
                                [parentViewButtonTitle]="textFor('dateInputsParentViewButton')"
                            >
                            </kendo-datepicker-messages>
                        </kendo-datepicker>
                    </li>
                </ul>
            </div>
        </div>
    `,
                    standalone: true,
                    imports: [LabelComponent, EndRuleRadioButtonDirective, LabelDirective, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, DatePickerComponent, DatePickerCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$1.LocalizationService }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.k-scheduler-recurrence-end-rule-editor']
            }], userNumericOptions: [{
                type: Input
            }], userDatePickerOptions: [{
                type: Input
            }], endRuleRadioButtons: [{
                type: ViewChildren,
                args: [EndRuleRadioButtonDirective]
            }] } });

/**
 * @hidden
 */
class RepeatOnRadioButtonDirective {
    constructor(el, renderer, recurrence, changeDetector) {
        this.el = el;
        this.renderer = renderer;
        this.recurrence = recurrence;
        this.changeDetector = changeDetector;
        this.type = 'radio';
        this.radioClass = true;
        this.radioSizeClass = true;
        this.destroyClick = this.renderer.listen(this.elem, 'click', this.onClick.bind(this));
    }
    set repeatOnRule(value) {
        const parts = value.split('-');
        this._repeatOnRule = parts[0];
        this._uniqueId = parts[1];
    }
    ngOnInit() {
        this.renderer.setAttribute(this.elem, 'id', `k-repeaton-${this._repeatOnRule}-${this._uniqueId}`);
        this.renderer.setAttribute(this.elem, 'name', `day-${this._uniqueId}`);
    }
    ngAfterContentChecked() {
        this.setCheckedState();
    }
    ngOnDestroy() {
        if (this.destroyClick) {
            this.destroyClick();
        }
    }
    onClick() {
        if (this.elem.checked) {
            this.recurrence.repeatOnRule = this._repeatOnRule;
            this.changeDetector.markForCheck();
        }
    }
    setCheckedState() {
        const isChecked = this._repeatOnRule === this.recurrence.repeatOnRule;
        this.renderer.setProperty(this.elem, 'checked', isChecked);
    }
    get elem() {
        return this.el.nativeElement;
    }
}
RepeatOnRadioButtonDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RepeatOnRadioButtonDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: RecurrenceService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
RepeatOnRadioButtonDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: RepeatOnRadioButtonDirective, isStandalone: true, selector: "[kendoRecurrenceRepeatOnRadioButton]", inputs: { repeatOnRule: ["kendoRecurrenceRepeatOnRadioButton", "repeatOnRule"] }, host: { properties: { "attr.type": "this.type", "class.k-radio": "this.radioClass", "class.k-radio-md": "this.radioSizeClass" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RepeatOnRadioButtonDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoRecurrenceRepeatOnRadioButton]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: RecurrenceService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { type: [{
                type: HostBinding,
                args: ['attr.type']
            }], radioClass: [{
                type: HostBinding,
                args: ['class.k-radio']
            }], radioSizeClass: [{
                type: HostBinding,
                args: ['class.k-radio-md']
            }], repeatOnRule: [{
                type: Input,
                args: ["kendoRecurrenceRepeatOnRadioButton"]
            }] } });

/**
 * @hidden
 */
class RecurrenceMonthlyYearlyEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
        this.uniqueId = this.recurrence.getUniqueId();
        this.numericOptions = {
            min: 1,
            max: 31,
            format: '#',
            autoCorrect: true,
            step: 1,
            spinners: true
        };
        this.setInitialValues();
        this.subscribeEventHandlers();
    }
    set userNumericOptions(options) {
        this.numericOptions = { ...this.numericOptions, ...options };
    }
    setInitialValues() {
        this.extendedWeekDays = this.recurrence.extendedWeekDays;
        this.offsetPositions = this.recurrence.offsetPositions;
        this.currentOffset = this.defaultOffset;
        this.currentWeekDay = this.defaultWeekDay;
        if (this.currentFreq === 'yearly') {
            this.months = this.recurrence.months;
            this.currentMonthMonthDay = this.currentMonthWeekDay = this.recurrence.rrule.byMonth[0];
        }
    }
    subscribeEventHandlers() {
        this.subs = this.recurrence.repeatOnRuleChange.subscribe(this.onRepeatOnRuleChange.bind(this));
        this.subs.add(this.recurrence.frequencyChange.subscribe(this.onFrequencyChange.bind(this)));
    }
    onRepeatOnRuleChange(newRepeatOnRule) {
        if (newRepeatOnRule === 'monthday') {
            this.recurrence.rrule.byMonthDay = [this.monthDay];
            if (this.currentFreq === 'yearly') {
                this.recurrence.rrule.byMonth = [this.currentMonthMonthDay];
            }
        }
        else if (newRepeatOnRule === 'weekday') {
            if (typeof this.weekDay === 'string') {
                /* day, weekday or weekend */
                this.recurrence.rrule.bySetPosition = [this.offset];
                this.recurrence.rrule.byWeekDay = this.weekDayRuleFromString(this.weekDay);
            }
            else {
                /* specific weekday */
                this.recurrence.rrule.byWeekDay = [{
                        day: this.weekDay,
                        offset: this.offset
                    }];
            }
            if (this.currentFreq === 'yearly') {
                this.recurrence.rrule.byMonth = [this.currentMonthWeekDay];
            }
        }
    }
    onFrequencyChange() {
        this.setInitialValues();
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    get monthDay() {
        const rrule = this.recurrence.rrule;
        if (isPresent(rrule.byMonthDay) && rrule.byMonthDay.length > 0) {
            return rrule.byMonthDay[0];
        }
        else if (isPresent(this.currentMonthDay)) {
            return this.currentMonthDay;
        }
        else {
            return this.recurrence.start.getDate();
        }
    }
    get weekDay() {
        const rrule = this.recurrence.rrule;
        if (isPresent(rrule.byWeekDay)) {
            const weekDaysCount = rrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                    return 'day';
                case 5:
                    return 'weekday';
                case 2:
                    return 'weekend';
                case 1:
                    return rrule.byWeekDay[0].day;
                default:
                    break;
            }
        }
        else if (isPresent(this.currentWeekDay)) {
            return this.currentWeekDay;
        }
        return this.defaultWeekDay;
    }
    get offset() {
        const rrule = this.recurrence.rrule;
        if (isPresent(rrule.byWeekDay)) {
            const weekDaysCount = rrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                case 5:
                case 2:
                    return rrule.bySetPosition[0];
                case 1:
                    return rrule.byWeekDay[0].offset;
                default:
                    break;
            }
        }
        else if (isPresent(this.currentOffset)) {
            return this.currentOffset;
        }
        return this.defaultOffset;
    }
    onMonthChange(month, repeatOnRule) {
        if (repeatOnRule === 'monthday') {
            this.currentMonthMonthDay = month;
        }
        else {
            this.currentMonthWeekDay = month;
        }
        this.recurrence.setMonths([month]);
    }
    onMonthDayChange(monthDay) {
        this.currentMonthDay = monthDay;
        this.recurrence.monthDays = [monthDay];
    }
    onOffsetPositionChange(offset) {
        const rrule = this.recurrence.rrule;
        if (isPresent(rrule.byWeekDay)) {
            const weekDaysCount = rrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                case 5:
                case 2:
                    this.recurrence.positions = [offset];
                    break;
                case 1:
                    rrule.byWeekDay[0].offset = offset;
                    this.recurrence.onChange();
                    break;
                default:
                    break;
            }
        }
        this.currentOffset = offset;
    }
    onWeekDayChange(weekDay) {
        let weekDays;
        if (typeof weekDay === 'string') {
            /* day, weekday or weekend */
            weekDays = this.weekDayRuleFromString(weekDay);
            this.recurrence.positions = [this.offset];
        }
        else {
            /* specific weekday */
            weekDays = [{
                    day: weekDay,
                    offset: this.offset
                }];
        }
        this.currentWeekDay = weekDay;
        this.recurrence.setWeekDays(weekDays);
    }
    isDisabled(repeatOn) {
        return this.recurrence.repeatOnRule !== repeatOn;
    }
    get currentFreq() {
        return this.recurrence.frequency;
    }
    get defaultOffset() {
        return 1;
    }
    get defaultWeekDay() {
        return this.recurrence.start.getDay();
    }
    weekDayRuleFromString(weekDay) {
        switch (weekDay) {
            case 'day':
                return dayRule;
            case 'weekday':
                return weekdayRule;
            case 'weekend':
                return weekendRule;
            default:
                break;
        }
        return null;
    }
    textForRepeatOn() {
        const freq = this.currentFreq;
        switch (freq) {
            case 'monthly':
                return this.textFor('monthlyRepeatOn');
            case 'yearly':
                return this.textFor('yearlyRepeatOn');
            default:
                break;
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onRepeatOnLabelClick() {
        const selected = this.repeatOnRadioButtons.toArray().find(r => r.elem.checked);
        if (selected) {
            selected.elem.focus();
        }
    }
}
RecurrenceMonthlyYearlyEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceMonthlyYearlyEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceMonthlyYearlyEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceMonthlyYearlyEditorComponent, isStandalone: true, selector: "kendo-recurrence-monthly-yearly-editor", inputs: { userNumericOptions: "userNumericOptions" }, viewQueries: [{ propertyName: "repeatOnRadioButtons", predicate: RepeatOnRadioButtonDirective, descendants: true }], ngImport: i0, template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textForRepeatOn()"
                labelCssClass="k-form-label"
                (click)="onRepeatOnLabelClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='monthday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-monthday-{{uniqueId}}'>
                            <ng-template [ngIf]="currentFreq === 'monthly'">
                                {{ textFor('monthlyDay') }}
                            </ng-template>
                        </label>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthMonthDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'monthday')"
                                [disabled]="isDisabled('monthday')"
                                [style.width.px]="170"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>

                        <kendo-numerictextbox
                            class="k-recur-monthday"
                            [min]="numericOptions.min"
                            [max]="numericOptions.max"
                            [decimals]="0"
                            [format]="numericOptions.format"
                            [autoCorrect]="numericOptions.autoCorrect"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [value]='monthDay'
                            (valueChange)='onMonthDayChange($event)'
                            [disabled]="isDisabled('monthday')"
                        >
                            <kendo-numerictextbox-messages 
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='weekday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-weekday-{{uniqueId}}'></label>

                        <kendo-dropdownlist
                            [data]='offsetPositions'
                            textField='text'
                            valueField='value'
                            [value]='offset'
                            [valuePrimitive]='true'
                            (valueChange)='onOffsetPositionChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <kendo-dropdownlist
                            [data]="extendedWeekDays"
                            textField='text'
                            valueField='value'
                            [value]='weekDay'
                            [valuePrimitive]='true'
                            (valueChange)='onWeekDayChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <span>{{ textFor('yearlyOf') }}</span>

                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthWeekDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'weekday')"
                                [disabled]="isDisabled('weekday')"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>
                    </li>
                </ul>
            </div>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "directive", type: RepeatOnRadioButtonDirective, selector: "[kendoRecurrenceRepeatOnRadioButton]", inputs: ["kendoRecurrenceRepeatOnRadioButton"] }, { kind: "directive", type: LabelDirective, selector: "label[for]", inputs: ["for", "labelClass"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DropDownListComponent, selector: "kendo-dropdownlist", inputs: ["customIconClass", "showStickyHeader", "icon", "svgIcon", "loading", "data", "value", "textField", "valueField", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "defaultItem", "disabled", "itemDisabled", "readonly", "filterable", "virtual", "ignoreCase", "delay", "valuePrimitive", "tabindex", "tabIndex", "size", "rounded", "fillMode", "leftRightArrowsNavigation", "id"], outputs: ["valueChange", "filterChange", "selectionChange", "open", "opened", "close", "closed", "focus", "blur"], exportAs: ["kendoDropDownList"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceMonthlyYearlyEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-recurrence-monthly-yearly-editor',
                    template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textForRepeatOn()"
                labelCssClass="k-form-label"
                (click)="onRepeatOnLabelClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <ul class='k-radio-list'>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='monthday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-monthday-{{uniqueId}}'>
                            <ng-template [ngIf]="currentFreq === 'monthly'">
                                {{ textFor('monthlyDay') }}
                            </ng-template>
                        </label>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthMonthDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'monthday')"
                                [disabled]="isDisabled('monthday')"
                                [style.width.px]="170"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>

                        <kendo-numerictextbox
                            class="k-recur-monthday"
                            [min]="numericOptions.min"
                            [max]="numericOptions.max"
                            [decimals]="0"
                            [format]="numericOptions.format"
                            [autoCorrect]="numericOptions.autoCorrect"
                            [readonly]="numericOptions.readonly"
                            [selectOnFocus]="numericOptions.selectOnFocus"
                            [spinners]="numericOptions.spinners"
                            [step]="numericOptions.step"
                            [title]="numericOptions.title"
                            [value]='monthDay'
                            (valueChange)='onMonthDayChange($event)'
                            [disabled]="isDisabled('monthday')"
                        >
                            <kendo-numerictextbox-messages 
                                [increment]="textFor('numericIncrement')"
                                [decrement]="textFor('numericDecrement')"
                            >
                            </kendo-numerictextbox-messages>
                        </kendo-numerictextbox>
                    </li>
                    <li class='k-radio-list-item'>
                        <span class="k-radio-wrap">
                            <input kendoRecurrenceRepeatOnRadioButton='weekday-{{uniqueId}}' />
                        </span>
                        <label [labelClass]="false" class='k-radio-label' for='k-repeaton-weekday-{{uniqueId}}'></label>

                        <kendo-dropdownlist
                            [data]='offsetPositions'
                            textField='text'
                            valueField='value'
                            [value]='offset'
                            [valuePrimitive]='true'
                            (valueChange)='onOffsetPositionChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <kendo-dropdownlist
                            [data]="extendedWeekDays"
                            textField='text'
                            valueField='value'
                            [value]='weekDay'
                            [valuePrimitive]='true'
                            (valueChange)='onWeekDayChange($event)'
                            [disabled]="isDisabled('weekday')"
                            [style.margin]="'0 .4ex 0 1ex'">
                        </kendo-dropdownlist>

                        <ng-template [ngIf]="currentFreq === 'yearly'">
                            <span>{{ textFor('yearlyOf') }}</span>

                            <kendo-dropdownlist
                                [data]='months'
                                textField='text'
                                valueField='value'
                                [value]='currentMonthWeekDay'
                                [valuePrimitive]='true'
                                (valueChange)="onMonthChange($event, 'weekday')"
                                [disabled]="isDisabled('weekday')"
                                [style.margin]="'0 .4ex 0 1ex'">
                            </kendo-dropdownlist>
                        </ng-template>
                    </li>
                </ul>
            </div>
        </div>
    `,
                    standalone: true,
                    imports: [LabelComponent, RepeatOnRadioButtonDirective, LabelDirective, NgIf, DropDownListComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$1.LocalizationService }]; }, propDecorators: { userNumericOptions: [{
                type: Input
            }], repeatOnRadioButtons: [{
                type: ViewChildren,
                args: [RepeatOnRadioButtonDirective]
            }] } });

/**
 * @hidden
 */
class RecurrenceWeekdayRuleEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
        this.selected = [];
        this.weekDays = this.recurrence.weekDays;
        this.setSelectedDays();
    }
    setSelectedDays() {
        for (let i = 0; i < 7; i++) {
            this.selected[i] = false;
        }
        if (isPresent(this.rrule.byWeekDay)) {
            this.rrule.byWeekDay.forEach((rule) => {
                this.selected[rule.day] = true;
            });
        }
    }
    onSelectedChange(isSelected, day) {
        this.selected[day] = isSelected;
        this.recurrence.setWeekDays(this.serializeToWeekDayRuleArray(this.selected));
    }
    isSelected(day) {
        return this.selected[day.value];
    }
    serializeToWeekDayRuleArray(arr) {
        const selectedValues = [];
        arr.forEach((isSelected, idx) => {
            if (isSelected) {
                selectedValues.push({ day: idx, offset: 0 });
            }
        });
        return selectedValues.length > 0 ? selectedValues : null;
    }
    get rrule() {
        return this.recurrence.rrule;
    }
    capitalize(day) {
        return capitalize(day);
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onWeeklyRepeatOnClick() {
        const selected = this.weekDayButtons.toArray().find(r => r.selected);
        if (selected) {
            selected.focus();
        }
    }
}
RecurrenceWeekdayRuleEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceWeekdayRuleEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceWeekdayRuleEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceWeekdayRuleEditorComponent, isStandalone: true, selector: "kendo-recurrence-weekday-rule-editor", viewQueries: [{ propertyName: "weekDayButtons", predicate: Button, descendants: true }], ngImport: i0, template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('weeklyRepeatOn')"
                labelCssClass="k-form-label"
                (click)="onWeeklyRepeatOnClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-button-group-solid"
                    width="100%"
                    selection="multiple"
                >
                    <button
                        *ngFor='let day of weekDays'
                        kendoButton
                        [toggleable]="true"
                        [selected]="isSelected(day)"
                        (selectedChange)="onSelectedChange($event, day.value)"
                    >{{ capitalize(day.text) }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "component", type: ButtonGroupComponent, selector: "kendo-buttongroup", inputs: ["disabled", "selection", "width", "tabIndex", "navigable"], outputs: ["navigate"], exportAs: ["kendoButtonGroup"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceWeekdayRuleEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-recurrence-weekday-rule-editor',
                    template: `
        <div class="k-form-field">
            <kendo-label
                [text]="textFor('weeklyRepeatOn')"
                labelCssClass="k-form-label"
                (click)="onWeeklyRepeatOnClick()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-button-group-solid"
                    width="100%"
                    selection="multiple"
                >
                    <button
                        *ngFor='let day of weekDays'
                        kendoButton
                        [toggleable]="true"
                        [selected]="isSelected(day)"
                        (selectedChange)="onSelectedChange($event, day.value)"
                    >{{ capitalize(day.text) }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `,
                    standalone: true,
                    imports: [LabelComponent, ButtonGroupComponent, NgFor, ButtonComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$1.LocalizationService }]; }, propDecorators: { weekDayButtons: [{
                type: ViewChildren,
                args: [Button]
            }] } });

/**
 * @hidden
 */
class RecurrenceIntervalEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
        this.cssClass = true;
        this.numericOptions = {
            min: 1,
            format: '#',
            autoCorrect: true,
            step: 1,
            spinners: true
        };
        this.intervalValue = this.recurrence.rrule.interval || 1;
    }
    set userNumericOptions(options) {
        this.numericOptions = { ...this.numericOptions, ...options };
    }
    get currentFreq() {
        return this.recurrence.frequency;
    }
    onIntervalChange(newInterval) {
        if (isPresent(newInterval)) {
            this.recurrence.interval = newInterval;
        }
    }
    onIntervalBlur() {
        if (!isPresent(this.intervalValue)) {
            this.recurrence.interval = this.intervalValue = 1;
        }
    }
    textForRepeatEvery() {
        const freq = this.currentFreq;
        switch (freq) {
            case 'daily':
                return this.textFor('dailyRepeatEvery');
            case 'weekly':
                return this.textFor('weeklyRepeatEvery');
            case 'monthly':
                return this.textFor('monthlyRepeatEvery');
            case 'yearly':
                return this.textFor('yearlyRepeatEvery');
            default:
                break;
        }
    }
    textForFrequency() {
        const freq = this.currentFreq;
        switch (freq) {
            case 'daily':
                return this.textFor('dailyInterval');
            case 'weekly':
                return this.textFor('weeklyInterval');
            case 'monthly':
                return this.textFor('monthlyInterval');
            case 'yearly':
                return this.textFor('yearlyInterval');
            default:
                break;
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
}
RecurrenceIntervalEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceIntervalEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceIntervalEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceIntervalEditorComponent, isStandalone: true, selector: "kendo-recurrence-interval-editor", inputs: { userNumericOptions: "userNumericOptions" }, host: { properties: { "class.k-scheduler-recurrence-interval-editor": "this.cssClass" } }, ngImport: i0, template: `
        <div class="k-form-field">
            <kendo-label
                [for]="intervalNumeric"
                [text]="textForRepeatEvery()"
                labelCssClass="k-form-label"
                (click)="intervalNumeric.focus()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-numerictextbox
                    #intervalNumeric
                    class="k-recur-interval"
                    [min]="numericOptions.min"
                    [max]="numericOptions.max"
                    [decimals]="0"
                    [format]="numericOptions.format"
                    [autoCorrect]="numericOptions.autoCorrect"
                    [readonly]="numericOptions.readonly"
                    [selectOnFocus]="numericOptions.selectOnFocus"
                    [spinners]="numericOptions.spinners"
                    [step]="numericOptions.step"
                    [title]="numericOptions.title"
                    [(value)]="intervalValue"
                    (blur)="onIntervalBlur()"
                    (valueChange)="onIntervalChange($event)"
                >
                    <kendo-numerictextbox-messages 
                        [increment]="textFor('numericIncrement')"
                        [decrement]="textFor('numericDecrement')"
                    >
                    </kendo-numerictextbox-messages>
                </kendo-numerictextbox>
                <span>&nbsp;{{ textForFrequency() }}</span>
            </div>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "component", type: NumericTextBoxComponent, selector: "kendo-numerictextbox", inputs: ["focusableId", "disabled", "readonly", "title", "autoCorrect", "format", "max", "min", "decimals", "placeholder", "step", "spinners", "rangeValidation", "tabindex", "tabIndex", "changeValueOnScroll", "selectOnFocus", "value", "maxlength", "size", "rounded", "fillMode", "inputAttributes"], outputs: ["valueChange", "focus", "blur", "inputFocus", "inputBlur"], exportAs: ["kendoNumericTextBox"] }, { kind: "component", type: NumericTextBoxCustomMessagesComponent, selector: "kendo-numerictextbox-messages" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceIntervalEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-recurrence-interval-editor',
                    template: `
        <div class="k-form-field">
            <kendo-label
                [for]="intervalNumeric"
                [text]="textForRepeatEvery()"
                labelCssClass="k-form-label"
                (click)="intervalNumeric.focus()"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-numerictextbox
                    #intervalNumeric
                    class="k-recur-interval"
                    [min]="numericOptions.min"
                    [max]="numericOptions.max"
                    [decimals]="0"
                    [format]="numericOptions.format"
                    [autoCorrect]="numericOptions.autoCorrect"
                    [readonly]="numericOptions.readonly"
                    [selectOnFocus]="numericOptions.selectOnFocus"
                    [spinners]="numericOptions.spinners"
                    [step]="numericOptions.step"
                    [title]="numericOptions.title"
                    [(value)]="intervalValue"
                    (blur)="onIntervalBlur()"
                    (valueChange)="onIntervalChange($event)"
                >
                    <kendo-numerictextbox-messages 
                        [increment]="textFor('numericIncrement')"
                        [decrement]="textFor('numericDecrement')"
                    >
                    </kendo-numerictextbox-messages>
                </kendo-numerictextbox>
                <span>&nbsp;{{ textForFrequency() }}</span>
            </div>
        </div>
    `,
                    standalone: true,
                    imports: [LabelComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$1.LocalizationService }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.k-scheduler-recurrence-interval-editor']
            }], userNumericOptions: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class RecurrenceFrequencyEditorComponent {
    constructor(recurrence, localization) {
        this.recurrence = recurrence;
        this.localization = localization;
    }
    ngOnInit() {
        this.frequencies = this.recurrence.frequencies;
    }
    get selected() {
        return this.recurrence.frequency;
    }
    onClick(newFreq) {
        if (newFreq.value !== this.selected) {
            this.recurrence.setFrequency(newFreq.value);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onFrequencyClick() {
        const selected = this.weekDayButtons.toArray().find(r => r.selected);
        if (selected) {
            selected.focus();
        }
    }
}
RecurrenceFrequencyEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceFrequencyEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceFrequencyEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceFrequencyEditorComponent, isStandalone: true, selector: "kendo-recurrence-frequency-editor", viewQueries: [{ propertyName: "weekDayButtons", predicate: Button, descendants: true }], ngImport: i0, template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textFor('repeat')"
                (click)="onFrequencyClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-scheduler-recurrence-repeat k-button-group-solid"
                    width="100%"
                    selection="single"
                >
                    <button *ngFor='let freq of frequencies' kendoButton
                            [togglable]="true"
                            [selected]="freq.value === selected"
                            (click)="onClick(freq)"
                    >{{ freq.text }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `, isInline: true, dependencies: [{ kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "component", type: ButtonGroupComponent, selector: "kendo-buttongroup", inputs: ["disabled", "selection", "width", "tabIndex", "navigable"], outputs: ["navigate"], exportAs: ["kendoButtonGroup"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceFrequencyEditorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-recurrence-frequency-editor',
                    template: `
        <div class='k-form-field'>
            <kendo-label
                [text]="textFor('repeat')"
                (click)="onFrequencyClick()"
                labelCssClass="k-form-label"
            ></kendo-label>
            <div class="k-form-field-wrap">
                <kendo-buttongroup
                    class="k-scheduler-recurrence-repeat k-button-group-solid"
                    width="100%"
                    selection="single"
                >
                    <button *ngFor='let freq of frequencies' kendoButton
                            [togglable]="true"
                            [selected]="freq.value === selected"
                            (click)="onClick(freq)"
                    >{{ freq.text }}</button>
                </kendo-buttongroup>
            </div>
        </div>
    `,
                    standalone: true,
                    imports: [LabelComponent, ButtonGroupComponent, NgFor, ButtonComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$1.LocalizationService }]; }, propDecorators: { weekDayButtons: [{
                type: ViewChildren,
                args: [Button]
            }] } });

/**
 * @hidden
 */
let Messages$1 = class Messages extends ComponentMessages {
};
Messages$1.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: Messages$1, deps: null, target: i0.ɵɵFactoryTarget.Directive });
Messages$1.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: Messages$1, inputs: { repeat: "repeat", dailyInterval: "dailyInterval", dailyRepeatEvery: "dailyRepeatEvery", weeklyInterval: "weeklyInterval", weeklyRepeatEvery: "weeklyRepeatEvery", weeklyRepeatOn: "weeklyRepeatOn", monthlyDay: "monthlyDay", monthlyInterval: "monthlyInterval", monthlyRepeatEvery: "monthlyRepeatEvery", monthlyRepeatOn: "monthlyRepeatOn", yearlyOf: "yearlyOf", yearlyRepeatEvery: "yearlyRepeatEvery", yearlyRepeatOn: "yearlyRepeatOn", yearlyInterval: "yearlyInterval", frequenciesDaily: "frequenciesDaily", frequenciesMonthly: "frequenciesMonthly", frequenciesNever: "frequenciesNever", frequenciesWeekly: "frequenciesWeekly", frequenciesYearly: "frequenciesYearly", offsetPositionsFirst: "offsetPositionsFirst", offsetPositionsSecond: "offsetPositionsSecond", offsetPositionsThird: "offsetPositionsThird", offsetPositionsFourth: "offsetPositionsFourth", offsetPositionsLast: "offsetPositionsLast", weekdaysDay: "weekdaysDay", weekdaysWeekday: "weekdaysWeekday", weekdaysWeekendday: "weekdaysWeekendday", endAfter: "endAfter", endOccurrence: "endOccurrence", endLabel: "endLabel", endNever: "endNever", endOn: "endOn", numericIncrement: "numericIncrement", numericDecrement: "numericDecrement", dateInputsToday: "dateInputsToday", dateInputsToggle: "dateInputsToggle", dateInputsParentViewButton: "dateInputsParentViewButton" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: Messages$1, decorators: [{
            type: Directive
        }], propDecorators: { repeat: [{
                type: Input
            }], dailyInterval: [{
                type: Input
            }], dailyRepeatEvery: [{
                type: Input
            }], weeklyInterval: [{
                type: Input
            }], weeklyRepeatEvery: [{
                type: Input
            }], weeklyRepeatOn: [{
                type: Input
            }], monthlyDay: [{
                type: Input
            }], monthlyInterval: [{
                type: Input
            }], monthlyRepeatEvery: [{
                type: Input
            }], monthlyRepeatOn: [{
                type: Input
            }], yearlyOf: [{
                type: Input
            }], yearlyRepeatEvery: [{
                type: Input
            }], yearlyRepeatOn: [{
                type: Input
            }], yearlyInterval: [{
                type: Input
            }], frequenciesDaily: [{
                type: Input
            }], frequenciesMonthly: [{
                type: Input
            }], frequenciesNever: [{
                type: Input
            }], frequenciesWeekly: [{
                type: Input
            }], frequenciesYearly: [{
                type: Input
            }], offsetPositionsFirst: [{
                type: Input
            }], offsetPositionsSecond: [{
                type: Input
            }], offsetPositionsThird: [{
                type: Input
            }], offsetPositionsFourth: [{
                type: Input
            }], offsetPositionsLast: [{
                type: Input
            }], weekdaysDay: [{
                type: Input
            }], weekdaysWeekday: [{
                type: Input
            }], weekdaysWeekendday: [{
                type: Input
            }], endAfter: [{
                type: Input
            }], endOccurrence: [{
                type: Input
            }], endLabel: [{
                type: Input
            }], endNever: [{
                type: Input
            }], endOn: [{
                type: Input
            }], numericIncrement: [{
                type: Input
            }], numericDecrement: [{
                type: Input
            }], dateInputsToday: [{
                type: Input
            }], dateInputsToggle: [{
                type: Input
            }], dateInputsParentViewButton: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class RecurrenceEditorLocalizedMessagesDirective extends Messages$1 {
    constructor(service) {
        super();
        this.service = service;
    }
}
RecurrenceEditorLocalizedMessagesDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorLocalizedMessagesDirective, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
RecurrenceEditorLocalizedMessagesDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceEditorLocalizedMessagesDirective, isStandalone: true, selector: "[kendoRecurrenceEditorLocalizedMessages]", providers: [
        {
            provide: Messages$1,
            useExisting: forwardRef(() => RecurrenceEditorLocalizedMessagesDirective)
        }
    ], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorLocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(() => RecurrenceEditorLocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoRecurrenceEditorLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }]; } });

/**
 * @hidden
 */
const RECURRENCE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RecurrenceEditorComponent)
};
/**
 * Represents the Kendo UI Recurrence Editor component for Angular. [This example](slug:custom_reactive_editing_scheduler) demonstrates the Recurrence Editor, among other components.
 */
class RecurrenceEditorComponent {
    constructor(recurrenceService, intl) {
        this.recurrenceService = recurrenceService;
        this.intl = intl;
        this.cssClass = true;
        /**
         * Specifies the id of the timezone that will be used.
         * @default 'Etc/UTC'
         */
        this.timezone = 'Etc/UTC';
        /**
         * Fires when the value of the component has changed.
         */
        this.valueChange = new EventEmitter();
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
        this.weekStart = this.intl.firstDay();
        this.subscriptions = this.recurrenceService.change.subscribe((rrule) => {
            this.emitChange(rrule);
        });
    }
    /**
     * Specifies the start date of the event.
     */
    set start(value) {
        this._start = value;
    }
    get start() {
        return isPresent(this._start) ? this._start : getDate(new Date());
    }
    /**
     * @hidden
     */
    get currentFreq() {
        return this.recurrenceService.frequency;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.recurrenceService.init('', this.start, this.timezone, this.weekStart);
    }
    ngOnChanges(changes) {
        if (isChanged('start', changes)) {
            this.recurrenceService.start = this.start;
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    writeValue(rrule) {
        this.recurrenceService.init(typeof rrule === 'string' ? rrule : '', this.start, this.timezone, this.weekStart);
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    emitChange(rrule) {
        this.onChangeCallback(rrule);
        this.valueChange.emit(rrule);
    }
}
RecurrenceEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorComponent, deps: [{ token: RecurrenceService }, { token: i1$2.IntlService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceEditorComponent, isStandalone: true, selector: "kendo-recurrence-editor", inputs: { start: "start", timezone: "timezone", weekStart: "weekStart", repeatEveryOptions: "repeatEveryOptions", endAfterOptions: "endAfterOptions", repeatOnOptions: "repeatOnOptions", endOnOptions: "endOnOptions" }, outputs: { valueChange: "valueChange" }, host: { properties: { "class.k-recurrence-editor": "this.cssClass" } }, providers: [
        RecurrenceLocalizationService,
        {
            provide: LocalizationService,
            useExisting: RecurrenceLocalizationService
        },
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.recurrenceeditor'
        },
        RECURRENCE_VALUE_ACCESSOR,
        RecurrenceService
    ], exportAs: ["kendoRecurrenceEditor"], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoRecurrenceEditorLocalizedMessages
            i18n-repeat="kendo.recurrenceeditor.repeat|The text similar to 'Repeat' displayed in the recurrence editor."
            repeat='Repeat'

            i18n-dailyInterval="kendo.recurrenceeditor.dailyInterval|The text similar to 'day(s)' displayed in the recurrence editor."
            dailyInterval='day(s)'

            i18n-dailyRepeatEvery="kendo.recurrenceeditor.dailyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            dailyRepeatEvery='Repeat every'

            i18n-weeklyInterval="kendo.recurrenceeditor.weeklyInterval|The text similar to 'week(s)' displayed in the recurrence editor."
            weeklyInterval='week(s)'

            i18n-weeklyRepeatEvery="kendo.recurrenceeditor.weeklyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            weeklyRepeatEvery='Repeat every'

            i18n-weeklyRepeatOn="kendo.recurrenceeditor.weeklyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            weeklyRepeatOn='Repeat on'

            i18n-monthlyDay="kendo.recurrenceeditor.monthlyDay|The text similar to 'Day' displayed in the recurrence editor."
            monthlyDay='Day'

            i18n-monthlyInterval="kendo.recurrenceeditor.monthlyInterval|The text similar to 'month(s)' displayed in the recurrence editor."
            monthlyInterval='month(s)'

            i18n-monthlyRepeatEvery="kendo.recurrenceeditor.monthlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            monthlyRepeatEvery='Repeat every'

            i18n-monthlyRepeatOn="kendo.recurrenceeditor.monthlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            monthlyRepeatOn='Repeat on'

            i18n-yearlyOf="kendo.recurrenceeditor.yearlyOf|The text similar to 'of' displayed in the recurrence editor."
            yearlyOf='of'

            i18n-yearlyRepeatEvery="kendo.recurrenceeditor.yearlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            yearlyRepeatEvery='Repeat every'

            i18n-yearlyRepeatOn="kendo.recurrenceeditor.yearlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            yearlyRepeatOn='Repeat on'

            i18n-yearlyInterval="kendo.recurrenceeditor.yearlyInterval|The text similar to 'year(s)' displayed in the recurrence editor."
            yearlyInterval='year(s)'

            i18n-frequenciesDaily="kendo.recurrenceeditor.frequenciesDaily|The text similar to 'Daily' displayed in the recurrence editor."
            frequenciesDaily='Daily'

            i18n-frequenciesMonthly="kendo.recurrenceeditor.frequenciesMonthly|The text similar to 'Monthly' displayed in the recurrence editor."
            frequenciesMonthly='Monthly'

            i18n-frequenciesNever="kendo.recurrenceeditor.frequenciesNever|The text similar to 'Never' displayed in the recurrence editor."
            frequenciesNever='Never'

            i18n-frequenciesWeekly="kendo.recurrenceeditor.frequenciesWeekly|The text similar to 'Weekly' displayed in the recurrence editor."
            frequenciesWeekly='Weekly'

            i18n-frequenciesYearly="kendo.recurrenceeditor.frequenciesYearly|The text similar to 'Yearly' displayed in the recurrence editor."
            frequenciesYearly='Yearly'

            i18n-offsetPositionsFirst="kendo.recurrenceeditor.offsetPositionsFirst|The text similar to 'First' displayed in the recurrence editor."
            offsetPositionsFirst='First'

            i18n-offsetPositionsSecond="kendo.recurrenceeditor.offsetPositionsSecond|The text similar to 'Second' displayed in the recurrence editor."
            offsetPositionsSecond='Second'

            i18n-offsetPositionsThird="kendo.recurrenceeditor.offsetPositionsThird|The text similar to 'Third' displayed in the recurrence editor."
            offsetPositionsThird='Third'

            i18n-offsetPositionsFourth="kendo.recurrenceeditor.offsetPositionsFourth|The text similar to 'Fourth' displayed in the recurrence editor."
            offsetPositionsFourth='Fourth'

            i18n-offsetPositionsLast="kendo.recurrenceeditor.offsetPositionsLast|The text similar to 'Last' displayed in the recurrence editor."
            offsetPositionsLast='Last'

            i18n-weekdaysDay="kendo.recurrenceeditor.weekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysDay='Day'

            i18n-weekdaysWeekday="kendo.recurrenceeditor.weekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekday='Weekday'

            i18n-weekdaysWeekendday="kendo.recurrenceeditor.weekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekendday='Weekend Day'

            i18n-endAfter="kendo.recurrenceeditor.endAfter|The text similar to 'After' displayed in the recurrence editor."
            endAfter='After'

            i18n-endOccurrence="kendo.recurrenceeditor.endOccurrence|The text similar to 'occurrence(s)' displayed in the recurrence editor."
            endOccurrence='occurrence(s)'

            i18n-endLabel="kendo.recurrenceeditor.endLabel|The text similar to 'End' displayed in the recurrence editor."
            endLabel='End'

            i18n-endNever="kendo.recurrenceeditor.endNever|The text similar to 'Never' displayed in the recurrence editor."
            endNever='Never'

            i18n-endOn="kendo.recurrenceeditor.endOn|The text similar to 'On' displayed in the recurrence editor."
            endOn='On'

            i18n-numericIncrement="kendo.recurrenceeditor.numericIncrement|The title of the 'Increment' button of the NumericTextBoxes displayed in the recurrence editor."
            numericIncrement='Increase value'

            i18n-numericDecrement="kendo.recurrenceeditor.numericDecrement|The title of the 'Decrement' button of the NumericTextBoxes displayed in the recurrence editor."
            numericDecrement='Decrease value'

            i18n-dateInputsToday="kendo.recurrenceeditor.dateInputsToday|The title of the 'Today' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsToday='Today'

            i18n-dateInputsToggle="kendo.recurrenceeditor.dateInputsToggle|The title of the 'Toggle' button of the DatePickers displayed in the recurrence editor."
            dateInputsToggle='Toggle calendar'

            i18n-dateInputsParentViewButton="kendo.recurrenceeditor.dateInputsParentViewButton|The title of the 'Parent View' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsParentViewButton='Navigate to parent view'
        >
        </ng-container>

        <kendo-recurrence-frequency-editor>
        </kendo-recurrence-frequency-editor>

        <div class="k-recur-view">
            <kendo-recurrence-interval-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="repeatEveryOptions">
            </kendo-recurrence-interval-editor>

            <kendo-recurrence-weekday-rule-editor *ngIf="currentFreq === 'weekly'">
            </kendo-recurrence-weekday-rule-editor>

            <kendo-recurrence-monthly-yearly-editor
                *ngIf="currentFreq === 'monthly' || currentFreq === 'yearly'"
                [userNumericOptions]="repeatOnOptions">
            </kendo-recurrence-monthly-yearly-editor>

            <kendo-recurrence-end-rule-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="endAfterOptions"
                [userDatePickerOptions]="endOnOptions">
            </kendo-recurrence-end-rule-editor>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: RecurrenceEditorLocalizedMessagesDirective, selector: "[kendoRecurrenceEditorLocalizedMessages]" }, { kind: "component", type: RecurrenceFrequencyEditorComponent, selector: "kendo-recurrence-frequency-editor" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: RecurrenceIntervalEditorComponent, selector: "kendo-recurrence-interval-editor", inputs: ["userNumericOptions"] }, { kind: "component", type: RecurrenceWeekdayRuleEditorComponent, selector: "kendo-recurrence-weekday-rule-editor" }, { kind: "component", type: RecurrenceMonthlyYearlyEditorComponent, selector: "kendo-recurrence-monthly-yearly-editor", inputs: ["userNumericOptions"] }, { kind: "component", type: RecurrenceEndRuleEditorComponent, selector: "kendo-recurrence-end-rule-editor", inputs: ["userNumericOptions", "userDatePickerOptions"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendoRecurrenceEditor',
                    providers: [
                        RecurrenceLocalizationService,
                        {
                            provide: LocalizationService,
                            useExisting: RecurrenceLocalizationService
                        },
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.recurrenceeditor'
                        },
                        RECURRENCE_VALUE_ACCESSOR,
                        RecurrenceService
                    ],
                    selector: 'kendo-recurrence-editor',
                    template: `
        <ng-container kendoRecurrenceEditorLocalizedMessages
            i18n-repeat="kendo.recurrenceeditor.repeat|The text similar to 'Repeat' displayed in the recurrence editor."
            repeat='Repeat'

            i18n-dailyInterval="kendo.recurrenceeditor.dailyInterval|The text similar to 'day(s)' displayed in the recurrence editor."
            dailyInterval='day(s)'

            i18n-dailyRepeatEvery="kendo.recurrenceeditor.dailyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            dailyRepeatEvery='Repeat every'

            i18n-weeklyInterval="kendo.recurrenceeditor.weeklyInterval|The text similar to 'week(s)' displayed in the recurrence editor."
            weeklyInterval='week(s)'

            i18n-weeklyRepeatEvery="kendo.recurrenceeditor.weeklyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            weeklyRepeatEvery='Repeat every'

            i18n-weeklyRepeatOn="kendo.recurrenceeditor.weeklyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            weeklyRepeatOn='Repeat on'

            i18n-monthlyDay="kendo.recurrenceeditor.monthlyDay|The text similar to 'Day' displayed in the recurrence editor."
            monthlyDay='Day'

            i18n-monthlyInterval="kendo.recurrenceeditor.monthlyInterval|The text similar to 'month(s)' displayed in the recurrence editor."
            monthlyInterval='month(s)'

            i18n-monthlyRepeatEvery="kendo.recurrenceeditor.monthlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            monthlyRepeatEvery='Repeat every'

            i18n-monthlyRepeatOn="kendo.recurrenceeditor.monthlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            monthlyRepeatOn='Repeat on'

            i18n-yearlyOf="kendo.recurrenceeditor.yearlyOf|The text similar to 'of' displayed in the recurrence editor."
            yearlyOf='of'

            i18n-yearlyRepeatEvery="kendo.recurrenceeditor.yearlyRepeatEvery|The text similar to 'Repeat every' displayed in the recurrence editor."
            yearlyRepeatEvery='Repeat every'

            i18n-yearlyRepeatOn="kendo.recurrenceeditor.yearlyRepeatOn|The text similar to 'Repeat on' displayed in the recurrence editor."
            yearlyRepeatOn='Repeat on'

            i18n-yearlyInterval="kendo.recurrenceeditor.yearlyInterval|The text similar to 'year(s)' displayed in the recurrence editor."
            yearlyInterval='year(s)'

            i18n-frequenciesDaily="kendo.recurrenceeditor.frequenciesDaily|The text similar to 'Daily' displayed in the recurrence editor."
            frequenciesDaily='Daily'

            i18n-frequenciesMonthly="kendo.recurrenceeditor.frequenciesMonthly|The text similar to 'Monthly' displayed in the recurrence editor."
            frequenciesMonthly='Monthly'

            i18n-frequenciesNever="kendo.recurrenceeditor.frequenciesNever|The text similar to 'Never' displayed in the recurrence editor."
            frequenciesNever='Never'

            i18n-frequenciesWeekly="kendo.recurrenceeditor.frequenciesWeekly|The text similar to 'Weekly' displayed in the recurrence editor."
            frequenciesWeekly='Weekly'

            i18n-frequenciesYearly="kendo.recurrenceeditor.frequenciesYearly|The text similar to 'Yearly' displayed in the recurrence editor."
            frequenciesYearly='Yearly'

            i18n-offsetPositionsFirst="kendo.recurrenceeditor.offsetPositionsFirst|The text similar to 'First' displayed in the recurrence editor."
            offsetPositionsFirst='First'

            i18n-offsetPositionsSecond="kendo.recurrenceeditor.offsetPositionsSecond|The text similar to 'Second' displayed in the recurrence editor."
            offsetPositionsSecond='Second'

            i18n-offsetPositionsThird="kendo.recurrenceeditor.offsetPositionsThird|The text similar to 'Third' displayed in the recurrence editor."
            offsetPositionsThird='Third'

            i18n-offsetPositionsFourth="kendo.recurrenceeditor.offsetPositionsFourth|The text similar to 'Fourth' displayed in the recurrence editor."
            offsetPositionsFourth='Fourth'

            i18n-offsetPositionsLast="kendo.recurrenceeditor.offsetPositionsLast|The text similar to 'Last' displayed in the recurrence editor."
            offsetPositionsLast='Last'

            i18n-weekdaysDay="kendo.recurrenceeditor.weekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysDay='Day'

            i18n-weekdaysWeekday="kendo.recurrenceeditor.weekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekday='Weekday'

            i18n-weekdaysWeekendday="kendo.recurrenceeditor.weekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            weekdaysWeekendday='Weekend Day'

            i18n-endAfter="kendo.recurrenceeditor.endAfter|The text similar to 'After' displayed in the recurrence editor."
            endAfter='After'

            i18n-endOccurrence="kendo.recurrenceeditor.endOccurrence|The text similar to 'occurrence(s)' displayed in the recurrence editor."
            endOccurrence='occurrence(s)'

            i18n-endLabel="kendo.recurrenceeditor.endLabel|The text similar to 'End' displayed in the recurrence editor."
            endLabel='End'

            i18n-endNever="kendo.recurrenceeditor.endNever|The text similar to 'Never' displayed in the recurrence editor."
            endNever='Never'

            i18n-endOn="kendo.recurrenceeditor.endOn|The text similar to 'On' displayed in the recurrence editor."
            endOn='On'

            i18n-numericIncrement="kendo.recurrenceeditor.numericIncrement|The title of the 'Increment' button of the NumericTextBoxes displayed in the recurrence editor."
            numericIncrement='Increase value'

            i18n-numericDecrement="kendo.recurrenceeditor.numericDecrement|The title of the 'Decrement' button of the NumericTextBoxes displayed in the recurrence editor."
            numericDecrement='Decrease value'

            i18n-dateInputsToday="kendo.recurrenceeditor.dateInputsToday|The title of the 'Today' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsToday='Today'

            i18n-dateInputsToggle="kendo.recurrenceeditor.dateInputsToggle|The title of the 'Toggle' button of the DatePickers displayed in the recurrence editor."
            dateInputsToggle='Toggle calendar'

            i18n-dateInputsParentViewButton="kendo.recurrenceeditor.dateInputsParentViewButton|The title of the 'Parent View' button in the popup of the DatePickers displayed in the recurrence editor."
            dateInputsParentViewButton='Navigate to parent view'
        >
        </ng-container>

        <kendo-recurrence-frequency-editor>
        </kendo-recurrence-frequency-editor>

        <div class="k-recur-view">
            <kendo-recurrence-interval-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="repeatEveryOptions">
            </kendo-recurrence-interval-editor>

            <kendo-recurrence-weekday-rule-editor *ngIf="currentFreq === 'weekly'">
            </kendo-recurrence-weekday-rule-editor>

            <kendo-recurrence-monthly-yearly-editor
                *ngIf="currentFreq === 'monthly' || currentFreq === 'yearly'"
                [userNumericOptions]="repeatOnOptions">
            </kendo-recurrence-monthly-yearly-editor>

            <kendo-recurrence-end-rule-editor
                *ngIf="currentFreq !== 'never'"
                [userNumericOptions]="endAfterOptions"
                [userDatePickerOptions]="endOnOptions">
            </kendo-recurrence-end-rule-editor>
        </div>
    `,
                    standalone: true,
                    imports: [RecurrenceEditorLocalizedMessagesDirective, RecurrenceFrequencyEditorComponent, NgIf, RecurrenceIntervalEditorComponent, RecurrenceWeekdayRuleEditorComponent, RecurrenceMonthlyYearlyEditorComponent, RecurrenceEndRuleEditorComponent]
                }]
        }], ctorParameters: function () { return [{ type: RecurrenceService }, { type: i1$2.IntlService }]; }, propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.k-recurrence-editor']
            }], start: [{
                type: Input
            }], timezone: [{
                type: Input
            }], weekStart: [{
                type: Input
            }], repeatEveryOptions: [{
                type: Input
            }], endAfterOptions: [{
                type: Input
            }], repeatOnOptions: [{
                type: Input
            }], endOnOptions: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const TIME_ZONE_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TimeZoneEditorComponent)
};
/**
 * Represents the Kendo UI TimeZone Editor component for Angular.
 * `TimeZoneEditorComponent` displays the currently loaded timezones.
 * Used for editing the `start` and `end` timezones of the `SchedulerEvent` objects.
 */
class TimeZoneEditorComponent {
    constructor(injector) {
        this.injector = injector;
        /**
         * Specifies the width of the ComboBox which contains the names of the timezones.
         * @default 260
         */
        this.width = 260;
        /**
         * Fires when the value of the component has changed.
         */
        this.valueChange = new EventEmitter();
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
        this.tzNames = timezoneNames();
        this.tzSource = this.tzNames.slice();
    }
    /**
     * @hidden
     */
    get focusableId() {
        return this.tzComboBox?.focusableId || this.tzComboBoxControl?.focusableId;
    }
    /**
     * @hidden
     */
    get formControl() {
        const ngControl = this.injector.get(NgControl, null);
        return ngControl?.control || null;
    }
    /**
     * @hidden
     */
    onTimeZoneChange(tzName) {
        this.tz = tzName;
        this.onChangeCallback(this.tz);
        this.valueChange.emit(tzName);
    }
    /**
     * @hidden
     */
    onTimeZoneFilterChange(value) {
        this.tzSource = this.tzNames.filter((tz) => tz.toLowerCase().indexOf(value.toLowerCase()) !== -1);
    }
    /**
     * @hidden
     */
    writeValue(value) {
        if (typeof value === 'string' && this.tzNames.indexOf(value) >= 0) {
            this.tz = value;
        }
    }
    /**
     * @hidden
     */
    focus() {
        this.tzComboBox ? this.tzComboBox.focus() : this.tzComboBoxControl.focus();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
TimeZoneEditorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeZoneEditorComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
TimeZoneEditorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: TimeZoneEditorComponent, isStandalone: true, selector: "kendo-timezone-editor", inputs: { width: "width" }, outputs: { valueChange: "valueChange" }, providers: [
        TIME_ZONE_VALUE_ACCESSOR
    ], viewQueries: [{ propertyName: "tzComboBox", first: true, predicate: ["tzcombobox"], descendants: true, static: true }, { propertyName: "tzComboBoxControl", first: true, predicate: ["tzcomboboxControl"], descendants: true, static: true }], ngImport: i0, template: `
        <kendo-combobox
            *ngIf="!formControl"
            #tzcombobox
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
        <kendo-combobox
            *ngIf="formControl"
            #tzcomboboxControl
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            [formControl]="formControl"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: ComboBoxComponent, selector: "kendo-combobox", inputs: ["icon", "svgIcon", "inputAttributes", "showStickyHeader", "focusableId", "allowCustom", "data", "value", "textField", "valueField", "valuePrimitive", "valueNormalizer", "placeholder", "adaptiveMode", "title", "subtitle", "popupSettings", "listHeight", "loading", "suggest", "clearButton", "disabled", "itemDisabled", "readonly", "tabindex", "tabIndex", "filterable", "virtual", "size", "rounded", "fillMode"], outputs: ["valueChange", "selectionChange", "filterChange", "open", "opened", "close", "closed", "focus", "blur", "inputFocus", "inputBlur", "escape"], exportAs: ["kendoComboBox"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeZoneEditorComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        TIME_ZONE_VALUE_ACCESSOR
                    ],
                    selector: 'kendo-timezone-editor',
                    template: `
        <kendo-combobox
            *ngIf="!formControl"
            #tzcombobox
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
        <kendo-combobox
            *ngIf="formControl"
            #tzcomboboxControl
            [style.width.px]="width"
            [allowCustom]="false"
            [data]="tzSource"
            [filterable]="true"
            [suggest]="true"
            [value]="tz"
            [formControl]="formControl"
            (filterChange)="onTimeZoneFilterChange($event)"
            (valueChange)="onTimeZoneChange($event)">
        </kendo-combobox>
    `,
                    standalone: true,
                    imports: [NgIf, ComboBoxComponent, ReactiveFormsModule]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; }, propDecorators: { tzComboBox: [{
                type: ViewChild,
                args: ['tzcombobox', { static: true }]
            }], tzComboBoxControl: [{
                type: ViewChild,
                args: ['tzcomboboxControl', { static: true }]
            }], width: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

/**
 * @hidden
 */
const SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR = {
    multi: true,
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SchedulerDateTimePickerComponent)
};
/**
 * @hidden
 */
class SchedulerDateTimePickerComponent {
    constructor(injector, localization) {
        this.injector = injector;
        this.localization = localization;
        this.valueChange = new EventEmitter();
        this.onTouchedCallback = (_) => { };
        this.onChangeCallback = (_) => { };
    }
    /**
     * @hidden
     */
    get focusableId() {
        return this.isAllDay ? this.datePicker?.focusableId : this.dateTimePicker?.focusableId;
    }
    get formControl() {
        const ngControl = this.injector.get(NgControl, null);
        return ngControl?.control || null;
    }
    textFor(key) {
        return this.localization.get(key);
    }
    writeValue(newDate) {
        if (newDate instanceof Date) {
            this.date = newDate;
        }
    }
    onValueChange(newValue) {
        this.onChangeCallback(newValue);
        this.valueChange.emit(newValue);
    }
    /**
     * @hidden
     */
    focus() {
        this.datePicker ? this.datePicker.focus() : this.dateTimePicker.focus();
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
SchedulerDateTimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerDateTimePickerComponent, deps: [{ token: i0.Injector }, { token: SchedulerLocalizationService }], target: i0.ɵɵFactoryTarget.Component });
SchedulerDateTimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: SchedulerDateTimePickerComponent, isStandalone: true, selector: "kendo-scheduler-datetime-picker", inputs: { isAllDay: "isAllDay" }, outputs: { valueChange: "valueChange" }, providers: [
        SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR
    ], viewQueries: [{ propertyName: "datePicker", first: true, predicate: ["datepicker"], descendants: true }, { propertyName: "dateTimePicker", first: true, predicate: ["datetimepicker"], descendants: true }], ngImport: i0, template: `
    <kendo-datepicker
        *ngIf='isAllDay'
        #datepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datepicker-messages
            [today]="textFor('editorDateInputsToday')"
            [toggle]="textFor('editorDateInputsToggle')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datepicker-messages>
    </kendo-datepicker>
    <kendo-datetimepicker
        *ngIf='!isAllDay'
        #datetimepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datetimepicker-messages
            [toggle]="textFor('editorDateInputsToggle')"
            [today]="textFor('editorDateInputsToday')"
            [accept]="textFor('editorDateInputsAccept')"
            [acceptLabel]="textFor('editorDateInputsAcceptLabel')"
            [cancelLabel]="textFor('editorDateInputsCancelLabel')"
            [cancel]="textFor('editorDateInputsCancel')"
            [now]="textFor('editorDateInputsNow')"
            [nowLabel]="textFor('editorDateInputsNowLabel')"
            [dateTab]="textFor('editorDateInputsDateTab')"
            [dateTabLabel]="textFor('editorDateInputsDateTabLabel')"
            [timeTab]="textFor('editorDateInputsTimeTab')"
            [timeTabLabel]="textFor('editorDateInputsTimeTabLabel')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datetimepicker-messages>
    </kendo-datetimepicker>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DatePickerComponent, selector: "kendo-datepicker", inputs: ["focusableId", "cellTemplate", "clearButton", "inputAttributes", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "footer", "navigationItemTemplate", "weekDaysFormat", "showOtherMonthDays", "activeView", "bottomView", "topView", "calendarType", "animateCalendarNavigation", "disabled", "readonly", "readOnlyInput", "popupSettings", "navigation", "min", "max", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "autoFill", "focusedDate", "value", "format", "twoDigitYearMax", "formatPlaceholder", "placeholder", "tabindex", "tabIndex", "disabledDates", "title", "subtitle", "rangeValidation", "disabledDatesValidation", "weekNumber", "size", "rounded", "fillMode", "adaptiveMode"], outputs: ["valueChange", "focus", "blur", "open", "close", "escape"], exportAs: ["kendo-datepicker"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "component", type: DatePickerCustomMessagesComponent, selector: "kendo-datepicker-messages" }, { kind: "component", type: DateTimePickerComponent, selector: "kendo-datetimepicker", inputs: ["focusableId", "weekDaysFormat", "showOtherMonthDays", "value", "format", "twoDigitYearMax", "tabindex", "disabledDates", "popupSettings", "title", "subtitle", "disabled", "readonly", "readOnlyInput", "cancelButton", "formatPlaceholder", "placeholder", "steps", "focusedDate", "calendarType", "animateCalendarNavigation", "weekNumber", "min", "max", "rangeValidation", "disabledDatesValidation", "incompleteDateValidation", "autoCorrectParts", "autoSwitchParts", "autoSwitchKeys", "enableMouseWheel", "allowCaretMode", "clearButton", "autoFill", "adaptiveMode", "inputAttributes", "defaultTab", "size", "rounded", "fillMode", "headerTemplate", "footerTemplate", "footer"], outputs: ["valueChange", "open", "close", "focus", "blur", "escape"], exportAs: ["kendo-datetimepicker"] }, { kind: "component", type: DateTimePickerCustomMessagesComponent, selector: "kendo-datetimepicker-messages" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerDateTimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        SCHEDULER_DATETIMEPICKER_VALUE_ACCESSOR
                    ],
                    selector: 'kendo-scheduler-datetime-picker',
                    template: `
    <kendo-datepicker
        *ngIf='isAllDay'
        #datepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datepicker-messages
            [today]="textFor('editorDateInputsToday')"
            [toggle]="textFor('editorDateInputsToggle')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datepicker-messages>
    </kendo-datepicker>
    <kendo-datetimepicker
        *ngIf='!isAllDay'
        #datetimepicker
        [(value)]='date'
        (valueChange)='onValueChange($event)'
        [formControl]="formControl"
        [clearButton]="true"
    >
        <kendo-datetimepicker-messages
            [toggle]="textFor('editorDateInputsToggle')"
            [today]="textFor('editorDateInputsToday')"
            [accept]="textFor('editorDateInputsAccept')"
            [acceptLabel]="textFor('editorDateInputsAcceptLabel')"
            [cancelLabel]="textFor('editorDateInputsCancelLabel')"
            [cancel]="textFor('editorDateInputsCancel')"
            [now]="textFor('editorDateInputsNow')"
            [nowLabel]="textFor('editorDateInputsNowLabel')"
            [dateTab]="textFor('editorDateInputsDateTab')"
            [dateTabLabel]="textFor('editorDateInputsDateTabLabel')"
            [timeTab]="textFor('editorDateInputsTimeTab')"
            [timeTabLabel]="textFor('editorDateInputsTimeTabLabel')"
            [parentViewButtonTitle]="textFor('editorDateInputsParentViewButton')"
        >
        </kendo-datetimepicker-messages>
    </kendo-datetimepicker>
    `,
                    standalone: true,
                    imports: [NgIf, DatePickerComponent, ReactiveFormsModule, DatePickerCustomMessagesComponent, DateTimePickerComponent, DateTimePickerCustomMessagesComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: SchedulerLocalizationService }]; }, propDecorators: { datePicker: [{
                type: ViewChild,
                args: ['datepicker']
            }], dateTimePicker: [{
                type: ViewChild,
                args: ['datetimepicker']
            }], isAllDay: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class EditDialogComponent {
    constructor(ngZone, editService, localization, changeDetector, element, focusService) {
        this.ngZone = ngZone;
        this.editService = editService;
        this.localization = localization;
        this.changeDetector = changeDetector;
        this.element = element;
        this.focusService = focusService;
        this.resources = [];
        this.timezone = 'Etc/UTC';
        this.setTimeZone = false;
        this.setSeparateStartEndTimeZones = false;
        this.saveIcon = saveIcon;
        this.cancelIcon = cancelOutlineIcon;
        this.subs = this.editService.changed.subscribe(() => {
            this.ngZone.run(() => { this.onChange(); });
        });
        this.subs.add(fromEvent(this.element.nativeElement, 'keydown')
            .pipe(filter(() => this.isActive))
            .subscribe((e) => {
            if (e.keyCode === Keys.Escape) {
                this.reset();
            }
            if (e.keyCode === Keys.Enter && (withModifiers(e, Modifiers.CtrlKey) || withModifiers(e, Modifiers.MetaKey))) {
                this.onSave(e);
            }
            e.stopPropagation();
        }));
    }
    get autoFocusedElement() {
        if (this.editTemplate) {
            return this.editTemplate.autoFocusedElement;
        }
        return '.k-form-field input';
    }
    get isEditingSeries() {
        return this.editMode === EditMode.Series && Boolean(this.formGroup.get(this.fields.recurrenceRule));
    }
    get eventTimezone() {
        return formValueOrDefault(this.formGroup, this.fields.startTimezone, this.timezone);
    }
    get endTimezone() {
        return formValueOrDefault(this.formGroup, this.fields.endTimezone, this.eventTimezone);
    }
    onChange() {
        this.changeDetector.markForCheck();
        if (this.editService.hasNewEvent) {
            this.editMode = EditMode.Series;
            this.formGroup = this.editService.context.formGroup;
            this.isNew = true;
            this.applyLocalTimezone();
        }
        else if (this.editService.isEditing()) {
            const { dataItem, mode } = this.editService.context;
            this.formGroup = this.editService.context.formGroup;
            this.isNew = false;
            this.editedEvent = dataItem;
            this.editMode = isPresent(mode) ? mode : EditMode.Series;
            this.applyLocalTimezone();
        }
        else {
            this.reset();
            return;
        }
        if (!this.editTemplate) {
            this.addTimeZoneCheckboxesToFormGroup();
            this.subscribeToFormGroupChanges();
        }
        if (isPresent(this.formGroup)) {
            this.recurrenceStart = this.formGroup.get(this.fields.start).value;
        }
        this.isActive = true;
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
    onCancel(e) {
        e.preventDefault();
        this.onClose();
        this.changeDetector.markForCheck();
    }
    onSave(e) {
        e.preventDefault();
        this.applyTimezone();
        this.editService.save();
        this.changeDetector.markForCheck();
    }
    onClose() {
        this.editService.endEdit();
        this.changeDetector.markForCheck();
        this.focusService.focus();
    }
    get hasAllDay() {
        return Boolean(this.formGroup.get(this.fields.isAllDay));
    }
    get hasStartTimeZone() {
        return Boolean(this.formGroup.get(this.fields.startTimezone));
    }
    get isStartTimeZoneVisible() {
        return this.formGroup && this.formGroup.get('startTimezoneCheckbox').value;
    }
    get hasEndTimeZone() {
        return Boolean(this.formGroup.get(this.fields.endTimezone));
    }
    get isEndTimeZoneVisible() {
        return this.formGroup && this.formGroup.get('endTimezoneCheckbox').value;
    }
    getFormValue(field) {
        if (field) {
            return this.formGroup.get(field);
        }
    }
    textFor(key) {
        return this.localization.get(key);
    }
    onResourceClick(resource) {
        const resourceEditors = resource.multiple ? this.multipleResourceEditors : this.singleResourceEditors;
        const currentEditor = resourceEditors.filter((editor) => editor.resource.field === resource.field).pop();
        if (currentEditor) {
            currentEditor.focus();
        }
    }
    getControl(name) {
        return this.formGroup.get(name);
    }
    reset() {
        this.isActive = false;
        this.setTimeZone = false;
        this.setSeparateStartEndTimeZones = false;
        this.removeTimeZoneCheckboxesFromFormGroup();
        this.focusService.focus();
    }
    addTimeZoneCheckboxesToFormGroup() {
        if (isPresent(this.formGroup)) {
            const startField = this.fields.startTimezone;
            this.formGroup.addControl('startTimezoneCheckbox', new FormControl(this.formGroup.contains(startField) &&
                this.formGroup.get(startField).value));
            const endField = this.fields.endTimezone;
            this.formGroup.addControl('endTimezoneCheckbox', new FormControl(this.formGroup.contains(endField) &&
                this.formGroup.get(endField).value));
        }
    }
    removeTimeZoneCheckboxesFromFormGroup() {
        if (isPresent(this.formGroup)) {
            this.formGroup.removeControl('startTimezoneCheckbox');
            this.formGroup.removeControl('endTimezoneCheckbox');
        }
    }
    subscribeToFormGroupChanges() {
        if (isPresent(this.formGroup)) {
            const fields = this.fields;
            this.formGroup.get('startTimezoneCheckbox').valueChanges.subscribe(isTrue => {
                if (!isTrue) {
                    this.formGroup.get(fields.startTimezone).setValue(null, { emitEvent: false });
                    this.formGroup.get(fields.endTimezone).setValue(null, { emitEvent: false });
                    this.formGroup.get('endTimezoneCheckbox').setValue(false, { emitEvent: false });
                }
            });
            this.formGroup.get('endTimezoneCheckbox').valueChanges.subscribe(isTrue => {
                if (!isTrue) {
                    this.formGroup.get(fields.endTimezone).setValue(null, { emitEvent: false });
                }
            });
            this.formGroup.get(fields.start).valueChanges.subscribe((newStart) => {
                this.recurrenceStart = newStart;
            });
        }
    }
    /**
     * Converts the event dates to "display dates" that look like the original date in its time zone.
     * The result does not represent the same moment in time and must be converted back to local dates.
     */
    applyLocalTimezone() {
        const fields = this.fields;
        const start = this.readDateAsLocal(fields.start, this.eventTimezone);
        const end = this.readDateAsLocal(fields.end, this.endTimezone);
        this.formGroup.get(fields.start).reset(start);
        this.formGroup.get(fields.end).reset(end);
    }
    /**
     * Converts the "display dates" used by the editors back to local dates that represent the true moment in time.
     */
    applyTimezone() {
        const fields = this.fields;
        const start = this.readDateWithTimezone(fields.start, this.eventTimezone);
        const end = this.readDateWithTimezone(fields.end, this.endTimezone);
        this.formGroup.get(fields.start).reset(start);
        this.formGroup.get(fields.end).reset(end);
    }
    readDateWithTimezone(field, timezone) {
        const value = this.formGroup.get(field).value;
        return ZonedDate.fromUTCDate(toUTCDateTime(value), timezone).toLocalDate();
    }
    readDateAsLocal(field, timezone) {
        const value = this.formGroup.get(field).value;
        return toLocalDate(ZonedDate.fromLocalDate(value, timezone).toUTCDate());
    }
}
EditDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditDialogComponent, deps: [{ token: i0.NgZone }, { token: EditService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: FocusService }], target: i0.ɵɵFactoryTarget.Component });
EditDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: EditDialogComponent, isStandalone: true, selector: "kendo-scheduler-edit-dialog", inputs: { resources: "resources", timezone: "timezone", weekStart: "weekStart", fields: "fields", editTemplate: "editTemplate" }, viewQueries: [{ propertyName: "multipleResourceEditors", predicate: MultipleResourceEditorComponent, descendants: true }, { propertyName: "singleResourceEditors", predicate: SingleResourceEditorComponent, descendants: true }], ngImport: i0, template: `
        <kendo-dialog (close)='onClose()' [minWidth]='400' *ngIf='isActive' title='{{ textFor("editorTitle") }}' class='k-scheduler-edit-dialog' [autoFocusedElement]="autoFocusedElement">
            <ng-container *ngIf='!editTemplate'>
                <form
                    class='k-scheduler-edit-form k-form k-form-md'
                    novalidate
                    [formGroup]='formGroup'
                >
                    <!-- Title -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="title"
                            [text]="textFor('editorEventTitle')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <input
                            #title
                            kendoTextBox
                            placeholder='Title'
                            [formControl]='getControl(fields.title)'
                        />
                    </kendo-formfield>

                    <!-- Start -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="startDateTimePicker"
                            [text]="textFor('editorEventStart')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #startDateTimePicker
                            [formControl]='getControl(fields.start)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="hasStartTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-set-timezone'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='startTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-set-timezone'>{{ textFor('editorEventTimeZone') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible">
                        <kendo-label
                            [for]="startTzPicker"
                            [text]="textFor('editorEventStartTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #startTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.startTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- End -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="endDateTimePicker"
                            [text]="textFor('editorEventEnd')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #endDateTimePicker
                            [formControl]='getControl(fields.end)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible && hasEndTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-use-separate'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='endTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-use-separate'>{{ textFor('editorEventSeparateTimeZones') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isEndTimeZoneVisible">
                        <kendo-label
                            [for]="endTzPicker"
                            [text]="textFor('editorEventEndTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #endTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.endTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- All day -->
                    <kendo-formfield *ngIf="hasAllDay">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-is-allday-chkbox'
                                    type='checkbox'
                                    kendoCheckBox
                                    [formControl]='getControl(fields.isAllDay)'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-is-allday-chkbox'>{{ textFor('editorEventAllDay') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <!-- Series -->
                    <kendo-recurrence-editor
                        *ngIf="isEditingSeries"
                        [formControl]='getControl(fields.recurrenceRule)'
                        [start]='recurrenceStart'
                        [timezone]='eventTimezone'
                        [weekStart]='weekStart'
                    ></kendo-recurrence-editor>

                    <!-- Description -->
                    <kendo-formfield *ngIf='getFormValue(fields.description)'>
                        <kendo-label
                            [for]="description"
                            [text]="textFor('editorEventDescription')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <textarea #description kendoTextArea [formControl]='getControl(fields.description)'></textarea>
                    </kendo-formfield>

                    <!-- Resources -->
                    <ng-container *ngFor='let resource of resources'>
                        <kendo-formfield *ngIf='getFormValue(resource.field)'>
                            <label class='k-label k-form-label' (click)="onResourceClick(resource)">
                                {{ resource.name ? resource.name : resource.field }}
                            </label>
                            <kendo-multiple-resource-editor
                                *ngIf='resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-multiple-resource-editor>
                            <kendo-single-resource-editor
                                *ngIf='!resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-single-resource-editor>
                        </kendo-formfield>
                    </ng-container>
                </form>
            </ng-container>

            <ng-container *ngIf='editTemplate'>
                <form novalidate [formGroup]='formGroup'>
                    <ng-container [ngTemplateOutlet]='editTemplate.templateRef'
                        [ngTemplateOutletContext]="{
                            $implicit: formGroup,
                            formGroup: formGroup,
                            dataItem: editedEvent,
                            editMode: editMode,
                            isNew: isNew
                        }">
                    </ng-container>
                </form>
            </ng-container>

            <kendo-dialog-actions layout="start">
                <button
                    kendoButton
                    themeColor="primary"
                    icon="save"
                    [svgIcon]="saveIcon"
                    [disabled]="!formGroup.valid"
                    (click)="onSave($event)"
                >{{ textFor('save') }}</button>
                <button
                    kendoButton
                    icon="cancel-outline"
                    [svgIcon]="cancelIcon"
                    (click)="onCancel($event)"
                >{{ textFor('cancel') }}</button>
            </kendo-dialog-actions>
        </kendo-dialog>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: DialogComponent, selector: "kendo-dialog", inputs: ["actions", "actionsLayout", "autoFocusedElement", "title", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight", "animation", "themeColor"], outputs: ["action", "close"], exportAs: ["kendoDialog"] }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i4.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i4.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "directive", type: i4.FormControlName, selector: "[formControlName]", inputs: ["formControlName", "disabled", "ngModel"], outputs: ["ngModelChange"] }, { kind: "component", type: FormFieldComponent, selector: "kendo-formfield", inputs: ["showHints", "orientation", "showErrors"] }, { kind: "component", type: LabelComponent, selector: "kendo-label", inputs: ["text", "for", "optional", "labelCssStyle", "labelCssClass"], exportAs: ["kendoLabel"] }, { kind: "directive", type: TextBoxDirective, selector: "input[kendoTextBox]", inputs: ["value"] }, { kind: "component", type: SchedulerDateTimePickerComponent, selector: "kendo-scheduler-datetime-picker", inputs: ["isAllDay"], outputs: ["valueChange"] }, { kind: "directive", type: CheckBoxDirective, selector: "input[kendoCheckBox]", inputs: ["size", "rounded"] }, { kind: "directive", type: LabelDirective, selector: "label[for]", inputs: ["for", "labelClass"] }, { kind: "component", type: TimeZoneEditorComponent, selector: "kendo-timezone-editor", inputs: ["width"], outputs: ["valueChange"] }, { kind: "component", type: RecurrenceEditorComponent, selector: "kendo-recurrence-editor", inputs: ["start", "timezone", "weekStart", "repeatEveryOptions", "endAfterOptions", "repeatOnOptions", "endOnOptions"], outputs: ["valueChange"], exportAs: ["kendoRecurrenceEditor"] }, { kind: "directive", type: TextAreaDirective, selector: "textarea[kendoTextArea]", inputs: ["autoSize", "value"], outputs: ["valueChange"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: MultipleResourceEditorComponent, selector: "kendo-multiple-resource-editor" }, { kind: "component", type: SingleResourceEditorComponent, selector: "kendo-single-resource-editor" }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: DialogActionsComponent, selector: "kendo-dialog-actions", inputs: ["actions", "layout"], outputs: ["action"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-scheduler-edit-dialog',
                    template: `
        <kendo-dialog (close)='onClose()' [minWidth]='400' *ngIf='isActive' title='{{ textFor("editorTitle") }}' class='k-scheduler-edit-dialog' [autoFocusedElement]="autoFocusedElement">
            <ng-container *ngIf='!editTemplate'>
                <form
                    class='k-scheduler-edit-form k-form k-form-md'
                    novalidate
                    [formGroup]='formGroup'
                >
                    <!-- Title -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="title"
                            [text]="textFor('editorEventTitle')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <input
                            #title
                            kendoTextBox
                            placeholder='Title'
                            [formControl]='getControl(fields.title)'
                        />
                    </kendo-formfield>

                    <!-- Start -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="startDateTimePicker"
                            [text]="textFor('editorEventStart')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #startDateTimePicker
                            [formControl]='getControl(fields.start)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="hasStartTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-set-timezone'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='startTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-set-timezone'>{{ textFor('editorEventTimeZone') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible">
                        <kendo-label
                            [for]="startTzPicker"
                            [text]="textFor('editorEventStartTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #startTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.startTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- End -->
                    <kendo-formfield>
                        <kendo-label
                            [for]="endDateTimePicker"
                            [text]="textFor('editorEventEnd')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-scheduler-datetime-picker
                            #endDateTimePicker
                            [formControl]='getControl(fields.end)'
                            [isAllDay]='getFormValue(fields.isAllDay)?.value'
                        ></kendo-scheduler-datetime-picker>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isStartTimeZoneVisible && hasEndTimeZone">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-use-separate'
                                    type='checkbox'
                                    kendoCheckBox
                                    formControlName='endTimezoneCheckbox'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-use-separate'>{{ textFor('editorEventSeparateTimeZones') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <kendo-formfield *ngIf="isEndTimeZoneVisible">
                        <kendo-label
                            [for]="endTzPicker"
                            [text]="textFor('editorEventEndTimeZone')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <kendo-timezone-editor
                            #endTzPicker
                            [width]="undefined"
                            [formControl]='getControl(fields.endTimezone)'
                        ></kendo-timezone-editor>
                    </kendo-formfield>

                    <!-- All day -->
                    <kendo-formfield *ngIf="hasAllDay">
                        <ng-container>
                            <span class="k-checkbox-wrap">
                                <input
                                    id='k-is-allday-chkbox'
                                    type='checkbox'
                                    kendoCheckBox
                                    [formControl]='getControl(fields.isAllDay)'
                                />
                            </span>
                            <label [labelClass]="false" class='k-checkbox-label' for='k-is-allday-chkbox'>{{ textFor('editorEventAllDay') }}</label>
                        </ng-container>
                    </kendo-formfield>

                    <!-- Series -->
                    <kendo-recurrence-editor
                        *ngIf="isEditingSeries"
                        [formControl]='getControl(fields.recurrenceRule)'
                        [start]='recurrenceStart'
                        [timezone]='eventTimezone'
                        [weekStart]='weekStart'
                    ></kendo-recurrence-editor>

                    <!-- Description -->
                    <kendo-formfield *ngIf='getFormValue(fields.description)'>
                        <kendo-label
                            [for]="description"
                            [text]="textFor('editorEventDescription')"
                            labelCssClass="k-form-label"
                        ></kendo-label>
                        <textarea #description kendoTextArea [formControl]='getControl(fields.description)'></textarea>
                    </kendo-formfield>

                    <!-- Resources -->
                    <ng-container *ngFor='let resource of resources'>
                        <kendo-formfield *ngIf='getFormValue(resource.field)'>
                            <label class='k-label k-form-label' (click)="onResourceClick(resource)">
                                {{ resource.name ? resource.name : resource.field }}
                            </label>
                            <kendo-multiple-resource-editor
                                *ngIf='resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-multiple-resource-editor>
                            <kendo-single-resource-editor
                                *ngIf='!resource.multiple'
                                [formControl]='getControl(resource.field)'
                                [resource]='resource'>
                            </kendo-single-resource-editor>
                        </kendo-formfield>
                    </ng-container>
                </form>
            </ng-container>

            <ng-container *ngIf='editTemplate'>
                <form novalidate [formGroup]='formGroup'>
                    <ng-container [ngTemplateOutlet]='editTemplate.templateRef'
                        [ngTemplateOutletContext]="{
                            $implicit: formGroup,
                            formGroup: formGroup,
                            dataItem: editedEvent,
                            editMode: editMode,
                            isNew: isNew
                        }">
                    </ng-container>
                </form>
            </ng-container>

            <kendo-dialog-actions layout="start">
                <button
                    kendoButton
                    themeColor="primary"
                    icon="save"
                    [svgIcon]="saveIcon"
                    [disabled]="!formGroup.valid"
                    (click)="onSave($event)"
                >{{ textFor('save') }}</button>
                <button
                    kendoButton
                    icon="cancel-outline"
                    [svgIcon]="cancelIcon"
                    (click)="onCancel($event)"
                >{{ textFor('cancel') }}</button>
            </kendo-dialog-actions>
        </kendo-dialog>
    `,
                    standalone: true,
                    imports: [NgIf, DialogComponent, ReactiveFormsModule, FormFieldComponent, LabelComponent, TextBoxDirective, SchedulerDateTimePickerComponent, CheckBoxDirective, LabelDirective, TimeZoneEditorComponent, RecurrenceEditorComponent, TextAreaDirective, NgFor, MultipleResourceEditorComponent, SingleResourceEditorComponent, NgTemplateOutlet, DialogActionsComponent, ButtonComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: EditService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: FocusService }]; }, propDecorators: { multipleResourceEditors: [{
                type: ViewChildren,
                args: [MultipleResourceEditorComponent]
            }], singleResourceEditors: [{
                type: ViewChildren,
                args: [SingleResourceEditorComponent]
            }], resources: [{
                type: Input
            }], timezone: [{
                type: Input
            }], weekStart: [{
                type: Input
            }], fields: [{
                type: Input
            }], editTemplate: [{
                type: Input
            }] } });

/**
 * A toolbar component which contains the controls for switching the views
 * ([see example]({% slug toolbar_scheduler %}#toc-including-the-built-in-components)).
 *
 * To render the view-selection buttons, include the component in the
 * [toolbar template]({% slug api_scheduler_toolbartemplatedirective %}).
 */
class ToolbarViewSelectorComponent {
    constructor(service, localization) {
        this.service = service;
        this.localization = localization;
        /**
         * Specifies the Toolbar width (in pixels) at which the responsive behavior should be enabled.
         * The responsive behavior means that the ButtonGroup with the views will be replaced by a `select` element.
         *
         * @default 1024
         */
        this.responsiveBreakpoint = 1024;
    }
    /**
     * @hidden
     */
    get ctx() {
        return this.service.context;
    }
    /**
     * @hidden
     */
    get selectView() {
        return this.localization.get('selectView');
    }
    ngOnDestroy() {
        if (this.detachDomEvents) {
            this.detachDomEvents();
        }
    }
    /**
     * @hidden
     */
    select(view) {
        if (this.ctx.selectedView !== view) {
            this.service.navigate({
                type: 'view-change',
                view: view
            });
        }
    }
    /**
     * @hidden
     */
    onChange(e) {
        const view = this.ctx.views.find(view => view.name === e.target.value);
        if (view) {
            this.select(view);
        }
    }
    /**
     * @hidden
     */
    isSelected(view) {
        return this.ctx.selectedView === view;
    }
}
ToolbarViewSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarViewSelectorComponent, deps: [{ token: ToolbarService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
ToolbarViewSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: ToolbarViewSelectorComponent, isStandalone: true, selector: "[kendoSchedulerToolbarViewSelector]", inputs: { toolbarWidth: "toolbarWidth", responsiveBreakpoint: "responsiveBreakpoint" }, ngImport: i0, template: `
        <select
            *ngIf="ctx.views?.length > 1 && toolbarWidth <= responsiveBreakpoint"
            (change)="onChange($event)"
            class="k-views-dropdown k-picker-md k-rounded-md k-picker-solid k-dropdownlist k-picker"
            [attr.aria-label]="selectView"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <option *ngFor="let view of ctx.views"
                [selected]="isSelected(view) === true"
                [value]="view.name"
            >
                {{ view.title }}
            </option>
        </select>
        <span
            *ngIf="toolbarWidth > responsiveBreakpoint"
            class="k-toolbar-button-group k-scheduler-views k-button-group k-button-group-solid"
            role="group"
        >
            <button kendoButton
                type="button"
                *ngFor="let view of ctx.views"
                [selected]="isSelected(view)"
                [attr.aria-pressed]="isSelected(view)"
                (click)="select(view)"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                <span class="k-button-text">
                    {{ view.title }}
                </span>
            </button>
        </span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarViewSelectorComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerToolbarViewSelector]',
                    template: `
        <select
            *ngIf="ctx.views?.length > 1 && toolbarWidth <= responsiveBreakpoint"
            (change)="onChange($event)"
            class="k-views-dropdown k-picker-md k-rounded-md k-picker-solid k-dropdownlist k-picker"
            [attr.aria-label]="selectView"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <option *ngFor="let view of ctx.views"
                [selected]="isSelected(view) === true"
                [value]="view.name"
            >
                {{ view.title }}
            </option>
        </select>
        <span
            *ngIf="toolbarWidth > responsiveBreakpoint"
            class="k-toolbar-button-group k-scheduler-views k-button-group k-button-group-solid"
            role="group"
        >
            <button kendoButton
                type="button"
                *ngFor="let view of ctx.views"
                [selected]="isSelected(view)"
                [attr.aria-pressed]="isSelected(view)"
                (click)="select(view)"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                <span class="k-button-text">
                    {{ view.title }}
                </span>
            </button>
        </span>
    `,
                    standalone: true,
                    imports: [NgIf, FocusableDirective, NgFor, ButtonComponent]
                }]
        }], ctorParameters: function () { return [{ type: ToolbarService }, { type: i1$1.LocalizationService }]; }, propDecorators: { toolbarWidth: [{
                type: Input
            }], responsiveBreakpoint: [{
                type: Input
            }] } });

const iconsMap = { caretAltLeftIcon, caretAltRightIcon, calendarIcon };
/**
 * A toolbar component which contains the controls for date navigation
 * ([see example]({% slug toolbar_scheduler %}#toc-including-the-built-in-components)).
 *
 * To render the **Previous**, **Today**, **Next**, and **Date picker**
 * buttons, include the component in the
 * [toolbar template]({% slug api_scheduler_toolbartemplatedirective %}).
 */
class ToolbarNavigationComponent {
    constructor(popupService, toolbarService, localization, cd, viewContext) {
        this.popupService = popupService;
        this.toolbarService = toolbarService;
        this.localization = localization;
        this.cd = cd;
        this.viewContext = viewContext;
        this.hostClass = true;
        /**
         * Sets the [`activeView`]({% slug api_dateinputs_calendarcomponent %}#toc-activeview) of the Calendar in the navigation component.
         *
         * @default month
         */
        this.activeView = 'month';
        /**
         * Sets the [`bottomView`]({% slug api_dateinputs_calendarcomponent %}#toc-bottomview) of the Calendar in the navigation component.
         *
         * @default month
         */
        this.bottomView = 'month';
        /**
         * @hidden
         */
        this.dateRangeText = { short: '', long: '', current: '' };
        this.isMouseDown = false;
        this.subs = this.localization.changes.subscribe(() => {
            cd.markForCheck();
        });
    }
    set calendar(calendar) {
        if (calendar) {
            calendar.focus();
        }
    }
    /**
     * @hidden
     */
    get todayText() {
        return this.localization.get('today');
    }
    /**
     * @hidden
     */
    get calendarTodayText() {
        return this.localization.get('calendarToday');
    }
    /**
     * @hidden
     */
    get nextText() {
        return this.localization.get('nextTitle');
    }
    /**
     * @hidden
     */
    get previousText() {
        return this.localization.get('previousTitle');
    }
    /**
     * @hidden
     */
    get ctx() {
        return this.toolbarService.context;
    }
    /**
     * @hidden
     */
    svgIcon(name) {
        return iconsMap[name];
    }
    /**
     * @hidden
     */
    onBlur() {
        this.isMouseDown ? null : this.closePopup();
    }
    /**
     * @hidden
     */
    onMouseDown() {
        this.isMouseDown = true;
    }
    ngOnInit() {
        if (!isDocumentAvailable()) {
            return;
        }
        this.subs.add(this.ctx.dateRange.subscribe(res => {
            this.dateRangeText.short = res?.shortText;
            this.dateRangeText.long = res?.text;
            this.setDateRangeText();
        }));
        this.subs.add(this.viewContext.resize.subscribe(() => {
            this.setDateRangeText();
        }));
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.closePopup();
    }
    /**
     * @hidden
     */
    toggleSelectedDate(anchor, template) {
        if (this.popupRef) {
            this.closePopup();
        }
        else {
            const popupSettings = {
                anchor: anchor,
                content: template
            };
            if (this.localization.rtl) {
                popupSettings.popupClass = 'k-rtl';
            }
            this.popupRef = this.popupService.open(popupSettings);
        }
        this.isMouseDown = false;
        return false;
    }
    /**
     * @hidden
     */
    selectDate(value) {
        this.closePopup();
        this.toolbarService.navigate({
            type: 'select-date',
            date: value
        });
    }
    /**
     * @hidden
     */
    prevClick() {
        this.toolbarService.navigate({
            type: 'prev'
        });
        return false;
    }
    /**
     * @hidden
     */
    nextClick() {
        this.toolbarService.navigate({
            type: 'next'
        });
        return false;
    }
    /**
     * @hidden
     */
    todayClick() {
        this.toolbarService.navigate({
            type: 'today'
        });
        return false;
    }
    closePopup() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    setDateRangeText() {
        const isDesktop = window.matchMedia('(min-width: 1024px)').matches;
        this.dateRangeText.current = isDesktop ? this.dateRangeText.long : this.dateRangeText.short;
        this.cd.detectChanges();
    }
    get arrowIcons() {
        return !this.localization.rtl ? ['caret-alt-left', 'caret-alt-right'] : ['caret-alt-right', 'caret-alt-left'];
    }
    get arrowSVGIcons() {
        return !this.localization.rtl ? ['caretAltLeftIcon', 'caretAltRightIcon'] : ['caretAltRightIcon', 'caretAltLeftIcon'];
    }
}
ToolbarNavigationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarNavigationComponent, deps: [{ token: i1$3.PopupService }, { token: ToolbarService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }], target: i0.ɵɵFactoryTarget.Component });
ToolbarNavigationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: ToolbarNavigationComponent, isStandalone: true, selector: "[kendoSchedulerToolbarNavigation]", inputs: { min: "min", max: "max", activeView: "activeView", bottomView: "bottomView" }, host: { properties: { "class.k-toolbar-group": "this.hostClass" } }, providers: [
        PopupService
    ], viewQueries: [{ propertyName: "calendar", first: true, predicate: ["calendar"], descendants: true }], ngImport: i0, template: `
        <span class="k-scheduler-navigation k-button-group k-button-group-solid" role="group">
            <button kendoButton
                (click)="todayClick()"
                class="k-nav-today"
                [attr.title]="todayText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                {{todayText}}
            </button>
            <button kendoButton
                (click)="prevClick()"
                class="k-nav-prev"
                [icon]="arrowIcons[0]"
                [svgIcon]="svgIcon(arrowSVGIcons[0])"
                [attr.title]="previousText"
                [attr.aria-label]="previousText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
            <button kendoButton
                (click)="nextClick()"
                type="button"
                class="k-nav-next"
                [icon]="arrowIcons[1]"
                [svgIcon]="svgIcon(arrowSVGIcons[1])"
                [attr.title]="nextText"
                [attr.aria-label]="nextText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
        </span>

        <button
            #anchor
            kendoButton
            type="button"
            icon="calendar"
            [svgIcon]="svgIcon('calendarIcon')"
            fillMode="flat"
            (mousedown)="onMouseDown()"
            (mouseup)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.enter)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.alt.arrowdown)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            role="button"
            class="k-nav-current"
            [attr.aria-live]="'polite'"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <span>{{ dateRangeText?.current }}</span>
        </button>

        <ng-template #template>
            <kendo-calendar
                #calendar
                (blur)="onBlur()"
                [activeView]="activeView"
                [bottomView]="bottomView"
                (keydown.escape)="toggleSelectedDate({ nativeElement: anchor }, template); anchor.focus();"
                (valueChange)="selectDate($event)"
                [value]="ctx.selectedDate | async" [min]="min" [max]="max">
                <kendo-calendar-messages [today]="calendarTodayText">
                </kendo-calendar-messages>
            </kendo-calendar>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "component", type: CalendarComponent, selector: "kendo-calendar", inputs: ["showOtherMonthDays", "id", "focusedDate", "min", "max", "rangeValidation", "weekDaysFormat", "footer", "selection", "allowReverse", "value", "disabled", "tabindex", "tabIndex", "disabledDates", "navigation", "activeView", "bottomView", "topView", "type", "animateNavigation", "weekNumber", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate", "headerTemplate", "footerTemplate", "navigationItemTemplate", "size", "activeRangeEnd"], outputs: ["activeViewChange", "navigate", "activeViewDateChange", "blur", "focus", "valueChange"], exportAs: ["kendo-calendar"] }, { kind: "component", type: CalendarCustomMessagesComponent, selector: "kendo-calendar-messages" }, { kind: "pipe", type: AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarNavigationComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerToolbarNavigation]',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        PopupService
                    ],
                    template: `
        <span class="k-scheduler-navigation k-button-group k-button-group-solid" role="group">
            <button kendoButton
                (click)="todayClick()"
                class="k-nav-today"
                [attr.title]="todayText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
                {{todayText}}
            </button>
            <button kendoButton
                (click)="prevClick()"
                class="k-nav-prev"
                [icon]="arrowIcons[0]"
                [svgIcon]="svgIcon(arrowSVGIcons[0])"
                [attr.title]="previousText"
                [attr.aria-label]="previousText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
            <button kendoButton
                (click)="nextClick()"
                type="button"
                class="k-nav-next"
                [icon]="arrowIcons[1]"
                [svgIcon]="svgIcon(arrowSVGIcons[1])"
                [attr.title]="nextText"
                [attr.aria-label]="nextText"
                [kendoSchedulerFocusIndex]="0"
                containerType="toolbar">
            </button>
        </span>

        <button
            #anchor
            kendoButton
            type="button"
            icon="calendar"
            [svgIcon]="svgIcon('calendarIcon')"
            fillMode="flat"
            (mousedown)="onMouseDown()"
            (mouseup)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.enter)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            (keydown.alt.arrowdown)="toggleSelectedDate({ nativeElement: anchor.element }, template)"
            role="button"
            class="k-nav-current"
            [attr.aria-live]="'polite'"
            [kendoSchedulerFocusIndex]="0"
            containerType="toolbar">
            <span>{{ dateRangeText?.current }}</span>
        </button>

        <ng-template #template>
            <kendo-calendar
                #calendar
                (blur)="onBlur()"
                [activeView]="activeView"
                [bottomView]="bottomView"
                (keydown.escape)="toggleSelectedDate({ nativeElement: anchor }, template); anchor.focus();"
                (valueChange)="selectDate($event)"
                [value]="ctx.selectedDate | async" [min]="min" [max]="max">
                <kendo-calendar-messages [today]="calendarTodayText">
                </kendo-calendar-messages>
            </kendo-calendar>
        </ng-template>
    `,
                    standalone: true,
                    imports: [ButtonComponent, FocusableDirective, CalendarComponent, CalendarCustomMessagesComponent, AsyncPipe]
                }]
        }], ctorParameters: function () { return [{ type: i1$3.PopupService }, { type: ToolbarService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }]; }, propDecorators: { calendar: [{
                type: ViewChild,
                args: ['calendar', { static: false }]
            }], hostClass: [{
                type: HostBinding,
                args: ['class.k-toolbar-group']
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], activeView: [{
                type: Input
            }], bottomView: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ToolbarComponent {
    constructor(service, element, zone) {
        this.service = service;
        this.element = element;
        this.zone = zone;
        this.hostClasses = true;
        this.toolbarRole = 'toolbar';
        this.navigate = new EventEmitter();
        this.toolbarWidthChange = new EventEmitter();
        // The template context is the same as the service context,
        // but with resolved values instead of observables.
        this.templateContext = {};
        this.subs = new Subscription();
        this.subs.add(service.action.subscribe(action => this.navigate.next(action)));
    }
    /**
     * @hidden
     */
    get activeView() {
        return this.service.context.selectedView?.name === 'year' ? 'decade' : 'month';
    }
    /**
     * @hidden
     */
    get bottomView() {
        return this.service.context.selectedView?.name === 'year' ? 'decade' : 'month';
    }
    ngOnInit() {
        this.subs.add(this.selectedDate.subscribe(date => this.templateContext.selectedDate = date));
        this.subs.add(this.dateRange.subscribe(dateRange => this.templateContext.dateRange = dateRange));
        this.resizeHandler();
    }
    ngOnChanges() {
        this.service.context = {
            dateRange: this.dateRange,
            selectedDate: this.selectedDate,
            views: this.views,
            selectedView: this.selectedView
        };
        Object.assign(this.templateContext, {
            views: this.views,
            selectedView: this.selectedView
            // The dateRange and selectedDate context fields
            // are updated through the subscriptions added in ngOnInit.
        });
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    resizeHandler() {
        const element = this.element.nativeElement;
        this.zone.run(() => this.toolbarWidth = element.offsetWidth);
        this.toolbarWidthChange.emit(this.toolbarWidth);
    }
}
ToolbarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarComponent, deps: [{ token: ToolbarService }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
ToolbarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: ToolbarComponent, isStandalone: true, selector: "kendo-scheduler-toolbar", inputs: { selectedView: "selectedView", views: "views", dateRange: "dateRange", selectedDate: "selectedDate", template: "template", min: "min", max: "max" }, outputs: { navigate: "navigate", toolbarWidthChange: "toolbarWidthChange" }, host: { properties: { "class.k-scheduler-toolbar": "this.hostClasses", "class.k-toolbar": "this.hostClasses", "class.k-toolbar-md": "this.hostClasses", "attr.role": "this.toolbarRole" } }, usesOnChanges: true, ngImport: i0, template: `
        <ng-template
            *ngIf="template; else defaultTemplate"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext"
        >
        </ng-template>

        <ng-template #defaultTemplate>
            <div kendoSchedulerToolbarNavigation
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView">
            </div>
            <span class="k-spacer"></span>
            <div kendoSchedulerToolbarViewSelector [toolbarWidth]="toolbarWidth"></div>
        </ng-template>

        <kendo-resize-sensor (resize)="resizeHandler()" [style]="'display: contents;'"></kendo-resize-sensor>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: ToolbarNavigationComponent, selector: "[kendoSchedulerToolbarNavigation]", inputs: ["min", "max", "activeView", "bottomView"] }, { kind: "component", type: ToolbarViewSelectorComponent, selector: "[kendoSchedulerToolbarViewSelector]", inputs: ["toolbarWidth", "responsiveBreakpoint"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ToolbarComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-scheduler-toolbar',
                    template: `
        <ng-template
            *ngIf="template; else defaultTemplate"
            [ngTemplateOutlet]="template.templateRef"
            [ngTemplateOutletContext]="templateContext"
        >
        </ng-template>

        <ng-template #defaultTemplate>
            <div kendoSchedulerToolbarNavigation
                [min]="min"
                [max]="max"
                [activeView]="activeView"
                [bottomView]="bottomView">
            </div>
            <span class="k-spacer"></span>
            <div kendoSchedulerToolbarViewSelector [toolbarWidth]="toolbarWidth"></div>
        </ng-template>

        <kendo-resize-sensor (resize)="resizeHandler()" [style]="'display: contents;'"></kendo-resize-sensor>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet, ToolbarNavigationComponent, ToolbarViewSelectorComponent, ResizeSensorComponent]
                }]
        }], ctorParameters: function () { return [{ type: ToolbarService }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-scheduler-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar-md']
            }], toolbarRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], selectedView: [{
                type: Input
            }], views: [{
                type: Input
            }], dateRange: [{
                type: Input
            }], selectedDate: [{
                type: Input
            }], template: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], navigate: [{
                type: Output
            }], toolbarWidthChange: [{
                type: Output
            }] } });

/**
 * @hidden
 */
class Messages extends ComponentMessages {
}
Messages.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: Messages, deps: null, target: i0.ɵɵFactoryTarget.Directive });
Messages.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: Messages, inputs: { allEvents: "allEvents", allDay: "allDay", dateHeader: "dateHeader", timeHeader: "timeHeader", eventHeader: "eventHeader", deleteTitle: "deleteTitle", nextTitle: "nextTitle", previousTitle: "previousTitle", today: "today", calendarToday: "calendarToday", showFullDay: "showFullDay", showWorkDay: "showWorkDay", dayViewTitle: "dayViewTitle", multiDayViewTitle: "multiDayViewTitle", weekViewTitle: "weekViewTitle", workWeekViewTitle: "workWeekViewTitle", monthViewTitle: "monthViewTitle", multiWeekViewTitle: "multiWeekViewTitle", timelineViewTitle: "timelineViewTitle", timelineWeekViewTitle: "timelineWeekViewTitle", timelineMonthViewTitle: "timelineMonthViewTitle", agendaViewTitle: "agendaViewTitle", yearViewTitle: "yearViewTitle", yearViewNoEvents: "yearViewNoEvents", cancel: "cancel", save: "save", editorEventTitle: "editorEventTitle", editorEventStart: "editorEventStart", editorEventStartTimeZone: "editorEventStartTimeZone", editorEventEnd: "editorEventEnd", editorEventEndTimeZone: "editorEventEndTimeZone", editorEventAllDay: "editorEventAllDay", editorEventDescription: "editorEventDescription", editorEventSeparateTimeZones: "editorEventSeparateTimeZones", editorEventTimeZone: "editorEventTimeZone", editorDateInputsToday: "editorDateInputsToday", editorDateInputsToggle: "editorDateInputsToggle", editorDateInputsParentViewButton: "editorDateInputsParentViewButton", editorDateInputsNow: "editorDateInputsNow", editorDateInputsNowLabel: "editorDateInputsNowLabel", editorDateInputsAccept: "editorDateInputsAccept", editorDateInputsAcceptLabel: "editorDateInputsAcceptLabel", editorDateInputsCancel: "editorDateInputsCancel", editorDateInputsCancelLabel: "editorDateInputsCancelLabel", editorDateInputsDateTab: "editorDateInputsDateTab", editorDateInputsDateTabLabel: "editorDateInputsDateTabLabel", editorDateInputsTimeTab: "editorDateInputsTimeTab", editorDateInputsTimeTabLabel: "editorDateInputsTimeTabLabel", recurrenceEditorDateInputsToday: "recurrenceEditorDateInputsToday", recurrenceEditorDateInputsToggle: "recurrenceEditorDateInputsToggle", recurrenceEditorDateInputsParentViewButton: "recurrenceEditorDateInputsParentViewButton", recurrenceEditorNumericIncrement: "recurrenceEditorNumericIncrement", recurrenceEditorNumericDecrement: "recurrenceEditorNumericDecrement", recurrenceEditorRepeat: "recurrenceEditorRepeat", recurrenceEditorDailyInterval: "recurrenceEditorDailyInterval", recurrenceEditorDailyRepeatEvery: "recurrenceEditorDailyRepeatEvery", recurrenceEditorWeeklyInterval: "recurrenceEditorWeeklyInterval", recurrenceEditorWeeklyRepeatEvery: "recurrenceEditorWeeklyRepeatEvery", recurrenceEditorWeeklyRepeatOn: "recurrenceEditorWeeklyRepeatOn", recurrenceEditorMonthlyDay: "recurrenceEditorMonthlyDay", recurrenceEditorMonthlyInterval: "recurrenceEditorMonthlyInterval", recurrenceEditorMonthlyRepeatEvery: "recurrenceEditorMonthlyRepeatEvery", recurrenceEditorMonthlyRepeatOn: "recurrenceEditorMonthlyRepeatOn", recurrenceEditorYearlyOf: "recurrenceEditorYearlyOf", recurrenceEditorYearlyRepeatEvery: "recurrenceEditorYearlyRepeatEvery", recurrenceEditorYearlyRepeatOn: "recurrenceEditorYearlyRepeatOn", recurrenceEditorYearlyInterval: "recurrenceEditorYearlyInterval", recurrenceEditorFrequenciesDaily: "recurrenceEditorFrequenciesDaily", recurrenceEditorFrequenciesMonthly: "recurrenceEditorFrequenciesMonthly", recurrenceEditorFrequenciesNever: "recurrenceEditorFrequenciesNever", recurrenceEditorFrequenciesWeekly: "recurrenceEditorFrequenciesWeekly", recurrenceEditorFrequenciesYearly: "recurrenceEditorFrequenciesYearly", recurrenceEditorOffsetPositionsFirst: "recurrenceEditorOffsetPositionsFirst", recurrenceEditorOffsetPositionsSecond: "recurrenceEditorOffsetPositionsSecond", recurrenceEditorOffsetPositionsThird: "recurrenceEditorOffsetPositionsThird", recurrenceEditorOffsetPositionsFourth: "recurrenceEditorOffsetPositionsFourth", recurrenceEditorOffsetPositionsLast: "recurrenceEditorOffsetPositionsLast", recurrenceEditorWeekdaysDay: "recurrenceEditorWeekdaysDay", recurrenceEditorWeekdaysWeekday: "recurrenceEditorWeekdaysWeekday", recurrenceEditorWeekdaysWeekendday: "recurrenceEditorWeekdaysWeekendday", recurrenceEditorEndAfter: "recurrenceEditorEndAfter", recurrenceEditorEndOccurrence: "recurrenceEditorEndOccurrence", recurrenceEditorEndLabel: "recurrenceEditorEndLabel", recurrenceEditorEndNever: "recurrenceEditorEndNever", recurrenceEditorEndOn: "recurrenceEditorEndOn", editorTitle: "editorTitle", destroy: "destroy", deleteConfirmation: "deleteConfirmation", editRecurringConfirmation: "editRecurringConfirmation", editOccurrence: "editOccurrence", editSeries: "editSeries", deleteRecurringConfirmation: "deleteRecurringConfirmation", deleteOccurrence: "deleteOccurrence", deleteSeries: "deleteSeries", deleteDialogTitle: "deleteDialogTitle", deleteRecurringDialogTitle: "deleteRecurringDialogTitle", editRecurringDialogTitle: "editRecurringDialogTitle", selectView: "selectView" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: Messages, decorators: [{
            type: Directive
        }], propDecorators: { allEvents: [{
                type: Input
            }], allDay: [{
                type: Input
            }], dateHeader: [{
                type: Input
            }], timeHeader: [{
                type: Input
            }], eventHeader: [{
                type: Input
            }], deleteTitle: [{
                type: Input
            }], nextTitle: [{
                type: Input
            }], previousTitle: [{
                type: Input
            }], today: [{
                type: Input
            }], calendarToday: [{
                type: Input
            }], showFullDay: [{
                type: Input
            }], showWorkDay: [{
                type: Input
            }], dayViewTitle: [{
                type: Input
            }], multiDayViewTitle: [{
                type: Input
            }], weekViewTitle: [{
                type: Input
            }], workWeekViewTitle: [{
                type: Input
            }], monthViewTitle: [{
                type: Input
            }], multiWeekViewTitle: [{
                type: Input
            }], timelineViewTitle: [{
                type: Input
            }], timelineWeekViewTitle: [{
                type: Input
            }], timelineMonthViewTitle: [{
                type: Input
            }], agendaViewTitle: [{
                type: Input
            }], yearViewTitle: [{
                type: Input
            }], yearViewNoEvents: [{
                type: Input
            }], cancel: [{
                type: Input
            }], save: [{
                type: Input
            }], editorEventTitle: [{
                type: Input
            }], editorEventStart: [{
                type: Input
            }], editorEventStartTimeZone: [{
                type: Input
            }], editorEventEnd: [{
                type: Input
            }], editorEventEndTimeZone: [{
                type: Input
            }], editorEventAllDay: [{
                type: Input
            }], editorEventDescription: [{
                type: Input
            }], editorEventSeparateTimeZones: [{
                type: Input
            }], editorEventTimeZone: [{
                type: Input
            }], editorDateInputsToday: [{
                type: Input
            }], editorDateInputsToggle: [{
                type: Input
            }], editorDateInputsParentViewButton: [{
                type: Input
            }], editorDateInputsNow: [{
                type: Input
            }], editorDateInputsNowLabel: [{
                type: Input
            }], editorDateInputsAccept: [{
                type: Input
            }], editorDateInputsAcceptLabel: [{
                type: Input
            }], editorDateInputsCancel: [{
                type: Input
            }], editorDateInputsCancelLabel: [{
                type: Input
            }], editorDateInputsDateTab: [{
                type: Input
            }], editorDateInputsDateTabLabel: [{
                type: Input
            }], editorDateInputsTimeTab: [{
                type: Input
            }], editorDateInputsTimeTabLabel: [{
                type: Input
            }], recurrenceEditorDateInputsToday: [{
                type: Input
            }], recurrenceEditorDateInputsToggle: [{
                type: Input
            }], recurrenceEditorDateInputsParentViewButton: [{
                type: Input
            }], recurrenceEditorNumericIncrement: [{
                type: Input
            }], recurrenceEditorNumericDecrement: [{
                type: Input
            }], recurrenceEditorRepeat: [{
                type: Input
            }], recurrenceEditorDailyInterval: [{
                type: Input
            }], recurrenceEditorDailyRepeatEvery: [{
                type: Input
            }], recurrenceEditorWeeklyInterval: [{
                type: Input
            }], recurrenceEditorWeeklyRepeatEvery: [{
                type: Input
            }], recurrenceEditorWeeklyRepeatOn: [{
                type: Input
            }], recurrenceEditorMonthlyDay: [{
                type: Input
            }], recurrenceEditorMonthlyInterval: [{
                type: Input
            }], recurrenceEditorMonthlyRepeatEvery: [{
                type: Input
            }], recurrenceEditorMonthlyRepeatOn: [{
                type: Input
            }], recurrenceEditorYearlyOf: [{
                type: Input
            }], recurrenceEditorYearlyRepeatEvery: [{
                type: Input
            }], recurrenceEditorYearlyRepeatOn: [{
                type: Input
            }], recurrenceEditorYearlyInterval: [{
                type: Input
            }], recurrenceEditorFrequenciesDaily: [{
                type: Input
            }], recurrenceEditorFrequenciesMonthly: [{
                type: Input
            }], recurrenceEditorFrequenciesNever: [{
                type: Input
            }], recurrenceEditorFrequenciesWeekly: [{
                type: Input
            }], recurrenceEditorFrequenciesYearly: [{
                type: Input
            }], recurrenceEditorOffsetPositionsFirst: [{
                type: Input
            }], recurrenceEditorOffsetPositionsSecond: [{
                type: Input
            }], recurrenceEditorOffsetPositionsThird: [{
                type: Input
            }], recurrenceEditorOffsetPositionsFourth: [{
                type: Input
            }], recurrenceEditorOffsetPositionsLast: [{
                type: Input
            }], recurrenceEditorWeekdaysDay: [{
                type: Input
            }], recurrenceEditorWeekdaysWeekday: [{
                type: Input
            }], recurrenceEditorWeekdaysWeekendday: [{
                type: Input
            }], recurrenceEditorEndAfter: [{
                type: Input
            }], recurrenceEditorEndOccurrence: [{
                type: Input
            }], recurrenceEditorEndLabel: [{
                type: Input
            }], recurrenceEditorEndNever: [{
                type: Input
            }], recurrenceEditorEndOn: [{
                type: Input
            }], editorTitle: [{
                type: Input
            }], destroy: [{
                type: Input
            }], deleteConfirmation: [{
                type: Input
            }], editRecurringConfirmation: [{
                type: Input
            }], editOccurrence: [{
                type: Input
            }], editSeries: [{
                type: Input
            }], deleteRecurringConfirmation: [{
                type: Input
            }], deleteOccurrence: [{
                type: Input
            }], deleteSeries: [{
                type: Input
            }], deleteDialogTitle: [{
                type: Input
            }], deleteRecurringDialogTitle: [{
                type: Input
            }], editRecurringDialogTitle: [{
                type: Input
            }], selectView: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class LocalizedMessagesDirective extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
}
LocalizedMessagesDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LocalizedMessagesDirective, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
LocalizedMessagesDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: LocalizedMessagesDirective, isStandalone: true, selector: "[kendoSchedulerLocalizedMessages]", providers: [
        {
            provide: Messages,
            useExisting: forwardRef(() => LocalizedMessagesDirective)
        }
    ], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: LocalizedMessagesDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => LocalizedMessagesDirective)
                        }
                    ],
                    selector: '[kendoSchedulerLocalizedMessages]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }]; } });

const todayDate = () => getDate(new Date());
const DAYS_IN_WEEK$1 = 7;
/**
 * Represents the [Kendo UI Scheduler component for Angular]({% slug overview_scheduler %}).
 */
class SchedulerComponent {
    constructor(wrapper, viewContext, viewState, editService, dialogsService, intlService, changeDetector, zone, pdfService, localization, domEvents, renderer, focusService) {
        this.wrapper = wrapper;
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.editService = editService;
        this.dialogsService = dialogsService;
        this.intlService = intlService;
        this.changeDetector = changeDetector;
        this.zone = zone;
        this.pdfService = pdfService;
        this.localization = localization;
        this.domEvents = domEvents;
        this.renderer = renderer;
        this.focusService = focusService;
        this.hostClasses = true;
        this.ariaRole = 'application';
        this.rtl = false;
        /**
         * Specifies if the Scheduler is editable.
         */
        this.editable = false;
        /**
         * Specifies if the Scheduler's day or time slots are selectable ([see example]({% slug slotselection_scheduler %}#toc-custom-callback)).
         *
         * When this input is set to `true`, the Scheduler component will emit [`slotDragStart`]({% slug api_scheduler_schedulercomponent %}#toc-slotdragstart), [`slotDrag`]({% slug api_scheduler_schedulercomponent %}#toc-slotdrag), and [`slotDragEnd`]({% slug api_scheduler_schedulercomponent %}#toc-slotdragend) events upon user interaction.
         */
        this.selectable = false;
        /**
         * The height of the events in the **Month** and **Timeline** views, and the height of the **All day** events in the **Day** and **Week** views.
         * @default 25
         */
        this.eventHeight = 25;
        /**
         * Specifies the columns width. Applicable for the **Timeline** views.
         * @default 100
         */
        this.columnWidth = 100;
        /**
         * The start time of the view. The Scheduler displays events which start after the start time.
         * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default '00:00'
         */
        this.startTime = '00:00';
        /**
         * The end time of the view. The Scheduler displays events which end before the end time.
         * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default '00:00'
         */
        this.endTime = '00:00';
        /**
         * The start time of the view when `showWorkHours` is set to `true`.
         * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default '08:00'
         */
        this.workDayStart = '08:00';
        /**
         * The end time of the view when `showWorkHours` is set to `true`.
         * Accepts string values in the `HH:mm` format. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default '17:00'
         */
        this.workDayEnd = '17:00';
        /**
         * The duration (in minutes) of the time slots. Applicable for the day, week and timeline views.
         * @default 60
         */
        this.slotDuration = 60;
        /**
         * The number of divisions of the time slots. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default 2
         */
        this.slotDivisions = 2;
        /**
         * A numeric value between 0 and 1 that specifies what percentage of the slot will be filled by the events.
         * Applicable for the **Day** and **Week** views.
         * @default 0.9
         */
        this.slotFill = 0.9;
        /**
         * Toggles the visibility of the all-day slot.
         * Applicable for the **Day**, **Multi-Day**, **Week**, and **Work-Week** views.
         * @default true
         */
        this.allDaySlot = true;
        /**
         * The time to which the view will initially be scrolled.
         * Accepts string values in the `HH:mm` format or a JavaScript `Date`. Applicable for the **Day**, **Week**, and **Timeline** views.
         * @default '08:00'
         */
        this.scrollTime = this.workDayStart;
        /**
         * Specifies the Scheduler current time marker settings.
         * @default true
         */
        this.currentTimeMarker = true;
        /**
         * Specifies the settings for the ongoing events highlight of the Scheduler.
         * @default true
         */
        this.highlightOngoingEvents = true;
        /**
         * Specifies whether to display the toolbar of the Scheduler.
         * @default true
         */
        this.showToolbar = true;
        /**
         * Specifies whether to display the footer of the Scheduler.
         * @default true
         */
        this.showFooter = true;
        /**
         * A callback that executes for each slot of the Scheduler view.
         * If it returns `true`, the `k-selected` CSS class will be added to the cell, making it visibly selected.
         * @default () => false
         */
        this.isSlotSelected = alwaysFalse;
        /**
         * @hidden
         */
        this.selectedViewIndexChange = new EventEmitter();
        /**
         * Fires when the Scheduler is about to execute a navigation action
         * (a view, date, or focus change).
         */
        this.navigate = new EventEmitter();
        /**
         * Fires when the date range that is displayed in the Scheduler changes.
         */
        this.dateChange = new EventEmitter();
        /**
         * Fires when a Scheduler view slot is clicked.
         */
        this.slotClick = new EventEmitter();
        /**
         * Fires when a Scheduler view slot is double-clicked.
         */
        this.slotDblClick = new EventEmitter();
        /**
         * Fires when the user creates a new event using the `'c'` key.
         * ([see example]({% slug keyboard_navigation_scheduler %})).
         */
        this.create = new EventEmitter();
        /**
         * Fires when a Scheduler event is clicked.
         */
        this.eventClick = new EventEmitter();
        /**
         * Fires when a Scheduler event is double-clicked.
         */
        this.eventDblClick = new EventEmitter();
        /**
         * Fires when a key is pressed on a focused Scheduler event.
         */
        this.eventKeydown = new EventEmitter();
        /**
         * Fires when the user cancels the editing by clicking the **Cancel** command button.
         */
        this.cancel = new EventEmitter();
        /**
         * Fires when the user clicks the **Save** command button to save the changes of the edited event.
         */
        this.save = new EventEmitter();
        /**
         * Fires when the user clicks the **Remove** icon of a Scheduler event.
         */
        this.remove = new EventEmitter();
        /**
         * Fires when the user starts resizing a Scheduler event.
         */
        this.resizeStart = new EventEmitter();
        /**
         * Fires when the user is resizing a Scheduler event.
         */
        this.resize = new EventEmitter();
        /**
         * Fires when the user stops resizing a Scheduler event.
         */
        this.resizeEnd = new EventEmitter();
        /**
         * Fires when the user starts dragging a Scheduler event.
         */
        this.dragStart = new EventEmitter();
        /**
         * Fires when the user is dragging a Scheduler event.
         */
        this.drag = new EventEmitter();
        /**
         * Fires when the user stops dragging a Scheduler event.
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fires when the user starts drag-selecting a Scheduler slot range.
         */
        this.slotDragStart = new EventEmitter();
        /**
         * Fires when the user is drag-selecting a Scheduler slot range.
         */
        this.slotDrag = new EventEmitter();
        /**
         * Fires when the user stops drag-selecting a Scheduler slot range.
         */
        this.slotDragEnd = new EventEmitter();
        /**
         * Fires when the user clicks the **PDF export** command button.
         */
        this.pdfExport = new EventEmitter();
        /**
         * Fires when the Scheduler is resized horizontally.
         */
        this.schedulerResize = new EventEmitter();
        /**
         * @hidden
         */
        this.dragEndConfirmed = new EventEmitter();
        /**
         * @hidden
         */
        this.resizeEndConfirmed = new EventEmitter();
        /**
         * @hidden
         */
        this.removeConfirmed = new EventEmitter();
        /**
         * @hidden
         */
        this.showLicenseWatermark = false;
        this.viewIndex = 0;
        this._timezone = '';
        this._modelFields = defaultModelFields;
        const isValid = validatePackage(packageMetadata);
        this.showLicenseWatermark = shouldShowValidationUI(isValid);
        this.dateRangeStream = viewState.dateRange;
        this.selectedDateStream = viewContext.selectedDate;
    }
    get dir() {
        return this.direction;
    }
    /**
     * The index of the currently selected view.
     *
     * By default, the selected view index is `0` and
     * indicates that the first declared view is visible.
     */
    set selectedViewIndex(index) {
        this.viewIndex = index;
        this.onViewIndexChange();
    }
    get selectedViewIndex() {
        return this.viewIndex;
    }
    /**
     * The first day of the week. Applicable to **Week**, **Month** and **TimelineWeek** views.
     * Defaults to the locale settings.
     */
    set weekStart(value) {
        this._weekStart = value;
    }
    get weekStart() {
        if (isPresent(this._weekStart)) {
            return this._weekStart;
        }
        return this.intlService.firstDay();
    }
    /**
     * Specifies the id of the timezone that will be displayed in the Scheduler.
     * For example, `Europe/Sofia`.
     * @default 'Etc/UTC'
     */
    set timezone(value) {
        this._timezone = value;
        this.events = this.events || [];
    }
    get timezone() {
        return this._timezone;
    }
    /**
     * An array of event instances which will be shown by the Scheduler.
     */
    set events(value) {
        this._events = value;
        this.processEvents(value);
    }
    get events() {
        return this._events;
    }
    /**
     * The currently selected date of the Scheduler.
     * Determines the period which is displayed.
     */
    set selectedDate(value) {
        if (!value) {
            return;
        }
        this._selectedDate = value;
        this.viewContext.notifySelectedDate(value);
    }
    get selectedDate() {
        return this._selectedDate;
    }
    /**
     * The names of the model fields from which the Scheduler will read its data
     * ([see example]({% slug databinding_scheduler %}#toc-binding-to-models)).
     */
    set modelFields(value) {
        this._modelFields = { ...defaultModelFields, ...value };
    }
    get modelFields() {
        return this._modelFields;
    }
    /**
     * @hidden
     */
    get viewToolbar() {
        return this.viewState?.toolbarVisibilityByView.get(this.selectedView);
    }
    ngOnInit() {
        if (!this.selectedDate) {
            this.selectedDate = todayDate();
        }
    }
    ngAfterContentInit() {
        if (isDevMode() && this.views.length === 0) {
            throw new Error('No views declared for <kendo-scheduler>. Please, declare at least one view.');
        }
        this.subs = this.views.changes.subscribe(() => this.resetViewIndex());
        this.subs.add(this.intlService.changes.subscribe(this.intlChange.bind(this)));
        this.subs.add(this.viewState.nextDate.subscribe(nextDate => {
            this.selectedDate = nextDate;
        }));
        this.subs.add(this.viewState.dateRange.subscribe(dateRange => {
            const isEmpty = dateRange.start.getTime() === 0;
            if (!isEmpty) {
                const args = new DateChangeEvent(this, this.selectedDate, dateRange);
                this.dateChange.emit(args);
            }
        }));
        this.subs.add(this.viewState.navigate.subscribe(({ viewName, date }) => {
            const views = this.views.toArray();
            const view = views.find(v => v.name === viewName);
            const args = new NavigateEvent(this, {
                type: 'show-date',
                view: view || {
                    name: viewName,
                    title: viewName
                },
                date: date
            });
            this.navigate.next(args);
            if (view && !args.isDefaultPrevented()) {
                const index = views.indexOf(view);
                this.selectedView = view;
                this.setViewIndex(index);
                this.selectedDate = date;
            }
        }));
        this.subs.add(this.viewState.viewEvent.subscribe(({ name, args }) => {
            const emitter = this[name];
            const confirmedEmitter = this[`${name}Confirmed`];
            if (hasObservers(emitter) || (confirmedEmitter && hasObservers(confirmedEmitter))) {
                this.zone.run(() => {
                    const eventInstance = new VIEW_EVENT_MAP[name](this, args);
                    emitter.emit(eventInstance);
                    args.prevented = eventInstance.prevented;
                    if (confirmedEmitter && !args.prevented) {
                        confirmedEmitter.emit(eventInstance);
                    }
                });
            }
        }));
        this.subs.add(this.viewState.layoutEnd.subscribe(() => {
            if (this.resizeSensor) {
                this.resizeSensor.acceptSize();
            }
        }));
        this.subs.add(this.viewState.slotSelectionStart
            .subscribe((e) => {
            if (hasObservers(this.slotDragStart)) {
                this.zone.run(() => {
                    this.slotDragStart.emit(Object.assign(e, { sender: this }));
                });
            }
        }));
        this.subs.add(this.viewState.slotSelectionDrag
            .subscribe((value) => {
            if (hasObservers(this.slotDrag)) {
                this.zone.run(() => {
                    this.slotDrag.emit(new SlotDragEvent(this, value));
                });
            }
        }));
        this.subs.add(this.viewState.slotSelectionEnd
            .subscribe((value) => {
            if (hasObservers(this.slotDragEnd)) {
                this.zone.run(() => {
                    this.slotDragEnd.emit(new SlotDragEndEvent(this, value));
                });
            }
        }));
        this.onViewIndexChange();
        this.notifyOptionsChange = this.notifyOptionsChange.bind(this);
        this.subs.add(this.allDayEventTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.eventTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.timeSlotTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.timeSlotTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.minorTimeHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.majorTimeHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.monthDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.multiWeekDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.dateHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.allDaySlotTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.groupHeaderTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.agendaDateTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.agendaTimeTemplate.changes.subscribe(this.notifyOptionsChange));
        this.subs.add(this.views.changes.subscribe(() => {
            this.changeDetector.markForCheck();
        }));
        //this.editService.timezone = this.timezone;
        this.attachEditHandlers();
        this.dialogsService.container = this.confirmationDialogContainerRef;
        this.notifyOptionsChange();
        this.subs.add(this.pdfService.exportClick.subscribe(() => {
            const args = new PDFExportEvent();
            this.pdfExport.emit(args);
            if (!args.isDefaultPrevented()) {
                this.saveAsPDF();
            }
        }));
        this.subs.add(this.pdfService.done.subscribe(() => {
            this.loadingComponent.toggle(false);
        }));
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
            this.direction = this.rtl ? 'rtl' : 'ltr';
        }));
        this.subs.add(this.viewState.optionsChange.subscribe(() => {
            this.changeDetector.markForCheck();
        }));
        this.attachElementEventHandlers();
    }
    ngOnChanges(changes) {
        if (isChanged('resources', changes) && !isChanged('events', changes) && this.viewItems) {
            this.viewItems.forEach(item => {
                copyResources(item.event, this.resources);
            });
        }
        if (anyChanged([
            'group', 'resources', 'min', 'max', 'showWorkHours', 'startTime', 'scrollTime', 'endTime', 'eventHeight',
            'workDayStart', 'workDayEnd', 'workWeekStart', 'workWeekEnd', 'weekStart', 'slotDuration', 'slotDivisions',
            'editable', 'timezone', 'slotClass', 'slotFill', 'columnWidth', 'eventClass', 'eventStyles', 'isSlotSelected',
            'selectable', 'allDaySlot', 'showToolbar', 'showFooter'
        ], changes)) {
            this.notifyOptionsChange(changes);
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
        if (this.detachElementEventHandlers) {
            this.detachElementEventHandlers();
        }
    }
    /**
     * @hidden
     */
    onResize(_event) {
        this.viewContext.notifyResize();
    }
    /**
     * @hidden
     */
    onNavigationAction(action) {
        const args = new NavigateEvent(this, action);
        this.navigate.next(args);
        if (args.isDefaultPrevented()) {
            return true;
        }
        if (action.type === 'view-change') {
            const views = this.views.toArray();
            const index = views.indexOf(action.view);
            this.selectedView = action.view;
            this.setViewIndex(index);
        }
        else if (action.type === 'select-date') {
            if (this.isInRange(action.date)) {
                this.selectedDate = action.date;
            }
        }
        else if (action.type === 'today') {
            const date = new Date();
            if (this.isInRange(date)) {
                this.selectedDate = date;
            }
        }
        else if (action.type === 'toggle-business-hours') {
            this.viewState.toggleWorkHours.next(null);
        }
        else if (action.type === 'focus-toolbar') {
            this.focusService.focusToolbar();
        }
        else {
            this.viewContext.notifyAction(action);
        }
    }
    /**
     * @hidden
     */
    onToolbarWidthChange(width) {
        this.schedulerResize.emit(width);
    }
    /**
     * Creates a popup editor for the new event.
     *
     * @param group - The [`FormGroup`](https://angular.io/docs/ts/latest/api/forms/index/FormGroup-class.html) that describes
     * the edit form. If called with a data item, the parameter will build the `FormGroup` from the data item fields.
     */
    addEvent(group) {
        const isFormGroup = group instanceof FormGroup;
        if (!isFormGroup) {
            const createControl = (source) => (acc, key) => {
                acc[key] = new FormControl(source[key]);
                return acc;
            };
            const fields = Object.keys(group).reduce(createControl(group), {});
            group = new FormGroup(fields);
        }
        this.editService.addEvent(group);
    }
    /**
     * Switches the specified event in edit mode.
     *
     * @param dataItem - The event that will be switched to edit mode.
     * @param options - An object which contains the form `group` that will be bound in the edit dialog and the current edit `mode`.
     *
     */
    editEvent(dataItem, options = {}) {
        const { group, mode } = options;
        this.editService.editEvent(dataItem, group, mode);
    }
    /**
     * Closes the event editor, if open.
     */
    closeEvent() {
        this.editService.close();
    }
    /**
     * Returns a flag which indicates if an event is currently edited.
     *
     * @return {boolean} - A flag which indicates if an event is currently edited.
     */
    isEditing() {
        return this.editService.isEditing();
    }
    /**
     * Opens the built-in confirmation dialog for defining the edit mode
     * that will be used when the user edits or removes a recurring event.
     *
     * @param operation - The type of operation that will be confirmed. Has to be either **Edit** or **Remove**.
     *
     * @returns the result from the confirmation dialog.
     */
    openRecurringConfirmationDialog(operation) {
        return this.dialogsService.openRecurringConfirmationDialog(operation);
    }
    /**
     * Opens the built-in removal confirmation dialog.
     *
     * @return the result from the confirmation dialog.
     */
    openRemoveConfirmationDialog() {
        return this.dialogsService.openRemoveConfirmationDialog();
    }
    /**
     * Saves the current view as PDF.
     */
    saveAsPDF() {
        this.loadingComponent.toggle(true);
        this.zone.runOutsideAngular(() => {
            // wait a tick in order for the loading element style to be updated by the browser.
            // if the export is synchronous, the browser will not update the element before the export is finished.
            setTimeout(() => {
                this.pdfService.save();
            }, 0);
        });
    }
    /**
     * Scrolls the view to the specified time.
     */
    scrollToTime(time) {
        this.viewContext.notifyAction({
            type: 'scroll-time',
            time: time
        });
    }
    /**
     * Returns the current view slot that matches the passed document position.
     *
     * @param x - The x document position.
     * @param y - The y document position.
     *
     * @return {SchedulerSlot} - The slot.
     */
    slotByPosition(x, y) {
        return this.viewContext.executeMethod('slotByPosition', { x, y });
    }
    /**
     * Returns the event associated with the specified DOM element, if any.
     *
     * @param element - The DOM element document position.
     * @return the event instance, if found.
     */
    eventFromElement(element) {
        return this.viewContext.executeMethod('eventFromElement', { element });
    }
    /**
     * Gets the currently active event, if any.
     * The active event is the event that can currently receive focus.
     */
    get activeEvent() {
        const activeElement = this.focusService.activeElement;
        if (activeElement && activeElement.nativeElement.matches('.k-event, [data-task-index]')) {
            return this.eventFromElement(activeElement.nativeElement);
        }
    }
    /**
     * Focuses the next event or an event at a specified relative position.
     * The `options` parameter can be used to set a positive or negative offset
     * that is relative to the currently focused event ([see example](slug:keyboard_navigation_scheduler#toc-event-navigation-with-the-tab-key)).
     * A `nowrap` flag toggles the wrapping to the first or to the last item.
     *
     * @param position The relative position of the event to focus.
     * @returns `true` if the focused event changed. Otherwise, returns `false`.
     */
    focusNext(position) {
        const changed = this.focusService.focusNext(position);
        this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
        return changed;
    }
    /**
     * Focuses the previous event or an event at a specified relative position.
     * The `options` parameter can be used to set a positive or negative offset
     * that is relative to the currently focused event ([see example](slug:keyboard_navigation_scheduler#toc-event-navigation-with-the-tab-key)).
     * A `nowrap` flag toggles the wrapping to the first or to the last item.
     *
     * @param position The relative position of the event to focus.
     * @returns `true` if the focused event changed. Otherwise, returns `false`.
     */
    focusPrev(position) {
        const prevPosition = { offset: -1, ...position };
        const changed = this.focusService.focusNext(prevPosition);
        this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
        return changed;
    }
    /**
     * Focuses the last focused scheduler element or the Scheduler element, if no events are available.
     */
    focus() {
        this.zone.onStable.pipe(take(1)).subscribe(() => this.focusService.focus());
    }
    /**
     * @hidden
     */
    get toolbarVisibilityState() {
        return isPresent(this.viewToolbar) ? this.viewToolbar : this.showToolbar;
    }
    isInRange(date) {
        return (!this.min || this.min <= date) && (!this.max || date <= this.max);
    }
    notifyOptionsChange(changes) {
        const workweek = this.workWeek;
        this.viewContext.notifyOptionsChange({
            group: this.group,
            resources: this.resources,
            allDayEventTemplate: this.allDayEventTemplate ? this.allDayEventTemplate.first : null,
            eventTemplate: this.eventTemplate ? this.eventTemplate.first : null,
            timeSlotTemplate: this.timeSlotTemplate ? this.timeSlotTemplate.first : null,
            minorTimeHeaderTemplate: this.minorTimeHeaderTemplate ? this.minorTimeHeaderTemplate.first : null,
            majorTimeHeaderTemplate: this.majorTimeHeaderTemplate ? this.majorTimeHeaderTemplate.first : null,
            monthDaySlotTemplate: this.monthDaySlotTemplate ? this.monthDaySlotTemplate.first : null,
            multiWeekDaySlotTemplate: this.multiWeekDaySlotTemplate ? this.multiWeekDaySlotTemplate.first : null,
            dateHeaderTemplate: this.dateHeaderTemplate ? this.dateHeaderTemplate.first : null,
            allDaySlotTemplate: this.allDaySlotTemplate ? this.allDaySlotTemplate.first : null,
            groupHeaderTemplate: this.groupHeaderTemplate ? this.groupHeaderTemplate.first : null,
            agendaDateTemplate: this.agendaDateTemplate ? this.agendaDateTemplate.first : null,
            agendaTimeTemplate: this.agendaTimeTemplate ? this.agendaTimeTemplate.first : null,
            min: this.min,
            max: this.max,
            showWorkHours: this.showWorkHours,
            startTime: this.startTime,
            scrollTime: this.scrollTime,
            endTime: this.endTime,
            workDayStart: this.workDayStart,
            workDayEnd: this.workDayEnd,
            workWeekStart: workweek.start,
            workWeekEnd: workweek.end,
            weekStart: this.weekStart,
            allDaySlot: this.allDaySlot,
            slotDuration: this.slotDuration,
            slotDivisions: this.slotDivisions,
            eventHeight: this.eventHeight,
            editable: this.editable,
            selectable: this.selectable,
            timezone: this.timezone,
            currentTimeMarker: this.currentTimeMarker,
            highlightOngoingEvents: this.highlightOngoingEvents,
            showToolbar: this.showToolbar,
            showFooter: this.showFooter,
            slotClass: this.slotClass,
            slotFill: this.slotFill,
            columnWidth: this.columnWidth,
            eventClass: this.eventClass,
            eventStyles: this.eventStyles,
            isSlotSelected: this.isSlotSelected,
            changes: changes
        });
    }
    get workWeek() {
        const { start, end } = this.intlService.weekendRange();
        const workWeekStart = isPresent(this.workWeekStart) ? this.workWeekStart : (end + 1) % DAYS_IN_WEEK$1;
        const weekEnd = start > 0 ? start - 1 : Day.Saturday;
        const workWeekEnd = isPresent(this.workWeekEnd) ? this.workWeekEnd : weekEnd;
        return { start: workWeekStart, end: workWeekEnd };
    }
    resetViewIndex() {
        const index = this.selectedViewIndex;
        const newIndex = Math.max(0, Math.min(index, this.views.length - 1));
        this.setViewIndex(newIndex);
        this.onViewIndexChange();
    }
    onViewIndexChange() {
        if (!this.views) {
            return;
        }
        const views = this.views.toArray();
        const selectedView = views[this.viewIndex];
        if (selectedView) {
            this.selectedView = selectedView;
        }
    }
    setViewIndex(newIndex) {
        const changed = this.selectedViewIndex !== newIndex;
        if (changed) {
            this.selectedViewIndex = newIndex;
            this.selectedViewIndexChange.emit(newIndex);
        }
        return changed;
    }
    processEvents(dataItems) {
        const timezone = this.timezone;
        const fields = this.modelFields;
        const items = dataItems
            .map(dataItem => readEvent(dataItem, fields, this.resources))
            .filter(event => !isRecurrenceMaster$1(event))
            .map(event => {
            const start = ZonedDate.fromLocalDate(event.start, timezone);
            const end = ZonedDate.fromLocalDate(event.end, timezone);
            return { start, end, event };
        });
        this.viewItems = items;
        this.viewContext.notifyItems(items);
    }
    attachEditHandlers() {
        if (!this.editService) {
            return;
        }
        this.subs.add(this.editService.changes.subscribe(this.emitCRUDEvent.bind(this)));
    }
    emitCRUDEvent(args) {
        Object.assign(args, { sender: this });
        switch (args.action) {
            case 'cancel':
                this.cancel.emit(args);
                break;
            case 'save':
                this.save.emit(args);
                break;
            default: break;
        }
    }
    intlChange() {
        const currentView = this.selectedView;
        this.selectedView = null;
        if (!isPresent(this.workWeekStart) || !isPresent(this.workWeekEnd)) {
            this.notifyOptionsChange();
        }
        this.changeDetector.detectChanges();
        this.selectedView = currentView;
        if (NgZone.isInAngularZone()) {
            this.changeDetector.markForCheck();
        }
        else {
            this.changeDetector.detectChanges();
        }
    }
    attachElementEventHandlers() {
        if (!isDocumentAvailable()) {
            return;
        }
        const wrapper = this.wrapper.nativeElement;
        this.zone.runOutsideAngular(() => {
            const windowBlurSubscription = this.renderer.listen('window', 'blur', (args) => {
                this.domEvents.windowBlur.emit(args);
            });
            const clickSubscription = this.renderer.listen(wrapper, 'click', (args) => {
                this.domEvents.click.emit(args);
            });
            const keydownSubscription = this.renderer.listen(wrapper, 'keydown', args => {
                this.domEvents.keydown.emit(args);
            });
            let focused = false;
            const focusInSubscription = this.renderer.listen(wrapper, 'focusin', (args) => {
                this.domEvents.focus.emit(args);
                if (!focused) {
                    this.domEvents.focusIn.emit(args);
                    this.renderer.addClass(this.wrapper.nativeElement, 'k-focus');
                    focused = true;
                }
            });
            const focusOutSubscription = this.renderer.listen(wrapper, 'focusout', (args) => {
                const next = args.relatedTarget || document.activeElement;
                const outside = !closest(next, (node) => node === wrapper);
                if (outside) {
                    this.domEvents.focusOut.emit(args);
                    this.renderer.removeClass(this.wrapper.nativeElement, 'k-focus');
                    focused = false;
                }
            });
            this.detachElementEventHandlers = () => {
                windowBlurSubscription();
                clickSubscription();
                keydownSubscription();
                focusInSubscription();
                focusOutSubscription();
            };
        });
    }
}
SchedulerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerComponent, deps: [{ token: i0.ElementRef }, { token: ViewContextService }, { token: ViewStateService }, { token: EditService }, { token: DialogsService }, { token: i1$2.IntlService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: PDFService }, { token: i1$1.LocalizationService }, { token: DomEventsService }, { token: i0.Renderer2 }, { token: FocusService }], target: i0.ɵɵFactoryTarget.Component });
SchedulerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: SchedulerComponent, isStandalone: true, selector: "kendo-scheduler", inputs: { selectedViewIndex: "selectedViewIndex", editable: "editable", selectable: "selectable", min: "min", max: "max", eventHeight: "eventHeight", columnWidth: "columnWidth", showWorkHours: "showWorkHours", startTime: "startTime", endTime: "endTime", workDayStart: "workDayStart", workDayEnd: "workDayEnd", workWeekStart: "workWeekStart", workWeekEnd: "workWeekEnd", weekStart: "weekStart", slotDuration: "slotDuration", slotDivisions: "slotDivisions", slotFill: "slotFill", allDaySlot: "allDaySlot", scrollTime: "scrollTime", group: "group", resources: "resources", loading: "loading", timezone: "timezone", events: "events", selectedDate: "selectedDate", modelFields: "modelFields", currentTimeMarker: "currentTimeMarker", highlightOngoingEvents: "highlightOngoingEvents", showToolbar: "showToolbar", showFooter: "showFooter", slotClass: "slotClass", eventClass: "eventClass", eventStyles: "eventStyles", isSlotSelected: "isSlotSelected" }, outputs: { selectedViewIndexChange: "selectedViewIndexChange", navigate: "navigate", dateChange: "dateChange", slotClick: "slotClick", slotDblClick: "slotDblClick", create: "create", eventClick: "eventClick", eventDblClick: "eventDblClick", eventKeydown: "eventKeydown", cancel: "cancel", save: "save", remove: "remove", resizeStart: "resizeStart", resize: "resize", resizeEnd: "resizeEnd", dragStart: "dragStart", drag: "drag", dragEnd: "dragEnd", slotDragStart: "slotDragStart", slotDrag: "slotDrag", slotDragEnd: "slotDragEnd", pdfExport: "pdfExport", schedulerResize: "schedulerResize" }, host: { properties: { "class.k-scheduler": "this.hostClasses", "attr.role": "this.ariaRole", "class.k-rtl": "this.rtl", "attr.dir": "this.dir" } }, providers: [
        EditService,
        DialogsService,
        DomEventsService,
        LocalDataChangesService,
        FocusService,
        SchedulerLocalizationService,
        {
            provide: LocalizationService,
            useExisting: SchedulerLocalizationService
        },
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.scheduler'
        },
        ToolbarService,
        ViewContextService,
        ViewStateService,
        PDFService
    ], queries: [{ propertyName: "editDialogTemplate", first: true, predicate: EditDialogTemplateDirective, descendants: true }, { propertyName: "toolbarTemplate", first: true, predicate: ToolbarTemplateDirective, descendants: true }, { propertyName: "views", predicate: SchedulerView }, { propertyName: "allDayEventTemplate", predicate: AllDayEventTemplateDirective }, { propertyName: "eventTemplate", predicate: EventTemplateDirective }, { propertyName: "timeSlotTemplate", predicate: TimeSlotTemplateDirective }, { propertyName: "minorTimeHeaderTemplate", predicate: MinorTimeHeaderTemplateDirective }, { propertyName: "majorTimeHeaderTemplate", predicate: MajorTimeHeaderTemplateDirective }, { propertyName: "monthDaySlotTemplate", predicate: MonthDaySlotTemplateDirective }, { propertyName: "multiWeekDaySlotTemplate", predicate: MultiWeekDaySlotTemplateDirective }, { propertyName: "dateHeaderTemplate", predicate: DateHeaderTemplateDirective }, { propertyName: "allDaySlotTemplate", predicate: AllDaySlotTemplateDirective }, { propertyName: "groupHeaderTemplate", predicate: GroupHeaderTemplateDirective }, { propertyName: "agendaDateTemplate", predicate: AgendaDateTemplateDirective }, { propertyName: "agendaTimeTemplate", predicate: AgendaTimeTemplateDirective }], viewQueries: [{ propertyName: "resizeSensor", first: true, predicate: ResizeSensorComponent, descendants: true, static: true }, { propertyName: "confirmationDialogContainerRef", first: true, predicate: ["confirmationDialogContainer"], descendants: true, read: ViewContainerRef, static: true }, { propertyName: "loadingComponent", first: true, predicate: LoadingComponent, descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: `
        <ng-container kendoSchedulerLocalizedMessages
            i18n-allEvents="kendo.scheduler.allEvents|The All events text displayed in the timeline views when there is no vertical grouping."
            allEvents="All events"

            i18n-allDay="kendo.scheduler.allDay|The all day text displayed in the day and week views."
            allDay="all day"

            i18n-dateHeader="kendo.scheduler.dateHeader|The date header text displayed in the agenda view."
            dateHeader="Date"

            i18n-timeHeader="kendo.scheduler.timeHeader|The time header text displayed in the agenda view."
            timeHeader="Time"

            i18n-deleteTitle="kendo.scheduler.deleteTitle|The delete icon title."
            deleteTitle="Delete"

            i18n-eventHeader="kendo.scheduler.eventHeader|The event header text displayed in the agenda view."
            eventHeader="Event"

            i18n-nextTitle="kendo.scheduler.nextTitle|The title of the navigation next button."
            nextTitle="Next"

            i18n-previousTitle="kendo.scheduler.previousTitle|The title of the navigation previous button."
            previousTitle="Previous"

            i18n-showFullDay="kendo.scheduler.showFullDay|The text of the show full day button displayed in the footer of the day, week and timeline views."
            showFullDay="Show full day"

            i18n-showWorkDay="kendo.scheduler.showWorkDay|The text of the show work day button displayed in the footer of the day, week and timeline views."
            showWorkDay="Show business hours"

            i18n-today="kendo.scheduler.today|The today button text displayed in the navigation."
            today="Today"

            i18n-calendarToday="kendo.scheduler.calendarToday|The text of today's date in the header of the Calendar."
            calendarToday="TODAY"

            i18n-dayViewTitle="kendo.scheduler.dayViewTitle|The day view title."
            dayViewTitle="Day"

            i18n-multiDayViewTitle="kendo.scheduler.multiDayViewTitle|The multi day view title."
            multiDayViewTitle="Multi-Day"

            i18n-weekViewTitle="kendo.scheduler.weekViewTitle|The week view title."
            weekViewTitle="Week"

            i18n-workWeekViewTitle="kendo.scheduler.workWeekViewTitle|The work week view title."
            workWeekViewTitle="Work Week"

            i18n-monthViewTitle="kendo.scheduler.monthViewTitle|The month view title."
            monthViewTitle="Month"

            i18n-multiWeekViewTitle="kendo.scheduler.multiWeekViewTitle|The multi week view title."
            multiWeekViewTitle="Multi-Week"

            i18n-timelineViewTitle="kendo.scheduler.timelineViewTitle|The timeline view title."
            timelineViewTitle="Timeline"

            i18n-timelineWeekViewTitle="kendo.scheduler.timelineWeekViewTitle|The timeline week view title."
            timelineWeekViewTitle="Timeline Week"

            i18n-timelineMonthViewTitle="kendo.scheduler.timelineMonthViewTitle|The timeline month view title."
            timelineMonthViewTitle="Timeline Month"

            i18n-agendaViewTitle="kendo.scheduler.agendaViewTitle|The agenda view title."
            agendaViewTitle="Agenda"

            i18n-yearViewTitle="kendo.scheduler.yearViewTitle|The year view title."
            yearViewTitle="Year"

            i18n-yearViewNoEvents="kendo.scheduler.yearViewNoEvents|The year view no events message."
            yearViewNoEvents="No events on this date."

            i18n-cancel="kendo.scheduler.cancel|The text similar to 'Cancel' displayed in the Scheduler."
            cancel="Cancel"

            i18n-save="kendo.scheduler.save|The text similar to 'Save' displayed in the Scheduler."
            save="Save"

            i18n-editorEventTitle="kendo.scheduler.editorEventTitle|The text similar to 'Title' displayed in the Scheduler event editor."
            editorEventTitle='Title'

            i18n-editorEventStart="kendo.scheduler.editorEventStart|The text similar to 'Start' displayed in the Scheduler event editor."
            editorEventStart="Start"

            i18n-editorEventStartTimeZone="kendo.scheduler.editorEventStartTimeZone|The text similar to 'Start Time Zone' displayed in the Scheduler event editor."
            editorEventStartTimeZone="Start Time Zone"

            i18n-editorEventEnd="kendo.scheduler.editorEventEnd|The text similar to 'End' displayed in the Scheduler event editor."
            editorEventEnd="End"

            i18n-editorEventEndTimeZone="kendo.scheduler.editorEventEndTimeZone|The text similar to 'End Time Zone' displayed in the Scheduler event editor."
            editorEventEndTimeZone="End Time Zone"

            i18n-editorEventAllDay="kendo.scheduler.editorEventAllDay|The text similar to 'All Day event' displayed in the Scheduler event editor."
            editorEventAllDay="All Day Event"

            i18n-editorEventDescription="kendo.scheduler.editorEventDescription|The text similar to 'Description' displayed in the Scheduler event editor."
            editorEventDescription="Description"

            i18n-editorEventSeparateTimeZones="kendo.scheduler.editorEventSeparateTimeZones|The text similar to 'Use separate Start and End Time Zones' displayed in the Scheduler event editor."
            editorEventSeparateTimeZones="End in different Time Zone"

            i18n-editorEventTimeZone="kendo.scheduler.editorEventTimeZone|The text similar to 'Time Zone' displayed in the Scheduler event editor."
            editorEventTimeZone='Specify Time Zone'

            i18n-editorTitle="kendo.scheduler.editorTitle|The text similar to 'Event' displayed as title of the Scheduler event editor."
            editorTitle='Event'

            i18n-editorDateInputsToday="kendo.scheduler.editorDateInputsToday|The Today button text in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToday='Today'

            i18n-editorDateInputsToggle="kendo.scheduler.editorDateInputsToggle|The title of the Toggle button of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToggle='Toggle calendar'

            i18n-editorDateInputsParentViewButton="kendo.scheduler.editorDateInputsParentViewButton|The title of the Parent View button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsParentViewButton='Navigate to parent view'

            i18n-editorDateInputsNow="kendo.scheduler.editorDateInputsAccept|The text of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Now'

            i18n-editorDateInputsNowLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Select now'

            i18n-editorDateInputsAccept="kendo.scheduler.editorDateInputsAccept|The text of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Set'

            i18n-editorDateInputsAcceptLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Set'

            i18n-editorDateInputsCancel="kendo.scheduler.editorDateInputsCancel|The text of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancel='Cancel'

            i18n-editorDateInputsCancelLabel="kendo.scheduler.editorDateInputsCancelLabel|The label of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancelLabel='Cancel'

            i18n-editorDateInputsDateTab="kendo.scheduler.editorDateInputsDateTab|The text of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTab='Date'

            i18n-editorDateInputsDateTabLabel="kendo.scheduler.editorDateInputsDateTabLabel|The label of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTabLabel='Date tab'

            i18n-editorDateInputsTimeTab="kendo.scheduler.editorDateInputsTimeTab|The text of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTab='Time'

            i18n-editorDateInputsTimeTabLabel="kendo.scheduler.editorDateInputsTimeTabLabel|The label of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTabLabel='Time tab'

            i18n-recurrenceEditorDateInputsToday="kendo.scheduler.recurrenceEditorDateInputsToday|The Today button text in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToday='Today'

            i18n-recurrenceEditorDateInputsToggle="kendo.scheduler.recurrenceEditorDateInputsToggle|The title of the Toggle button of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToggle='Toggle calendar'

            i18n-recurrenceEditorDateInputsParentViewButton="kendo.scheduler.recurrenceEditorDateInputsParentViewButton|The title of the Parent View button in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsParentViewButton='Navigate to parent view'

            i18n-recurrenceEditorNumericIncrement="kendo.scheduler.recurrenceEditorNumericIncrement|The title of the Increment button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericIncrement='Increase value'

            i18n-recurrenceEditorNumericDecrement="kendo.scheduler.recurrenceEditorNumericDecrement|The title of the Decrement button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericDecrement='Decrease value'

            i18n-recurrenceEditorRepeat="kendo.scheduler.recurrenceEditorRepeat|The text similar to 'Repeat' displayed in the Scheduler recurrence editor."
            recurrenceEditorRepeat='Repeat'

            i18n-recurrenceEditorDailyInterval="kendo.scheduler.recurrenceEditorDailyInterval|The text similar to 'day(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyInterval='day(s)'

            i18n-recurrenceEditorDailyRepeatEvery="kendo.scheduler.recurrenceEditorDailyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyInterval="kendo.scheduler.recurrenceEditorWeeklyInterval|The text similar to 'week(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyInterval='week(s)'

            i18n-recurrenceEditorWeeklyRepeatEvery="kendo.scheduler.recurrenceEditorWeeklyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyRepeatOn="kendo.scheduler.recurrenceEditorWeeklyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatOn='Repeat on'

            i18n-recurrenceEditorMonthlyDay="kendo.scheduler.recurrenceEditorMonthlyDay|The text similar to 'Day' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyDay='Day'

            i18n-recurrenceEditorMonthlyInterval="kendo.scheduler.recurrenceEditorMonthlyInterval|The text similar to 'month(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyInterval='month(s)'

            i18n-recurrenceEditorMonthlyRepeatEvery="kendo.scheduler.recurrenceEditorMonthlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorMonthlyRepeatOn="kendo.scheduler.recurrenceEditorMonthlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyOf="kendo.scheduler.recurrenceEditorYearlyOf|The text similar to 'of' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyOf='of'

            i18n-recurrenceEditorYearlyRepeatEvery="kendo.scheduler.recurrenceEditorYearlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorYearlyRepeatOn="kendo.scheduler.recurrenceEditorYearlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyInterval="kendo.scheduler.recurrenceEditorYearlyInterval|The text similar to 'year(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyInterval='year(s)'

            i18n-recurrenceEditorFrequenciesDaily="kendo.scheduler.recurrenceEditorFrequenciesDaily|The text similar to 'Daily' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesDaily='Daily'

            i18n-recurrenceEditorFrequenciesMonthly="kendo.scheduler.recurrenceEditorFrequenciesMonthly|The text similar to 'Monthly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesMonthly='Monthly'

            i18n-recurrenceEditorFrequenciesNever="kendo.scheduler.recurrenceEditorFrequenciesNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesNever='Never'

            i18n-recurrenceEditorFrequenciesWeekly="kendo.scheduler.recurrenceEditorFrequenciesWeekly|The text similar to 'Weekly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesWeekly='Weekly'

            i18n-recurrenceEditorFrequenciesYearly="kendo.scheduler.recurrenceEditorFrequenciesYearly|The text similar to 'Yearly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesYearly='Yearly'

            i18n-recurrenceEditorOffsetPositionsFirst="kendo.scheduler.recurrenceEditorOffsetPositionsFirst|The text similar to 'First' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFirst='First'

            i18n-recurrenceEditorOffsetPositionsSecond="kendo.scheduler.recurrenceEditorOffsetPositionsSecond|The text similar to 'Second' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsSecond='Second'

            i18n-recurrenceEditorOffsetPositionsThird="kendo.scheduler.recurrenceEditorOffsetPositionsThird|The text similar to 'Third' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsThird='Third'

            i18n-recurrenceEditorOffsetPositionsFourth="kendo.scheduler.recurrenceEditorOffsetPositionsFourth|The text similar to 'Fourth' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFourth='Fourth'

            i18n-recurrenceEditorOffsetPositionsLast="kendo.scheduler.recurrenceEditorOffsetPositionsLast|The text similar to 'Last' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsLast='Last'

            i18n-recurrenceEditorWeekdaysDay="kendo.scheduler.recurrenceEditorWeekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysDay='Day'

            i18n-recurrenceEditorWeekdaysWeekday="kendo.scheduler.recurrenceEditorWeekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekday='Weekday'

            i18n-recurrenceEditorWeekdaysWeekendday="kendo.scheduler.recurrenceEditorWeekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekendday='Weekend Day'

            i18n-recurrenceEditorEndAfter="kendo.scheduler.recurrenceEditorEndAfter|The text similar to 'After' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndAfter='After'

            i18n-recurrenceEditorEndOccurrence="kendo.scheduler.recurrenceEditorEndOccurrence|The text similar to 'occurrence(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOccurrence='occurrence(s)'

            i18n-recurrenceEditorEndLabel="kendo.scheduler.recurrenceEditorEndLabel|The text similar to 'End' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndLabel='End'

            i18n-recurrenceEditorEndNever="kendo.scheduler.recurrenceEditorEndNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndNever='Never'

            i18n-recurrenceEditorEndOn="kendo.scheduler.recurrenceEditorEndOn|The text similar to 'On' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOn='On'

            i18n-destroy="kendo.scheduler.destroy|The text of the 'Delete' button displayed in the Scheduler remove confirmation dialog."
            destroy='Delete'

            i18n-deleteConfirmation="kendo.scheduler.deleteConfirmation|The text similar to 'Are you sure you want to delete this event?' displayed in Scheduler remove confirmation dialog."
            deleteConfirmation='Are you sure you want to delete this event?'

            i18n-editRecurringConfirmation="kendo.scheduler.editRecurringConfirmation|The text similar to 'Do you want to edit only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            editRecurringConfirmation='Do you want to edit only this event occurrence or the whole series?'

            i18n-editOccurrence="kendo.scheduler.editOccurrence|The text of the 'Edit current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            editOccurrence='Edit current occurrence'

            i18n-editSeries="kendo.scheduler.editSeries|The text of the 'Edit the series' button displayed in the Scheduler recurring confirmation dialog."
            editSeries='Edit the series'

            i18n-deleteRecurringConfirmation="kendo.scheduler.deleteRecurringConfirmation|The text similar to 'Do you want to delete only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            deleteRecurringConfirmation='Do you want to delete only this event occurrence or the whole series?'

            i18n-deleteOccurrence="kendo.scheduler.deleteOccurrence|The text of the 'Delete current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            deleteOccurrence='Delete current occurrence'

            i18n-deleteSeries="kendo.scheduler.deleteSeries|The text similar of the 'Delete the series' button displayed in the Scheduler recurring confirmation dialog."
            deleteSeries='Delete the series'

            i18n-deleteDialogTitle="kendo.scheduler.deleteDialogTitle|The title of the remove confirmation dialog, similar to 'Delete Event'."
            deleteDialogTitle='Delete Event'

            i18n-deleteRecurringDialogTitle="kendo.scheduler.deleteRecurringDialogTitle|The title of the recurring remove confirmation dialog, similar to 'Delete Recurring Item'"
            deleteRecurringDialogTitle='Delete Recurring Item'

            i18n-editRecurringDialogTitle="kendo.scheduler.editRecurringDialogTitle|The title of the recurring edit confirmation dialog, similar to 'Edit Recurring Item'"
            editRecurringDialogTitle='Edit Recurring Item'

            i18n-selectView="kendo.scheduler.selectView|The value of the aria-label attribute of the <select> element used for switching the Scheduler views."
            selectView='Select View'
        >
        </ng-container>

        <kendo-scheduler-toolbar
            *ngIf="toolbarVisibilityState"
            [dateRange]="dateRangeStream"
            [selectedDate]="selectedDateStream"
            [views]="$any(views)"
            [selectedView]="selectedView"
            [template]="toolbarTemplate"
            [min]="min"
            [max]="max"
            (navigate)="onNavigationAction($event)"
            (toolbarWidthChange)="onToolbarWidthChange($event)"
        ></kendo-scheduler-toolbar>

        <ng-container *ngTemplateOutlet="selectedView?.template">
        </ng-container>

        <ng-container #confirmationDialogContainer>
        </ng-container>

        <kendo-scheduler-edit-dialog
            [resources]="resources"
            [editTemplate]="editDialogTemplate"
            [timezone]="timezone"
            [weekStart]="weekStart"
            [fields]="modelFields"
        ></kendo-scheduler-edit-dialog>

        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>

        <div [loading]="loading" kendoSchedulerLoading>
        </div>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `, isInline: true, dependencies: [{ kind: "directive", type: LocalizedMessagesDirective, selector: "[kendoSchedulerLocalizedMessages]" }, { kind: "component", type: ToolbarComponent, selector: "kendo-scheduler-toolbar", inputs: ["selectedView", "views", "dateRange", "selectedDate", "template", "min", "max"], outputs: ["navigate", "toolbarWidthChange"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: EditDialogComponent, selector: "kendo-scheduler-edit-dialog", inputs: ["resources", "timezone", "weekStart", "fields", "editTemplate"] }, { kind: "component", type: ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { kind: "component", type: LoadingComponent, selector: "[kendoSchedulerLoading]", inputs: ["loading"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: WatermarkOverlayComponent, selector: "div[kendoWatermarkOverlay]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler',
                    providers: [
                        EditService,
                        DialogsService,
                        DomEventsService,
                        LocalDataChangesService,
                        FocusService,
                        SchedulerLocalizationService,
                        {
                            provide: LocalizationService,
                            useExisting: SchedulerLocalizationService
                        },
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.scheduler'
                        },
                        ToolbarService,
                        ViewContextService,
                        ViewStateService,
                        PDFService
                    ],
                    template: `
        <ng-container kendoSchedulerLocalizedMessages
            i18n-allEvents="kendo.scheduler.allEvents|The All events text displayed in the timeline views when there is no vertical grouping."
            allEvents="All events"

            i18n-allDay="kendo.scheduler.allDay|The all day text displayed in the day and week views."
            allDay="all day"

            i18n-dateHeader="kendo.scheduler.dateHeader|The date header text displayed in the agenda view."
            dateHeader="Date"

            i18n-timeHeader="kendo.scheduler.timeHeader|The time header text displayed in the agenda view."
            timeHeader="Time"

            i18n-deleteTitle="kendo.scheduler.deleteTitle|The delete icon title."
            deleteTitle="Delete"

            i18n-eventHeader="kendo.scheduler.eventHeader|The event header text displayed in the agenda view."
            eventHeader="Event"

            i18n-nextTitle="kendo.scheduler.nextTitle|The title of the navigation next button."
            nextTitle="Next"

            i18n-previousTitle="kendo.scheduler.previousTitle|The title of the navigation previous button."
            previousTitle="Previous"

            i18n-showFullDay="kendo.scheduler.showFullDay|The text of the show full day button displayed in the footer of the day, week and timeline views."
            showFullDay="Show full day"

            i18n-showWorkDay="kendo.scheduler.showWorkDay|The text of the show work day button displayed in the footer of the day, week and timeline views."
            showWorkDay="Show business hours"

            i18n-today="kendo.scheduler.today|The today button text displayed in the navigation."
            today="Today"

            i18n-calendarToday="kendo.scheduler.calendarToday|The text of today's date in the header of the Calendar."
            calendarToday="TODAY"

            i18n-dayViewTitle="kendo.scheduler.dayViewTitle|The day view title."
            dayViewTitle="Day"

            i18n-multiDayViewTitle="kendo.scheduler.multiDayViewTitle|The multi day view title."
            multiDayViewTitle="Multi-Day"

            i18n-weekViewTitle="kendo.scheduler.weekViewTitle|The week view title."
            weekViewTitle="Week"

            i18n-workWeekViewTitle="kendo.scheduler.workWeekViewTitle|The work week view title."
            workWeekViewTitle="Work Week"

            i18n-monthViewTitle="kendo.scheduler.monthViewTitle|The month view title."
            monthViewTitle="Month"

            i18n-multiWeekViewTitle="kendo.scheduler.multiWeekViewTitle|The multi week view title."
            multiWeekViewTitle="Multi-Week"

            i18n-timelineViewTitle="kendo.scheduler.timelineViewTitle|The timeline view title."
            timelineViewTitle="Timeline"

            i18n-timelineWeekViewTitle="kendo.scheduler.timelineWeekViewTitle|The timeline week view title."
            timelineWeekViewTitle="Timeline Week"

            i18n-timelineMonthViewTitle="kendo.scheduler.timelineMonthViewTitle|The timeline month view title."
            timelineMonthViewTitle="Timeline Month"

            i18n-agendaViewTitle="kendo.scheduler.agendaViewTitle|The agenda view title."
            agendaViewTitle="Agenda"

            i18n-yearViewTitle="kendo.scheduler.yearViewTitle|The year view title."
            yearViewTitle="Year"

            i18n-yearViewNoEvents="kendo.scheduler.yearViewNoEvents|The year view no events message."
            yearViewNoEvents="No events on this date."

            i18n-cancel="kendo.scheduler.cancel|The text similar to 'Cancel' displayed in the Scheduler."
            cancel="Cancel"

            i18n-save="kendo.scheduler.save|The text similar to 'Save' displayed in the Scheduler."
            save="Save"

            i18n-editorEventTitle="kendo.scheduler.editorEventTitle|The text similar to 'Title' displayed in the Scheduler event editor."
            editorEventTitle='Title'

            i18n-editorEventStart="kendo.scheduler.editorEventStart|The text similar to 'Start' displayed in the Scheduler event editor."
            editorEventStart="Start"

            i18n-editorEventStartTimeZone="kendo.scheduler.editorEventStartTimeZone|The text similar to 'Start Time Zone' displayed in the Scheduler event editor."
            editorEventStartTimeZone="Start Time Zone"

            i18n-editorEventEnd="kendo.scheduler.editorEventEnd|The text similar to 'End' displayed in the Scheduler event editor."
            editorEventEnd="End"

            i18n-editorEventEndTimeZone="kendo.scheduler.editorEventEndTimeZone|The text similar to 'End Time Zone' displayed in the Scheduler event editor."
            editorEventEndTimeZone="End Time Zone"

            i18n-editorEventAllDay="kendo.scheduler.editorEventAllDay|The text similar to 'All Day event' displayed in the Scheduler event editor."
            editorEventAllDay="All Day Event"

            i18n-editorEventDescription="kendo.scheduler.editorEventDescription|The text similar to 'Description' displayed in the Scheduler event editor."
            editorEventDescription="Description"

            i18n-editorEventSeparateTimeZones="kendo.scheduler.editorEventSeparateTimeZones|The text similar to 'Use separate Start and End Time Zones' displayed in the Scheduler event editor."
            editorEventSeparateTimeZones="End in different Time Zone"

            i18n-editorEventTimeZone="kendo.scheduler.editorEventTimeZone|The text similar to 'Time Zone' displayed in the Scheduler event editor."
            editorEventTimeZone='Specify Time Zone'

            i18n-editorTitle="kendo.scheduler.editorTitle|The text similar to 'Event' displayed as title of the Scheduler event editor."
            editorTitle='Event'

            i18n-editorDateInputsToday="kendo.scheduler.editorDateInputsToday|The Today button text in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToday='Today'

            i18n-editorDateInputsToggle="kendo.scheduler.editorDateInputsToggle|The title of the Toggle button of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsToggle='Toggle calendar'

            i18n-editorDateInputsParentViewButton="kendo.scheduler.editorDateInputsParentViewButton|The title of the Parent View button in the popup of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsParentViewButton='Navigate to parent view'

            i18n-editorDateInputsNow="kendo.scheduler.editorDateInputsAccept|The text of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Now'

            i18n-editorDateInputsNowLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Now button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Select now'

            i18n-editorDateInputsAccept="kendo.scheduler.editorDateInputsAccept|The text of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAccept='Set'

            i18n-editorDateInputsAcceptLabel="kendo.scheduler.editorDateInputsAcceptLabel|The label of the Accept button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsAcceptLabel='Set'

            i18n-editorDateInputsCancel="kendo.scheduler.editorDateInputsCancel|The text of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancel='Cancel'

            i18n-editorDateInputsCancelLabel="kendo.scheduler.editorDateInputsCancelLabel|The label of the Cancel button in the popup footer of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsCancelLabel='Cancel'

            i18n-editorDateInputsDateTab="kendo.scheduler.editorDateInputsDateTab|The text of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTab='Date'

            i18n-editorDateInputsDateTabLabel="kendo.scheduler.editorDateInputsDateTabLabel|The label of the Date tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsDateTabLabel='Date tab'

            i18n-editorDateInputsTimeTab="kendo.scheduler.editorDateInputsTimeTab|The text of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTab='Time'

            i18n-editorDateInputsTimeTabLabel="kendo.scheduler.editorDateInputsTimeTabLabel|The label of the Time tab in the popup header of the DateTimePickers and DatePickers in the Scheduler event editor."
            editorDateInputsTimeTabLabel='Time tab'

            i18n-recurrenceEditorDateInputsToday="kendo.scheduler.recurrenceEditorDateInputsToday|The Today button text in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToday='Today'

            i18n-recurrenceEditorDateInputsToggle="kendo.scheduler.recurrenceEditorDateInputsToggle|The title of the Toggle button of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsToggle='Toggle calendar'

            i18n-recurrenceEditorDateInputsParentViewButton="kendo.scheduler.recurrenceEditorDateInputsParentViewButton|The title of the Parent View button in the popup of the DatePickers in the Scheduler recurrence editor."
            recurrenceEditorDateInputsParentViewButton='Navigate to parent view'

            i18n-recurrenceEditorNumericIncrement="kendo.scheduler.recurrenceEditorNumericIncrement|The title of the Increment button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericIncrement='Increase value'

            i18n-recurrenceEditorNumericDecrement="kendo.scheduler.recurrenceEditorNumericDecrement|The title of the Decrement button of the NumericTextBox in the Scheduler recurrence editor."
            recurrenceEditorNumericDecrement='Decrease value'

            i18n-recurrenceEditorRepeat="kendo.scheduler.recurrenceEditorRepeat|The text similar to 'Repeat' displayed in the Scheduler recurrence editor."
            recurrenceEditorRepeat='Repeat'

            i18n-recurrenceEditorDailyInterval="kendo.scheduler.recurrenceEditorDailyInterval|The text similar to 'day(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyInterval='day(s)'

            i18n-recurrenceEditorDailyRepeatEvery="kendo.scheduler.recurrenceEditorDailyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorDailyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyInterval="kendo.scheduler.recurrenceEditorWeeklyInterval|The text similar to 'week(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyInterval='week(s)'

            i18n-recurrenceEditorWeeklyRepeatEvery="kendo.scheduler.recurrenceEditorWeeklyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatEvery='Repeat every'

            i18n-recurrenceEditorWeeklyRepeatOn="kendo.scheduler.recurrenceEditorWeeklyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorWeeklyRepeatOn='Repeat on'

            i18n-recurrenceEditorMonthlyDay="kendo.scheduler.recurrenceEditorMonthlyDay|The text similar to 'Day' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyDay='Day'

            i18n-recurrenceEditorMonthlyInterval="kendo.scheduler.recurrenceEditorMonthlyInterval|The text similar to 'month(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyInterval='month(s)'

            i18n-recurrenceEditorMonthlyRepeatEvery="kendo.scheduler.recurrenceEditorMonthlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorMonthlyRepeatOn="kendo.scheduler.recurrenceEditorMonthlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorMonthlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyOf="kendo.scheduler.recurrenceEditorYearlyOf|The text similar to 'of' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyOf='of'

            i18n-recurrenceEditorYearlyRepeatEvery="kendo.scheduler.recurrenceEditorYearlyRepeatEvery|The text similar to 'Repeat every' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatEvery='Repeat every'

            i18n-recurrenceEditorYearlyRepeatOn="kendo.scheduler.recurrenceEditorYearlyRepeatOn|The text similar to 'Repeat on' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyRepeatOn='Repeat on'

            i18n-recurrenceEditorYearlyInterval="kendo.scheduler.recurrenceEditorYearlyInterval|The text similar to 'year(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorYearlyInterval='year(s)'

            i18n-recurrenceEditorFrequenciesDaily="kendo.scheduler.recurrenceEditorFrequenciesDaily|The text similar to 'Daily' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesDaily='Daily'

            i18n-recurrenceEditorFrequenciesMonthly="kendo.scheduler.recurrenceEditorFrequenciesMonthly|The text similar to 'Monthly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesMonthly='Monthly'

            i18n-recurrenceEditorFrequenciesNever="kendo.scheduler.recurrenceEditorFrequenciesNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesNever='Never'

            i18n-recurrenceEditorFrequenciesWeekly="kendo.scheduler.recurrenceEditorFrequenciesWeekly|The text similar to 'Weekly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesWeekly='Weekly'

            i18n-recurrenceEditorFrequenciesYearly="kendo.scheduler.recurrenceEditorFrequenciesYearly|The text similar to 'Yearly' displayed in the Scheduler recurrence editor."
            recurrenceEditorFrequenciesYearly='Yearly'

            i18n-recurrenceEditorOffsetPositionsFirst="kendo.scheduler.recurrenceEditorOffsetPositionsFirst|The text similar to 'First' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFirst='First'

            i18n-recurrenceEditorOffsetPositionsSecond="kendo.scheduler.recurrenceEditorOffsetPositionsSecond|The text similar to 'Second' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsSecond='Second'

            i18n-recurrenceEditorOffsetPositionsThird="kendo.scheduler.recurrenceEditorOffsetPositionsThird|The text similar to 'Third' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsThird='Third'

            i18n-recurrenceEditorOffsetPositionsFourth="kendo.scheduler.recurrenceEditorOffsetPositionsFourth|The text similar to 'Fourth' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsFourth='Fourth'

            i18n-recurrenceEditorOffsetPositionsLast="kendo.scheduler.recurrenceEditorOffsetPositionsLast|The text similar to 'Last' displayed in the Scheduler recurrence editor."
            recurrenceEditorOffsetPositionsLast='Last'

            i18n-recurrenceEditorWeekdaysDay="kendo.scheduler.recurrenceEditorWeekdaysDay|The text similar to 'Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysDay='Day'

            i18n-recurrenceEditorWeekdaysWeekday="kendo.scheduler.recurrenceEditorWeekdaysWeekday|The text similar to 'Weekday' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekday='Weekday'

            i18n-recurrenceEditorWeekdaysWeekendday="kendo.scheduler.recurrenceEditorWeekdaysWeekendday|The text similar to 'Weekend Day' displayed in the repeat by section of the monthly recurrence pattern."
            recurrenceEditorWeekdaysWeekendday='Weekend Day'

            i18n-recurrenceEditorEndAfter="kendo.scheduler.recurrenceEditorEndAfter|The text similar to 'After' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndAfter='After'

            i18n-recurrenceEditorEndOccurrence="kendo.scheduler.recurrenceEditorEndOccurrence|The text similar to 'occurrence(s)' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOccurrence='occurrence(s)'

            i18n-recurrenceEditorEndLabel="kendo.scheduler.recurrenceEditorEndLabel|The text similar to 'End' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndLabel='End'

            i18n-recurrenceEditorEndNever="kendo.scheduler.recurrenceEditorEndNever|The text similar to 'Never' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndNever='Never'

            i18n-recurrenceEditorEndOn="kendo.scheduler.recurrenceEditorEndOn|The text similar to 'On' displayed in the Scheduler recurrence editor."
            recurrenceEditorEndOn='On'

            i18n-destroy="kendo.scheduler.destroy|The text of the 'Delete' button displayed in the Scheduler remove confirmation dialog."
            destroy='Delete'

            i18n-deleteConfirmation="kendo.scheduler.deleteConfirmation|The text similar to 'Are you sure you want to delete this event?' displayed in Scheduler remove confirmation dialog."
            deleteConfirmation='Are you sure you want to delete this event?'

            i18n-editRecurringConfirmation="kendo.scheduler.editRecurringConfirmation|The text similar to 'Do you want to edit only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            editRecurringConfirmation='Do you want to edit only this event occurrence or the whole series?'

            i18n-editOccurrence="kendo.scheduler.editOccurrence|The text of the 'Edit current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            editOccurrence='Edit current occurrence'

            i18n-editSeries="kendo.scheduler.editSeries|The text of the 'Edit the series' button displayed in the Scheduler recurring confirmation dialog."
            editSeries='Edit the series'

            i18n-deleteRecurringConfirmation="kendo.scheduler.deleteRecurringConfirmation|The text similar to 'Do you want to delete only this event occurrence or the whole series?' displayed in the Scheduler recurring confirmation dialog."
            deleteRecurringConfirmation='Do you want to delete only this event occurrence or the whole series?'

            i18n-deleteOccurrence="kendo.scheduler.deleteOccurrence|The text of the 'Delete current occurrence' button displayed in the Scheduler recurring confirmation dialog."
            deleteOccurrence='Delete current occurrence'

            i18n-deleteSeries="kendo.scheduler.deleteSeries|The text similar of the 'Delete the series' button displayed in the Scheduler recurring confirmation dialog."
            deleteSeries='Delete the series'

            i18n-deleteDialogTitle="kendo.scheduler.deleteDialogTitle|The title of the remove confirmation dialog, similar to 'Delete Event'."
            deleteDialogTitle='Delete Event'

            i18n-deleteRecurringDialogTitle="kendo.scheduler.deleteRecurringDialogTitle|The title of the recurring remove confirmation dialog, similar to 'Delete Recurring Item'"
            deleteRecurringDialogTitle='Delete Recurring Item'

            i18n-editRecurringDialogTitle="kendo.scheduler.editRecurringDialogTitle|The title of the recurring edit confirmation dialog, similar to 'Edit Recurring Item'"
            editRecurringDialogTitle='Edit Recurring Item'

            i18n-selectView="kendo.scheduler.selectView|The value of the aria-label attribute of the <select> element used for switching the Scheduler views."
            selectView='Select View'
        >
        </ng-container>

        <kendo-scheduler-toolbar
            *ngIf="toolbarVisibilityState"
            [dateRange]="dateRangeStream"
            [selectedDate]="selectedDateStream"
            [views]="$any(views)"
            [selectedView]="selectedView"
            [template]="toolbarTemplate"
            [min]="min"
            [max]="max"
            (navigate)="onNavigationAction($event)"
            (toolbarWidthChange)="onToolbarWidthChange($event)"
        ></kendo-scheduler-toolbar>

        <ng-container *ngTemplateOutlet="selectedView?.template">
        </ng-container>

        <ng-container #confirmationDialogContainer>
        </ng-container>

        <kendo-scheduler-edit-dialog
            [resources]="resources"
            [editTemplate]="editDialogTemplate"
            [timezone]="timezone"
            [weekStart]="weekStart"
            [fields]="modelFields"
        ></kendo-scheduler-edit-dialog>

        <kendo-resize-sensor (resize)="onResize()"></kendo-resize-sensor>

        <div [loading]="loading" kendoSchedulerLoading>
        </div>

        <div kendoWatermarkOverlay *ngIf="showLicenseWatermark"></div>
    `,
                    standalone: true,
                    imports: [LocalizedMessagesDirective, ToolbarComponent, NgTemplateOutlet, EditDialogComponent, ResizeSensorComponent, LoadingComponent, NgIf, WatermarkOverlayComponent]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: ViewContextService }, { type: ViewStateService }, { type: EditService }, { type: DialogsService }, { type: i1$2.IntlService }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: PDFService }, { type: i1$1.LocalizationService }, { type: DomEventsService }, { type: i0.Renderer2 }, { type: FocusService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-scheduler']
            }], ariaRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], rtl: [{
                type: HostBinding,
                args: ['class.k-rtl']
            }], dir: [{
                type: HostBinding,
                args: ['attr.dir']
            }], selectedViewIndex: [{
                type: Input
            }], editable: [{
                type: Input
            }], selectable: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], columnWidth: [{
                type: Input
            }], showWorkHours: [{
                type: Input
            }], startTime: [{
                type: Input
            }], endTime: [{
                type: Input
            }], workDayStart: [{
                type: Input
            }], workDayEnd: [{
                type: Input
            }], workWeekStart: [{
                type: Input
            }], workWeekEnd: [{
                type: Input
            }], weekStart: [{
                type: Input
            }], slotDuration: [{
                type: Input
            }], slotDivisions: [{
                type: Input
            }], slotFill: [{
                type: Input
            }], allDaySlot: [{
                type: Input
            }], scrollTime: [{
                type: Input
            }], group: [{
                type: Input
            }], resources: [{
                type: Input
            }], loading: [{
                type: Input
            }], timezone: [{
                type: Input
            }], events: [{
                type: Input
            }], selectedDate: [{
                type: Input
            }], modelFields: [{
                type: Input
            }], currentTimeMarker: [{
                type: Input
            }], highlightOngoingEvents: [{
                type: Input
            }], showToolbar: [{
                type: Input
            }], showFooter: [{
                type: Input
            }], slotClass: [{
                type: Input
            }], eventClass: [{
                type: Input
            }], eventStyles: [{
                type: Input
            }], isSlotSelected: [{
                type: Input
            }], selectedViewIndexChange: [{
                type: Output
            }], navigate: [{
                type: Output
            }], dateChange: [{
                type: Output
            }], slotClick: [{
                type: Output
            }], slotDblClick: [{
                type: Output
            }], create: [{
                type: Output
            }], eventClick: [{
                type: Output
            }], eventDblClick: [{
                type: Output
            }], eventKeydown: [{
                type: Output
            }], cancel: [{
                type: Output
            }], save: [{
                type: Output
            }], remove: [{
                type: Output
            }], resizeStart: [{
                type: Output
            }], resize: [{
                type: Output
            }], resizeEnd: [{
                type: Output
            }], dragStart: [{
                type: Output
            }], drag: [{
                type: Output
            }], dragEnd: [{
                type: Output
            }], slotDragStart: [{
                type: Output
            }], slotDrag: [{
                type: Output
            }], slotDragEnd: [{
                type: Output
            }], pdfExport: [{
                type: Output
            }], schedulerResize: [{
                type: Output
            }], editDialogTemplate: [{
                type: ContentChild,
                args: [EditDialogTemplateDirective, { static: false }]
            }], toolbarTemplate: [{
                type: ContentChild,
                args: [ToolbarTemplateDirective, { static: false }]
            }], views: [{
                type: ContentChildren,
                args: [SchedulerView]
            }], resizeSensor: [{
                type: ViewChild,
                args: [ResizeSensorComponent, { static: true }]
            }], confirmationDialogContainerRef: [{
                type: ViewChild,
                args: ["confirmationDialogContainer", { read: ViewContainerRef, static: true }]
            }], loadingComponent: [{
                type: ViewChild,
                args: [LoadingComponent, { static: true }]
            }], allDayEventTemplate: [{
                type: ContentChildren,
                args: [AllDayEventTemplateDirective]
            }], eventTemplate: [{
                type: ContentChildren,
                args: [EventTemplateDirective]
            }], timeSlotTemplate: [{
                type: ContentChildren,
                args: [TimeSlotTemplateDirective]
            }], minorTimeHeaderTemplate: [{
                type: ContentChildren,
                args: [MinorTimeHeaderTemplateDirective]
            }], majorTimeHeaderTemplate: [{
                type: ContentChildren,
                args: [MajorTimeHeaderTemplateDirective]
            }], monthDaySlotTemplate: [{
                type: ContentChildren,
                args: [MonthDaySlotTemplateDirective]
            }], multiWeekDaySlotTemplate: [{
                type: ContentChildren,
                args: [MultiWeekDaySlotTemplateDirective]
            }], dateHeaderTemplate: [{
                type: ContentChildren,
                args: [DateHeaderTemplateDirective]
            }], allDaySlotTemplate: [{
                type: ContentChildren,
                args: [AllDaySlotTemplateDirective]
            }], groupHeaderTemplate: [{
                type: ContentChildren,
                args: [GroupHeaderTemplateDirective]
            }], agendaDateTemplate: [{
                type: ContentChildren,
                args: [AgendaDateTemplateDirective]
            }], agendaTimeTemplate: [{
                type: ContentChildren,
                args: [AgendaTimeTemplateDirective]
            }] } });

// TODO
// Extract as public method
const occurrences = (item, fields, range, timezone, weekStart) => {
    const rrule = parseRule({
        recurrenceRule: getField(item, fields.recurrenceRule),
        weekStart: weekStart
    });
    if (!rrule.start) {
        const start = getField(item, fields.start);
        rrule.start = ZonedDate.fromLocalDate(start, timezone);
    }
    if (!rrule.end) {
        const end = getField(item, fields.end);
        rrule.end = ZonedDate.fromLocalDate(end, timezone);
    }
    const exceptions = getField(item, fields.recurrenceExceptions);
    if (exceptions) {
        rrule.exceptionDates = exceptions
            .map(exDate => ZonedDate.fromLocalDate(exDate, timezone));
        // TODO: Merge exceptions from recurrence rule with event.recurrenceException
    }
    const utcRangeStart = toUTCDateTime(range.start);
    const utcRangeEnd = toUTCDateTime(range.end);
    const series = expand(rrule, {
        rangeStart: ZonedDate.fromUTCDate(utcRangeStart, timezone),
        rangeEnd: ZonedDate.fromUTCDate(utcRangeEnd, timezone)
    });
    if (!series.events.length) {
        return [];
    }
    const expanded = series.events.map(occ => {
        const event = clone(item);
        setField(event, fields.id, OCCURRENCE_ID);
        setField(event, fields.recurrenceId, getField(item, fields.id));
        setField(event, fields.start, occ.start.toLocalDate());
        setField(event, fields.end, occ.end.toLocalDate());
        return event;
    });
    return [item, ...expanded];
};
/**
 * A directive that processes Scheduler events in-memory ([see example](slug:databinding_scheduler#toc-using-the-built-in-directive)).
 *
 * Processing includes the expanding of recurring events and the filtering of data for
 * the currently active period.
 */
class DataBindingDirective {
    constructor(scheduler, changeDetector, intl, localDataChangesService) {
        this.scheduler = scheduler;
        this.changeDetector = changeDetector;
        this.intl = intl;
        this.localDataChangesService = localDataChangesService;
        this.originalData = [];
        if (localDataChangesService) {
            this.dataChangedSubscription = this.localDataChangesService.changes.subscribe(this.rebind.bind(this));
        }
    }
    /**
     * The array of data which will populate the Scheduler.
     */
    set data(value) {
        this.originalData = value || [];
        if (this.localDataChangesService) {
            this.localDataChangesService.data = value;
        }
        this.scheduler.events = this.process();
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscription = this.scheduler
            .dateChange
            .subscribe(e => this.onDateChange(e));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.dataChangedSubscription) {
            this.dataChangedSubscription.unsubscribe();
        }
    }
    /**
     * @hidden
     */
    rebind() {
        this.data = this.originalData;
        this.changeDetector.markForCheck();
    }
    process() {
        if (!this.dateRange) {
            // No processing until a date range is set
            return [];
        }
        const data = [];
        const fields = this.scheduler.modelFields;
        this.originalData
            .forEach(item => {
            if (getField(item, fields.recurrenceRule)) {
                const series = occurrences(item, fields, this.dateRange, this.scheduler.timezone, this.scheduler.weekStart);
                data.push(...series);
            }
            else {
                data.push(item);
            }
        });
        return data;
    }
    onDateChange(e) {
        this.dateRange = e.dateRange;
        this.rebind();
    }
}
DataBindingDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DataBindingDirective, deps: [{ token: SchedulerComponent }, { token: i0.ChangeDetectorRef }, { token: i1$2.IntlService }, { token: LocalDataChangesService }], target: i0.ɵɵFactoryTarget.Directive });
DataBindingDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: DataBindingDirective, isStandalone: true, selector: "[kendoSchedulerBinding]", inputs: { data: ["kendoSchedulerBinding", "data"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DataBindingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerBinding]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SchedulerComponent }, { type: i0.ChangeDetectorRef }, { type: i1$2.IntlService }, { type: LocalDataChangesService }]; }, propDecorators: { data: [{
                type: Input,
                args: ['kendoSchedulerBinding']
            }] } });

/**
 * Custom component messages override default component messages.
 */
class SchedulerCustomMessagesComponent extends Messages {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
SchedulerCustomMessagesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerCustomMessagesComponent, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
SchedulerCustomMessagesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: SchedulerCustomMessagesComponent, isStandalone: true, selector: "kendo-scheduler-messages", providers: [
        {
            provide: Messages,
            useExisting: forwardRef(() => SchedulerCustomMessagesComponent)
        }
    ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages,
                            useExisting: forwardRef(() => SchedulerCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-scheduler-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }]; } });

/**
 * Represents the `export-to-PDF` command of the Scheduler.
 * You can apply this directive to any `button` element inside a
 * [`ToolbarTemplate`]({% slug toolbar_scheduler %}).
 * When the user clicks a button that is associated with the directive, the
 * [`pdfExport`]({% slug api_scheduler_schedulercomponent %}#toc-pdfexport) event
 * fires ([see example]({% slug pdfexport_scheduler %})).
 *
 * ```html
 * <kendo-scheduler>
 *      <ng-template kendoSchedulerToolbarTemplate>
 *          <button kendoSchedulerPDFCommand>Export PDF</button>
 *      </ng-template>
 *      <kendo-scheduler-pdf fileName="Scheduler.pdf">
 *      </kendo-scheduler-pdf>
 * </kendo-scheduler>
 * ```
 */
class PDFCommandDirective extends Button {
    constructor(pdfService, element, renderer, localization, ngZone) {
        super(element, renderer, null, localization, ngZone);
        this.pdfService = pdfService;
    }
    /**
     * @hidden
     */
    onClick(e) {
        e.preventDefault();
        this.pdfService.exportClick.emit();
    }
    ngOnInit() {
        this.icon = 'pdf';
        this.svgIcon = filePdfIcon;
    }
}
PDFCommandDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFCommandDirective, deps: [{ token: PDFService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i1$1.LocalizationService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
PDFCommandDirective.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: PDFCommandDirective, isStandalone: true, selector: "[kendoSchedulerPDFCommand]", host: { listeners: { "click": "onClick($event)" } }, usesInheritance: true, ngImport: i0, template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFCommandDirective, decorators: [{
            type: Component,
            args: [{
                    selector: '[kendoSchedulerPDFCommand]',
                    template: `
        <kendo-icon-wrapper
            *ngIf="icon || svgIcon"
            innerCssClass="k-button-icon"
            [name]="icon"
            [svgIcon]="svgIcon"></kendo-icon-wrapper>
        <span *ngIf="imageUrl" class="k-button-icon k-icon">
            <img [src]="imageUrl" class="k-image" role="presentation" />
        </span>
        <span *ngIf="iconClass" class="k-button-icon" [ngClass]="iconClass"></span>
        <span class="k-button-text"><ng-content></ng-content></span>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgClass]
                }]
        }], ctorParameters: function () { return [{ type: PDFService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i1$1.LocalizationService }, { type: i0.NgZone }]; }, propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

const createElement = (tagName, className) => {
    const element = document.createElement(tagName);
    if (className) {
        element.className = className;
    }
    return element;
};
const createDiv = (className) => createElement('div', className);
/**
 * Configures the settings for the export of Scheduler in PDF ([see example]({% slug pdfexport_scheduler %})).
 */
class PDFComponent {
    constructor(pdfService, ngZone) {
        this.pdfService = pdfService;
        this.ngZone = ngZone;
        /**
         * The creator of the PDF document.
         * @default 'Kendo UI PDF Generator'
         */
        this.creator = 'Kendo UI PDF Generator';
        this.subscriptions = this.pdfService.elementReady.subscribe(this.createElement.bind(this));
        this.saveDataUri = this.saveDataUri.bind(this);
        this.exportGroup = this.exportGroup.bind(this);
        this.done = this.done.bind(this);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    get drawOptions() {
        return {
            _destructive: true,
            avoidLinks: this.avoidLinks,
            margin: this.margin,
            scale: this.scale
        };
    }
    get pdfOptions() {
        return {
            author: this.author,
            creator: this.creator,
            date: this.date,
            imgDPI: this.imageResolution,
            keywords: this.keywords,
            margin: this.margin,
            producer: this.producer,
            subject: this.subject,
            title: this.title
        };
    }
    get saveOptions() {
        return {
            forceProxy: this.forceProxy,
            proxyData: this.proxyData,
            proxyTarget: this.proxyTarget,
            proxyURL: this.proxyURL
        };
    }
    createElement(args) {
        this.ngZone.runOutsideAngular(() => {
            const container = this.container = createDiv();
            container.style.top = container.style.left = '-10000px';
            container.style.position = 'absolute';
            const wrapper = createDiv('k-scheduler');
            wrapper.style.position = 'relative';
            wrapper.appendChild(args.element);
            container.appendChild(wrapper);
            document.body.appendChild(container);
            this.save(wrapper);
        });
    }
    save(element) {
        this.drawElement(element, this.drawOptions)
            .then(this.exportGroup)
            .then(this.saveDataUri)
            .then(this.done, this.done);
    }
    drawElement(element, options) {
        return drawDOM(element, options);
    }
    exportGroup(group) {
        return exportPDF(group, this.pdfOptions);
    }
    saveDataUri(dataUri) {
        saveAs(dataUri, this.fileName, this.saveOptions);
    }
    done() {
        if (this.container) {
            document.body.removeChild(this.container);
            this.container = null;
        }
        this.pdfService.done.emit();
    }
}
PDFComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFComponent, deps: [{ token: PDFService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
PDFComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: PDFComponent, isStandalone: true, selector: "kendo-scheduler-pdf", inputs: { author: "author", avoidLinks: "avoidLinks", creator: "creator", date: "date", imageResolution: "imageResolution", fileName: "fileName", forceProxy: "forceProxy", keywords: "keywords", margin: "margin", scale: "scale", proxyData: "proxyData", proxyURL: "proxyURL", proxyTarget: "proxyTarget", producer: "producer", subject: "subject", title: "title" }, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-scheduler-pdf',
                    template: '',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: PDFService }, { type: i0.NgZone }]; }, propDecorators: { author: [{
                type: Input
            }], avoidLinks: [{
                type: Input
            }], creator: [{
                type: Input
            }], date: [{
                type: Input
            }], imageResolution: [{
                type: Input
            }], fileName: [{
                type: Input
            }], forceProxy: [{
                type: Input
            }], keywords: [{
                type: Input
            }], margin: [{
                type: Input
            }], scale: [{
                type: Input
            }], proxyData: [{
                type: Input
            }], proxyURL: [{
                type: Input
            }], proxyTarget: [{
                type: Input
            }], producer: [{
                type: Input
            }], subject: [{
                type: Input
            }], title: [{
                type: Input
            }] } });

/**
 * A directive which manages the in-memory selection state of the Scheduler slots
 * ([see example]({% slug slotselection_scheduler %}#toc-built-in-directive)).
 */
class SlotSelectableDirective {
    constructor(scheduler, cdr) {
        this.scheduler = scheduler;
        this.cdr = cdr;
        /**
         * Fires when the currently selected slot range has changed through user interaction.
         */
        this.slotSelectionChange = new EventEmitter();
        this.selectedRange = null;
        this.slotSelectionChangeSource = new EventEmitter();
        this.subscriptions = new Subscription();
        this.scheduler.selectable = true;
        this.subscriptions.add(this.slotSelectionChangeSource
            .pipe(distinctUntilChanged(isSameRange)).subscribe((v) => {
            this.slotSelectionChange.emit(v);
        }));
        const start$ = this.scheduler.slotDragStart;
        const drag$ = this.scheduler.slotDrag;
        const end$ = this.scheduler.slotDragEnd;
        const startSource = start$.pipe(filter(e => !e.isDefaultPrevented()));
        this.subscriptions.add(startSource.subscribe(e => this.initDragSelect(e)));
        this.subscriptions.add(drag$.subscribe(e => this.onDrag(e)));
        this.subscriptions.add(end$.subscribe(() => this.onRelease()));
    }
    ngOnInit() {
        this.scheduler.isSlotSelected = this.isSlotSelected.bind(this);
    }
    ngOnChanges(changes) {
        if (isChanged("slotSelection", changes, false)) {
            const defaults = {
                isAllDay: false,
                resources: this.scheduler?.resources ? this.scheduler.resources.reduce((result, resource) => {
                    result.push(...resource.data);
                    return result;
                }, []) : []
            };
            this.selectedRange = Object.assign(defaults, changes['slotSelection'].currentValue);
            this.cdr.markForCheck();
        }
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    isSlotSelected({ start, end, isAllDay, resources }) {
        if (!start || !end || !this.selectedRange) {
            return false;
        }
        const match = resourcesMatch(this.selectedRange.resources, resources);
        if (!match) {
            return false; // Limit selection to the grouped resource where the drag started.
        }
        return this.selectedRange && isAllDay === this.selectedRange.isAllDay && this.isInRange(start, end);
    }
    initDragSelect({ start, end, isAllDay, resources }) {
        this.selectionOriginResources = resources.slice();
        this.selectedRange = { start, end, isAllDay, resources: resources.slice() };
        this.cdr.markForCheck();
    }
    onDrag({ start, end, resources }) {
        const match = resourcesMatch(this.selectionOriginResources, resources);
        if (!match) {
            return; // Don't change selection when dragging over a different grouped resource's cells.
        }
        this.selectedRange.start = start;
        this.selectedRange.end = end;
        this.cdr.markForCheck();
    }
    onRelease() {
        this.selectionOriginResources = null;
        if (this.selectedRange) {
            this.slotSelectionChangeSource.emit(this.selectedRange);
        }
    }
    /**
     * @hidden
     * Checks if the selected range contains a local date range.
     */
    isInRange(start, end) {
        if (!this.selectedRange) {
            return;
        }
        return intersects(start, end, this.selectedRange.start, this.selectedRange.end);
    }
}
SlotSelectableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SlotSelectableDirective, deps: [{ token: SchedulerComponent }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
SlotSelectableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: SlotSelectableDirective, isStandalone: true, selector: "[kendoSchedulerSlotSelectable]", inputs: { slotSelection: "slotSelection" }, outputs: { slotSelectionChange: "slotSelectionChange" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SlotSelectableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerSlotSelectable]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SchedulerComponent }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { slotSelection: [{
                type: Input
            }], slotSelectionChange: [{
                type: Output
            }] } });

// eslint-disable no-input-rename
/**
 * A directive selector for a custom Scheduler view.
 */
class SchedulerViewDirective extends SchedulerView {
    constructor(template) {
        super();
        this.template = template;
    }
    /**
     * The invariant name for this view. For example, `day`.
     * If not set, the name will be the same as the title.
     */
    get name() {
        return this._name || this.title;
    }
    set name(value) {
        this._name = value;
    }
}
SchedulerViewDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerViewDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
SchedulerViewDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: SchedulerViewDirective, isStandalone: true, selector: "[kendoSchedulerView]", inputs: { title: ["kendoSchedulerView", "title"], name: ["kendoSchedulerViewName", "name"] }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => SchedulerViewDirective)
        }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerViewDirective, decorators: [{
            type: Directive,
            args: [{
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => SchedulerViewDirective)
                        }],
                    selector: '[kendoSchedulerView]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; }, propDecorators: { title: [{
                type: Input,
                args: ['kendoSchedulerView']
            }], name: [{
                type: Input,
                args: ['kendoSchedulerViewName']
            }] } });

const defaultSlotClass = (_args) => null;
/**
 * @hidden
 */
class ConfigurationViewBase extends SchedulerView {
    constructor(localization, changeDetector, viewContext, viewState) {
        super();
        this.localization = localization;
        this.changeDetector = changeDetector;
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.schedulerOptions = {};
        this.subs = this.localization.changes.subscribe(() => {
            changeDetector.markForCheck();
        });
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
    }
    /**
     * Specifies whether to display the toolbar of the Scheduler.
     */
    get showToolbar() {
        return this._showToolbar;
    }
    set showToolbar(value) {
        this._showToolbar = value;
        this.viewState.toolbarVisibilityByView.set(this, value);
    }
    /**
     * @hidden
     */
    get viewSlotClass() {
        return isPresent(this.slotClass) ? this.slotClass : (this.schedulerOptions.slotClass || defaultSlotClass);
    }
    /**
     * @hidden
     */
    get viewEventClass() {
        return isPresent(this.eventClass) ? this.eventClass : this.schedulerOptions.eventClass;
    }
    /**
     * @hidden
     */
    get viewEventStyles() {
        return isPresent(this.eventStyles) ? this.eventStyles : this.schedulerOptions.eventStyles;
    }
    /**
     * @hidden
     */
    get viewHighlightOngoingEvents() {
        return isPresent(this.highlightOngoingEvents) ? this.highlightOngoingEvents : this.schedulerOptions.highlightOngoingEvents;
    }
    /**
     * @hidden
     */
    get viewWeekStart() {
        return this.schedulerOptions.weekStart;
    }
    ngOnChanges(changes) {
        this.viewState.notifyOptionsChange(changes);
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.viewState.toolbarVisibilityByView.delete(this);
    }
    optionsChange(options) {
        this.schedulerOptions = options;
    }
}
ConfigurationViewBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ConfigurationViewBase, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Directive });
ConfigurationViewBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: ConfigurationViewBase, inputs: { slotClass: "slotClass", eventClass: "eventClass", eventStyles: "eventStyles", highlightOngoingEvents: "highlightOngoingEvents", showToolbar: "showToolbar" }, queries: [{ propertyName: "eventTemplate", first: true, predicate: EventTemplateDirective, descendants: true }, { propertyName: "groupHeaderTemplate", first: true, predicate: GroupHeaderTemplateDirective, descendants: true }], viewQueries: [{ propertyName: "template", first: true, predicate: ["content"], descendants: true, static: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ConfigurationViewBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { slotClass: [{
                type: Input
            }], eventClass: [{
                type: Input
            }], eventStyles: [{
                type: Input
            }], highlightOngoingEvents: [{
                type: Input
            }], showToolbar: [{
                type: Input
            }], template: [{
                type: ViewChild,
                args: ['content', { static: true }]
            }], eventTemplate: [{
                type: ContentChild,
                args: [EventTemplateDirective, { static: false }]
            }], groupHeaderTemplate: [{
                type: ContentChild,
                args: [GroupHeaderTemplateDirective, { static: false }]
            }] } });

const flip = fn => a => b => fn(b, a);
const sort = flip(orderBy);
const group = flip(groupBy);
/**
 * @hidden
 */
const compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);
/**
 * @hidden
 */
const processEvents = (_start, _end) => compose(group([{ field: "startDate" }]), sort([{ field: "start", dir: "asc" }, { field: "end", dir: "asc" }]));
function flattenGroupsAndAddIds(scope) {
    return function* flattenGroups(groups) {
        for (let index = 0; index < groups.length; index++) {
            const groupItem = groups[index];
            yield {
                type: "group",
                dataItem: groupItem,
                rowSpan: groupItem.items.length,
                elementId: `k-scheduler-${scope.counter}-${index}`
            };
            for (let itemIndex = 1; itemIndex < groupItem.items.length; itemIndex++) {
                const item = groupItem.items[itemIndex];
                yield {
                    type: "event",
                    dataItem: item,
                    elementId: `k-scheduler-${scope.counter}-${index}-item-${itemIndex}`
                };
            }
        }
    };
}
/** @hidden */
class EmptyIterator {
    [iterator]() {
        return {
            next: () => ({ done: true, value: null })
        };
    }
    toString() {
        return "Empty Iterator";
    }
}
let seed = 0;
/**
 * @hidden
 */
class TaskCollection {
    constructor(start, end, events) {
        this.start = start;
        this.end = end;
        this.events = events;
        this.createIterator = compose(flattenGroupsAndAddIds(this), processEvents(this.start, this.end));
        this.counter = seed;
        seed++;
    }
    static empty() {
        return (new EmptyIterator());
    }
    [iterator]() {
        return this.createIterator(this.events);
    }
    itemAt(index) {
        const taskIterator = this.createIterator(this.events);
        let idx = 0;
        let item;
        do {
            item = taskIterator.next();
            if (item && idx === index) {
                const value = item.value;
                return value.type === 'group' ? value.dataItem.items[0] : value.dataItem;
            }
            idx++;
        } while (item);
    }
    toString() {
        return this.events.toString();
    }
}

/**
 * @hidden
 */
function createResourceGroups(groupedResources) {
    let result = [];
    const firstResource = groupedResources[0];
    const firstResourceData = firstResource.data;
    for (let dataIdx = 0; dataIdx < firstResourceData.length; dataIdx++) {
        const item = firstResourceData[dataIdx];
        result.push({ resources: [getField(item, firstResource.textField)] });
    }
    for (let idx = 1; idx < groupedResources.length; idx++) {
        const resource = groupedResources[idx];
        const data = resource.data;
        const current = [];
        for (let resourceIdx = 0; resourceIdx < result.length; resourceIdx++) {
            const resourceItem = result[resourceIdx];
            for (let dataIdx = 0; dataIdx < data.length; dataIdx++) {
                const item = data[dataIdx];
                current.push({ resources: resourceItem.resources.concat(getField(item, resource.textField)) });
            }
        }
        result = current;
    }
    return result;
}
function createTask(item, resourceIdx, resources, color) {
    const event = item.event;
    return {
        event,
        start: item.start.toUTCDate(),
        end: item.end.toUTCDate(),
        title: event.title,
        isAllDay: event.isAllDay,
        color,
        resourceIdx,
        resources
    };
}
const durationInDays = ({ start, end, isAllDay = false }) => {
    const eventEnd = isAllDay ? getUTCDate(end) : end;
    const duration = Math.ceil((eventEnd - +getUTCDate(start)) / MS_PER_DAY$1);
    if (isAllDay && duration > 0 && !endsAtMidnight(end)) {
        return duration + 1;
    }
    return duration;
};
const endsAtMidnight = (end) => {
    end = toLocalDate(end);
    return (end.getHours() === 0 && end.getMinutes() === 0 && end.getSeconds() === 0 && end.getMilliseconds() === 0);
};
const curry = fn => {
    const len = fn.length;
    return (...args) => len === args.length
        ? fn(...args)
        : curry(fn.bind(null, ...args));
};
const range = num => Array.from(new Array(num).keys());
const cloneTask = (eventStart, eventEnd) => task => ({
    ...task,
    start: getUTCDate(eventStart),
    end: task.tail && !task.isAllDay ? eventEnd : addUTCDays(eventStart, 1),
    startDate: getUTCDate(eventStart)
});
const previousEventEnd = (start, events) => events.length
    ? events[events.length - 1].end
    : start;
const markAsTail = isLast => task => {
    if (isLast) {
        task.tail = true;
    }
    return task;
};
const markAsMid = task => {
    if (!task.tail) {
        task.mid = true;
    }
    return task;
};
const addTaskPart = (task, start) => (tasks, _, day, days) => tasks.concat(compose(markAsMid, cloneTask(previousEventEnd(start, tasks), task.end), markAsTail(day === days.length - 1))(task));
const splitMultiDayTask = (task, start) => range(durationInDays(task) - 1)
    .reduce(addTaskPart(task, start), []);
/**
 * @hidden
 */
const splitTasks = curry((periodStart, periodEnd, tasks) => {
    const result = [];
    for (let index = 0; index < tasks.length; index++) {
        const task = { ...tasks[index] };
        task.startDate = getUTCDate(task.start);
        if (task.start >= periodStart && task.start <= periodEnd) {
            result.push(task);
        }
        if (durationInDays(task) > 1) {
            task.end = addUTCDays(task.startDate, 1);
            task.head = true;
            result.push(...splitMultiDayTask({ ...tasks[index] }, task.end)
                .filter(tsk => getUTCDate(tsk.end) <= periodEnd && tsk.start >= periodStart));
        }
    }
    return result;
});
function groupByResource(groupedResources, resourceGroups, dateRange) {
    const groups = resourceGroups.filter(group => group.tasks && group.tasks.length);
    if (!groups.length) {
        return [];
    }
    const values = groups[0].resources.map(resource => ({ value: resource, span: 0, groupIdx: 0 }));
    const periodStart = toUTCDate(dateRange.start);
    const periodEnd = toUTCDate(dateRange.end);
    for (let groupIdx = 0; groupIdx < groups.length; groupIdx++) {
        const group = groups[groupIdx];
        group.tasks = splitTasks(periodStart, periodEnd, group.tasks);
        const count = group.tasks.length;
        group.tasks = new TaskCollection(periodStart, periodEnd, group.tasks);
        let invalidate = false;
        for (let resourceIdx = 0; resourceIdx < groupedResources.length; resourceIdx++) {
            const resourceValue = values[resourceIdx];
            if (resourceValue.value !== group.resources[resourceIdx] || invalidate) {
                resourceValue.value = group.resources[resourceIdx];
                const spanGroup = groups[resourceValue.groupIdx];
                spanGroup.spans = spanGroup.spans || [];
                spanGroup.spans[resourceIdx] = resourceValue.span;
                resourceValue.span = count;
                resourceValue.groupIdx = groupIdx;
                invalidate = true;
            }
            else {
                resourceValue.span += count;
            }
        }
    }
    values.forEach((value, index) => {
        const group = groups[value.groupIdx];
        group.spans = group.spans || [];
        group.spans[index] = value.span;
    });
    return groups;
}
/**
 * @hidden
 */
function groupEvents(items, { taskResources, resourceGroups, spans, allResources, dateRange }) {
    const groups = resourceGroups || [{}];
    const periodStart = toUTCDate(dateRange.start);
    const periodEnd = toUTCDate(dateRange.end);
    for (let idx = 0; idx < items.length; idx++) {
        const item = items[idx];
        const event = item.event;
        if (!intersects(item.start.toUTCDate(), item.end.toUTCDate(), periodStart, periodEnd)) {
            continue;
        }
        const resources = eventResources(event, { taskResources, hasGroups: resourceGroups && resourceGroups.length > 0, spans, allResources });
        if (resources.length && resources[0].leafIdx >= 0) {
            for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
                const current = resources[resourceIdx];
                const task = createTask(item, current.leafIdx, current.resources, current.color);
                const tasks = groups[current.leafIdx].tasks = groups[current.leafIdx].tasks || [];
                tasks.push(task);
            }
        }
    }
    if (resourceGroups) {
        return groupByResource(taskResources, groups, dateRange);
    }
    groups[0].tasks = new TaskCollection(periodStart, periodEnd, splitTasks(periodStart, periodEnd, groups[0].tasks || []));
    return groups;
}

/**
 * @hidden
 */
class AgendaTaskItemComponent {
    constructor(localization, localeId) {
        this.localization = localization;
        this.localeId = localeId;
        this.arrowRotateCWIcon = arrowRotateCwIcon;
        this.arrowsNoRepeatIcon = arrowsNoRepeatIcon;
        this.xIcon = xIcon;
        this.cellClass = true;
    }
    get eventTitle() {
        const start = toLocalDate(this.item.start);
        const end = toLocalDate(this.item.end);
        const time = formatEventTime(start, end, this.item.isAllDay, this.localeId);
        return `${time}, ${this.item.event.title}`;
    }
    get eventColor() {
        return this.item.color;
    }
    get deleteMessage() {
        return this.localization.get('deleteTitle');
    }
    get isRecurrence() {
        return isRecurrence(this.item);
    }
    get isRecurrenceException() {
        return isRecurrenceException(this.item);
    }
    get removable() {
        return this.editable && this.editable.remove !== false;
    }
}
AgendaTaskItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaTaskItemComponent, deps: [{ token: i1$1.LocalizationService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
AgendaTaskItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaTaskItemComponent, isStandalone: true, selector: "[kendoSchedulerAgendaTaskItem]", inputs: { item: ["kendoSchedulerAgendaTaskItem", "item"], color: "color", eventTemplate: "eventTemplate", editable: "editable" }, host: { properties: { "class.k-scheduler-cell": "this.cellClass", "attr.aria-label": "this.eventTitle" } }, ngImport: i0, template: `
        <div class="k-task" [title]="item.title">
            <span class="k-scheduler-mark" *ngIf="eventColor" [style.background-color]="eventColor"></span>
            <kendo-icon-wrapper *ngIf="isRecurrence" name="arrow-rotate-cw" [svgIcon]="arrowRotateCWIcon"></kendo-icon-wrapper>

            <kendo-icon-wrapper *ngIf="isRecurrenceException" name="arrows-no-repeat" [svgIcon]="arrowsNoRepeatIcon"></kendo-icon-wrapper>
            <ng-container *ngIf="!eventTemplate">
                {{item?.title }}
            </ng-container>
            <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
                [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: item.resources }">
            </ng-container>

            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaTaskItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerAgendaTaskItem]',
                    template: `
        <div class="k-task" [title]="item.title">
            <span class="k-scheduler-mark" *ngIf="eventColor" [style.background-color]="eventColor"></span>
            <kendo-icon-wrapper *ngIf="isRecurrence" name="arrow-rotate-cw" [svgIcon]="arrowRotateCWIcon"></kendo-icon-wrapper>

            <kendo-icon-wrapper *ngIf="isRecurrenceException" name="arrows-no-repeat" [svgIcon]="arrowsNoRepeatIcon"></kendo-icon-wrapper>
            <ng-container *ngIf="!eventTemplate">
                {{item?.title }}
            </ng-container>
            <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
                [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: item.resources }">
            </ng-container>

            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
        </div>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { item: [{
                type: Input,
                args: ["kendoSchedulerAgendaTaskItem"]
            }], color: [{
                type: Input
            }], eventTemplate: [{
                type: Input
            }], editable: [{
                type: Input
            }], cellClass: [{
                type: HostBinding,
                args: ["class.k-scheduler-cell"]
            }], eventTitle: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }] } });

/**
 * @hidden
 */
class AgendaHeaderItemComponent {
    constructor() {
        this.classes = true;
        this.roleAttribute = "rowheader";
        this.hasFirstClass = true;
    }
    get firstClass() {
        return this.hasFirstClass;
    }
    get rowSpan() {
        return this.item.rowSpan;
    }
    get itemDate() {
        return toLocalDate(this.item.dataItem.value);
    }
}
AgendaHeaderItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaHeaderItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
AgendaHeaderItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaHeaderItemComponent, isStandalone: true, selector: "[kendoSchedulerAgendaHeaderItem]", inputs: { item: ["kendoSchedulerAgendaHeaderItem", "item"], agendaDateTemplate: "agendaDateTemplate", hasFirstClass: "hasFirstClass" }, host: { properties: { "class.k-scheduler-datecolumn": "this.classes", "class.k-scheduler-cell": "this.classes", "class.k-first": "this.firstClass", "attr.role": "this.roleAttribute", "attr.rowspan": "this.rowSpan" } }, ngImport: i0, template: `
        <ng-container *ngIf="!agendaDateTemplate">
            <strong class="k-scheduler-agendaday">{{itemDate | kendoDate: 'dd'}}</strong>
            <em class="k-scheduler-agendaweek">{{itemDate | kendoDate: 'EEEE'}}</em>
            <span class="k-scheduler-agendadate">{{itemDate | kendoDate: 'y'}}</span>
        </ng-container>
        <ng-container *ngIf="agendaDateTemplate" [ngTemplateOutlet]="agendaDateTemplate"
            [ngTemplateOutletContext]="{ date: itemDate }">
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: DatePipe, name: "kendoDate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaHeaderItemComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerAgendaHeaderItem]',
                    template: `
        <ng-container *ngIf="!agendaDateTemplate">
            <strong class="k-scheduler-agendaday">{{itemDate | kendoDate: 'dd'}}</strong>
            <em class="k-scheduler-agendaweek">{{itemDate | kendoDate: 'EEEE'}}</em>
            <span class="k-scheduler-agendadate">{{itemDate | kendoDate: 'y'}}</span>
        </ng-container>
        <ng-container *ngIf="agendaDateTemplate" [ngTemplateOutlet]="agendaDateTemplate"
            [ngTemplateOutletContext]="{ date: itemDate }">
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet, DatePipe]
                }]
        }], propDecorators: { classes: [{
                type: HostBinding,
                args: ["class.k-scheduler-datecolumn"]
            }, {
                type: HostBinding,
                args: ["class.k-scheduler-cell"]
            }], firstClass: [{
                type: HostBinding,
                args: ["class.k-first"]
            }], roleAttribute: [{
                type: HostBinding,
                args: ["attr.role"]
            }], rowSpan: [{
                type: HostBinding,
                args: ["attr.rowspan"]
            }], item: [{
                type: Input,
                args: ["kendoSchedulerAgendaHeaderItem"]
            }], agendaDateTemplate: [{
                type: Input
            }], hasFirstClass: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class AgendaListComponent {
    constructor(intlService, localization) {
        this.intlService = intlService;
        this.localization = localization;
        this.classes = true;
        this.caretAltLeftIcon = caretAltLeftIcon;
        this.caretAltRightIcon = caretAltRightIcon;
    }
    extractDataItem(item) {
        return item.type === "group" ? item.dataItem.items[0] : item.dataItem;
    }
    extractDataItemInLocalTime(item) {
        let currentItem;
        if (item.type === "group") {
            currentItem = { ...item.dataItem.items[0] };
            currentItem.start = toLocalDate(item.dataItem.items[0].start);
            currentItem.end = toLocalDate(item.dataItem.items[0].end);
        }
        else {
            currentItem = { ...item.dataItem };
            currentItem.start = toLocalDate(item.dataItem.start);
            currentItem.end = toLocalDate(item.dataItem.end);
        }
        return currentItem;
    }
    formatTime(dataItem) {
        if (dataItem.isAllDay) {
            return this.localization.get('allDay');
        }
        let format = "{0:t}-{1:t}";
        if (dataItem.head) {
            format = "{0:t}";
        }
        else if (dataItem.tail) {
            format = "{1:t}";
        }
        return this.intlService.format(format, toLocalDate(dataItem.start), toLocalDate(dataItem.end));
    }
    trackByFn(index, _item) {
        return index;
    }
    cellClasses(item) {
        const task = this.extractDataItem(item);
        let result = [];
        if (this.slotClass) {
            result = result.concat(convertNgClassBindings(this.slotClass({
                start: task.start,
                end: task.end,
                resources: task.resources,
                event: task.event
            })));
        }
        if (this.eventClass) {
            result = result.concat(convertNgClassBindings(this.eventClass({
                event: task.event,
                resources: task.resources
            })));
        }
        return result;
    }
    getEventStyles(item) {
        if (this.eventStyles) {
            const task = this.extractDataItem(item);
            return this.eventStyles({
                event: task.event,
                resources: task.resources
            });
        }
    }
    get arrowIcons() {
        return !this.localization.rtl ? ['caret-alt-left', 'caret-alt-right'] : ['caret-alt-right', 'caret-alt-left'];
    }
    get arrowSVGIcons() {
        return !this.localization.rtl ? [this.caretAltLeftIcon, this.caretAltRightIcon] : [this.caretAltRightIcon, this.caretAltLeftIcon];
    }
}
AgendaListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaListComponent, deps: [{ token: i1$2.IntlService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
AgendaListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaListComponent, isStandalone: true, selector: "[kendoSchedulerAgendaList]", inputs: { tasks: "tasks", eventTemplate: "eventTemplate", slotClass: "slotClass", eventClass: "eventClass", eventStyles: "eventStyles", agendaTimeTemplate: "agendaTimeTemplate", agendaDateTemplate: "agendaDateTemplate", editable: "editable" }, host: { properties: { "class.k-scheduler-content": "this.classes" } }, ngImport: i0, template: `
        <table class="k-scheduler-table" role="none">
            <tbody role="rowgroup">
                <ng-container *ngFor="let group of tasks; let groupIndex = index;">
                    <tr *ngFor="let item of group.tasks; let index = index; trackBy: trackByFn" role="row">
                        <ng-container *ngFor="let resource of group.resources; let resourceIndex = index">
                            <td *ngIf="group.spans[resourceIndex] && index === 0" class="k-scheduler-groupcolumn k-first" [attr.rowspan]="group.spans[resourceIndex]" role="rowheader">
                                {{ resource }}
                            </td>
                        </ng-container>
                        <td *ngIf="item.type === 'group'"
                            [kendoSchedulerAgendaHeaderItem]="item"
                            [hasFirstClass]="!group.resources || group.resources.length === 0"
                            [agendaDateTemplate]="agendaDateTemplate">
                        </td>
                        <td class="k-scheduler-timecolumn k-scheduler-cell" role="gridcell">
                            <div *ngIf="!agendaTimeTemplate">
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).tail || extractDataItem(item).mid"
                                    [name]="arrowIcons[0]"
                                    [svgIcon]="arrowSVGIcons[0]"
                                    >
                                </kendo-icon-wrapper>

                                {{ formatTime(extractDataItem(item)) }}
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).head || extractDataItem(item).mid"
                                    [name]="arrowIcons[1]"
                                    [svgIcon]="arrowSVGIcons[1]"
                                    >
                                </kendo-icon-wrapper>
                            </div>
                            <ng-container *ngIf="agendaTimeTemplate" [ngTemplateOutlet]="agendaTimeTemplate"
                                [ngTemplateOutletContext]="extractDataItemInLocalTime(item)">
                            </ng-container>
                        </td>
                        <td [attr.data-group-index]="groupIndex" [attr.data-task-index]="index" role="gridcell"
                            [ngClass]="cellClasses(item)" [ngStyle]="getEventStyles(item)"
                            [kendoSchedulerFocusIndex]="groupIndex"
                            [id]="item.elementId"
                            [kendoSchedulerAgendaTaskItem]="extractDataItem(item)"
                                [editable]="editable"
                                [eventTemplate]="eventTemplate"
                        ></td>
                    </tr>
                </ng-container>
            </tbody>
        </table>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: AgendaHeaderItemComponent, selector: "[kendoSchedulerAgendaHeaderItem]", inputs: ["kendoSchedulerAgendaHeaderItem", "agendaDateTemplate", "hasFirstClass"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "component", type: AgendaTaskItemComponent, selector: "[kendoSchedulerAgendaTaskItem]", inputs: ["kendoSchedulerAgendaTaskItem", "color", "eventTemplate", "editable"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaListComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerAgendaList]',
                    template: `
        <table class="k-scheduler-table" role="none">
            <tbody role="rowgroup">
                <ng-container *ngFor="let group of tasks; let groupIndex = index;">
                    <tr *ngFor="let item of group.tasks; let index = index; trackBy: trackByFn" role="row">
                        <ng-container *ngFor="let resource of group.resources; let resourceIndex = index">
                            <td *ngIf="group.spans[resourceIndex] && index === 0" class="k-scheduler-groupcolumn k-first" [attr.rowspan]="group.spans[resourceIndex]" role="rowheader">
                                {{ resource }}
                            </td>
                        </ng-container>
                        <td *ngIf="item.type === 'group'"
                            [kendoSchedulerAgendaHeaderItem]="item"
                            [hasFirstClass]="!group.resources || group.resources.length === 0"
                            [agendaDateTemplate]="agendaDateTemplate">
                        </td>
                        <td class="k-scheduler-timecolumn k-scheduler-cell" role="gridcell">
                            <div *ngIf="!agendaTimeTemplate">
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).tail || extractDataItem(item).mid"
                                    [name]="arrowIcons[0]"
                                    [svgIcon]="arrowSVGIcons[0]"
                                    >
                                </kendo-icon-wrapper>

                                {{ formatTime(extractDataItem(item)) }}
                                <kendo-icon-wrapper
                                    *ngIf="extractDataItem(item).head || extractDataItem(item).mid"
                                    [name]="arrowIcons[1]"
                                    [svgIcon]="arrowSVGIcons[1]"
                                    >
                                </kendo-icon-wrapper>
                            </div>
                            <ng-container *ngIf="agendaTimeTemplate" [ngTemplateOutlet]="agendaTimeTemplate"
                                [ngTemplateOutletContext]="extractDataItemInLocalTime(item)">
                            </ng-container>
                        </td>
                        <td [attr.data-group-index]="groupIndex" [attr.data-task-index]="index" role="gridcell"
                            [ngClass]="cellClasses(item)" [ngStyle]="getEventStyles(item)"
                            [kendoSchedulerFocusIndex]="groupIndex"
                            [id]="item.elementId"
                            [kendoSchedulerAgendaTaskItem]="extractDataItem(item)"
                                [editable]="editable"
                                [eventTemplate]="eventTemplate"
                        ></td>
                    </tr>
                </ng-container>
            </tbody>
        </table>
    `,
                    standalone: true,
                    imports: [NgFor, NgIf, AgendaHeaderItemComponent, IconWrapperComponent, NgTemplateOutlet, NgClass, NgStyle, FocusableDirective, AgendaTaskItemComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: i1$1.LocalizationService }]; }, propDecorators: { classes: [{
                type: HostBinding,
                args: ['class.k-scheduler-content']
            }], tasks: [{
                type: Input
            }], eventTemplate: [{
                type: Input
            }], slotClass: [{
                type: Input
            }], eventClass: [{
                type: Input
            }], eventStyles: [{
                type: Input
            }], agendaTimeTemplate: [{
                type: Input
            }], agendaDateTemplate: [{
                type: Input
            }], editable: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class AgendaHeaderComponent {
    constructor(localization) {
        this.localization = localization;
        this.classes = true;
    }
    get dateMessage() {
        return this.localization.get('dateHeader');
    }
    get timeMessage() {
        return this.localization.get('timeHeader');
    }
    get eventMessage() {
        return this.localization.get('eventHeader');
    }
}
AgendaHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaHeaderComponent, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
AgendaHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaHeaderComponent, isStandalone: true, selector: "[kendoSchedulerAgendaHeader]", inputs: { resources: "resources" }, host: { properties: { "class.k-scheduler-header": "this.classes" } }, ngImport: i0, template: `
        <div class="k-scheduler-header-wrap">
            <table class="k-scheduler-table" role="none">
                <tbody role="rowgroup">
                    <tr role="row">
                        <th *ngFor="let resource of resources" class="k-scheduler-groupcolumn k-first" role="columnheader"></th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-datecolumn" role="columnheader">{{ dateMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-timecolumn" role="columnheader">{{ timeMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell" role="columnheader">{{ eventMessage }}</th>
                    </tr>   
                </tbody>
            </table>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoSchedulerAgendaHeader]',
                    template: `
        <div class="k-scheduler-header-wrap">
            <table class="k-scheduler-table" role="none">
                <tbody role="rowgroup">
                    <tr role="row">
                        <th *ngFor="let resource of resources" class="k-scheduler-groupcolumn k-first" role="columnheader"></th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-datecolumn" role="columnheader">{{ dateMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell k-scheduler-timecolumn" role="columnheader">{{ timeMessage }}</th>
                        <th class="k-scheduler-cell k-heading-cell" role="columnheader">{{ eventMessage }}</th>
                    </tr>   
                </tbody>
            </table>
        </div>
    `,
                    standalone: true,
                    imports: [NgFor]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }]; }, propDecorators: { classes: [{
                type: HostBinding,
                args: ["class.k-scheduler-header"]
            }], resources: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class AgendaViewInternalComponent {
    constructor(viewContext, viewState, intl, renderer, element, zone, pdfService, localization) {
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.intl = intl;
        this.renderer = renderer;
        this.element = element;
        this.zone = zone;
        this.pdfService = pdfService;
        this.localization = localization;
        this.tasks = new BehaviorSubject(null);
        this.groupedResources = [];
        this.spans = [];
        this.subs = new Subscription();
    }
    get eventTemplateRef() {
        return this.eventTemplate || (this.schedulerEventTemplate || {}).templateRef;
    }
    get agendaTimeTemplateRef() {
        return this.agendaTimeTemplate || (this.schedulerAgendaTimeTemplate || {}).templateRef;
    }
    get agendaDateTemplateRef() {
        return this.agendaDateTemplate || (this.schedulerAgendaDateTemplate || {}).templateRef;
    }
    ngOnInit() {
        this.updateContentHeight = this.updateContentHeight.bind(this);
        this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
        this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
        this.subs.add(this.viewContext.execute.subscribe(this.execute.bind(this)));
        this.subs.add(this.viewContext.resize.subscribe(this.updateContentHeight));
        this.subs.add(combineLatest([
            this.viewContext.items,
            this.viewState.dateRange
        ]).pipe(map(([items, dateRange]) => {
            this.items = items;
            this.range = dateRange;
            return this.createEventGroups();
        }))
            .subscribe((tasks) => {
            this.tasks.next(tasks);
        }));
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
        const onStable = () => this.zone.onStable.pipe(take(1));
        this.subs.add(combineLatest(this.tasks, this.localization.changes).pipe(switchMap(onStable))
            .subscribe(this.updateContentHeight));
        this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
    }
    ngOnChanges(changes) {
        if (anyChanged(['selectedDateFormat', 'selectedShortDateFormat', 'numberOfDays'], changes)) {
            this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
        }
    }
    ngAfterViewInit() {
        if (!this.element) {
            return;
        }
        const contentElement = this.content.nativeElement;
        this.zone.runOutsideAngular(() => {
            this.subs.add(merge(fromEvent(contentElement, 'click'), fromEvent(contentElement, 'contextmenu'), fromEvent(contentElement, 'dblclick'))
                .subscribe(e => this.onClick(e)));
            this.subs.add(fromEvent(contentElement, 'keydown')
                .subscribe(e => this.onKeydown(e)));
        });
    }
    onClick(e) {
        const targetTask = this.targetTask(e.target);
        if (targetTask) {
            const { task, eventTarget } = targetTask;
            const eventType = e.type;
            const isSingle = eventType === 'click';
            const isDouble = eventType === 'dblclick';
            if (isSingle && closestInScope(e.target, node => hasClasses(node, 'k-event-delete'), eventTarget)) {
                this.viewState.emitEvent('remove', { event: task.event, dataItem: task.event.dataItem });
            }
            else {
                const name = isDouble ? 'eventDblClick' : 'eventClick';
                this.viewState.emitEvent(name, { type: eventType, event: task.event, originalEvent: e });
            }
        }
    }
    onKeydown(e) {
        const targetTask = this.targetTask(e.target);
        if (targetTask) {
            const task = targetTask.task;
            this.viewState.emitEvent('eventKeydown', { event: task.event, dataItem: task.event.dataItem, originalEvent: e });
        }
    }
    targetTask(target) {
        const eventTarget = closestInScope(target, node => node.hasAttribute('data-task-index'), this.element.nativeElement);
        if (eventTarget) {
            return {
                eventTarget,
                task: this.elementTask(eventTarget)
            };
        }
    }
    updateContentHeight() {
        const element = this.element.nativeElement;
        const parent = element.parentNode;
        const content = this.content.nativeElement;
        this.renderer.setStyle(content, 'height', '');
        let height = parent.clientHeight;
        for (let idx = 0; idx < parent.children.length; idx++) {
            const child = parent.children[idx];
            if (child !== element && !ignoreContentChild(child)) {
                height -= child.offsetHeight;
            }
        }
        const headerElement = this.headerWrap.nativeElement;
        height -= this.headerWrap ? headerElement.offsetHeight : 0;
        this.renderer.setStyle(content, 'height', `${height}px`);
        const rtl = this.localization.rtl;
        // Need to explicitly set 'padding-inline-xxx' to 0px when the Scheduler has no height set
        if (!hasScrollbar(content, 'vertical')) {
            this.renderer.setStyle(headerElement, !rtl ? 'padding-inline-end' : 'padding-inline-start', '0px');
        }
        this.renderer.removeStyle(headerElement, rtl ? 'padding-inline-end' : 'padding-inline-start');
        this.viewState.notifyLayoutEnd();
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    optionsChange(changes) {
        this.group = changes.group;
        this.resources = changes.resources;
        this.groupResources();
        this.min = changes.min;
        this.max = changes.max;
        this.editable = changes.editable;
        if (this.items && this.items.length) {
            this.tasks.next(this.createEventGroups());
        }
        this.schedulerEventTemplate = changes.eventTemplate;
        this.schedulerAgendaTimeTemplate = changes.agendaTimeTemplate;
        this.schedulerAgendaDateTemplate = changes.agendaDateTemplate;
    }
    onSelectDate(date) {
        this.selectedDate = date;
        this.viewState.notifyDateRange(this.dateRange());
    }
    onAction(e) {
        const now = getDate(this.selectedDate);
        if (e.type === 'next') {
            const next = getDate(addDays(now, this.numberOfDays));
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'prev') {
            const next = getDate(addDays(now, -this.numberOfDays));
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
    }
    createEventGroups() {
        const resourceGroups = this.groupedResources.length ? createResourceGroups(this.groupedResources) : null;
        const eventGroups = this.groups = groupEvents(this.items, {
            taskResources: this.taskResources,
            resourceGroups,
            allResources: this.resources,
            spans: this.spans,
            dateRange: this.range
        });
        return eventGroups;
    }
    dateRange(date = this.selectedDate) {
        const start = getDate(date);
        const end = getDate(addDays(start, this.numberOfDays));
        const rangeEnd = getDate(addDays(start, this.numberOfDays - 1));
        const text = this.intl.format(this.selectedDateFormat, start, rangeEnd);
        const shortText = this.intl.format(this.selectedShortDateFormat, start, rangeEnd);
        return { start, end, text, shortText };
    }
    groupResources() {
        const resources = this.resources || [];
        const group = this.group || {};
        const grouped = group.resources;
        const groupedResources = this.groupedResources = [];
        if (grouped && grouped.length) {
            for (let groupIdx = 0; groupIdx < grouped.length; groupIdx++) {
                const name = grouped[groupIdx];
                const resource = resources.find(item => item.name === name);
                if (resource) {
                    groupedResources.push(resource);
                }
            }
        }
        this.spans = this.resourceSpans();
    }
    resourceSpans() {
        const spans = [1];
        const resources = this.groupedResources;
        let span = 1;
        for (let idx = resources.length - 1; idx > 0; idx--) {
            span *= ((resources[idx].data || []).length || 1);
            spans.unshift(span);
        }
        return spans;
    }
    get taskResources() {
        if (this.groupedResources.length) {
            return this.groupedResources;
        }
        else if (this.resources && this.resources.length) {
            return [this.resources[0]];
        }
        else {
            return [{}];
        }
    }
    isInRange(date) {
        const dateRange = this.dateRange(date);
        return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
    }
    createPDFElement() {
        const element = this.element.nativeElement.cloneNode(true);
        element.style.width = `${this.element.nativeElement.offsetWidth}px`;
        element.querySelector('.k-scheduler-content').style.height = 'auto';
        const header = element.querySelector('.k-scheduler-header');
        header.style.paddingRight = 0;
        header.style.paddingLeft = 0;
        this.pdfService.elementReady.emit({
            element: element
        });
    }
    elementTask(element) {
        const index = parseInt(element.getAttribute('data-task-index'), 10);
        const groupIndex = parseInt(element.getAttribute('data-group-index'), 10);
        const group = this.groups[groupIndex];
        const task = group.tasks.itemAt(index);
        return task;
    }
    execute(e) {
        if (e.name === 'slotByPosition') {
            const slot = this.slotByPosition(e.args);
            e.result(slot);
        }
        else if (e.name === 'eventFromElement') {
            const task = this.elementTask(e.args.element);
            if (task) {
                e.result(task.event);
            }
        }
    }
    slotByPosition({ x, y }) {
        const contentTable = this.content.nativeElement.querySelector('table');
        const offset = elementOffset(contentTable);
        if (offset.top <= y && y <= offset.top + offset.height) {
            const contentRows = contentTable.rows;
            if (!contentRows.length) {
                return;
            }
            const taskOffset = elementOffset(contentRows[0].cells[contentRows[0].cells.length - 1]);
            if (taskOffset.left <= x && x <= taskOffset.left + taskOffset.width) {
                for (let idx = 0; idx < contentRows.length; idx++) {
                    const row = contentRows[idx];
                    const rowOffset = elementOffset(row);
                    if (rowOffset.top <= y && y <= rowOffset.top + rowOffset.height) {
                        const element = row.querySelector('[data-task-index]');
                        const task = this.elementTask(element);
                        const event = task.event;
                        return {
                            element: new ElementRef(element),
                            start: event.start,
                            end: event.end,
                            event: event,
                            resources: task.resources,
                            isAllDay: task.isAllDay
                        };
                    }
                }
            }
        }
    }
}
AgendaViewInternalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaViewInternalComponent, deps: [{ token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: PDFService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
AgendaViewInternalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaViewInternalComponent, isStandalone: true, selector: "agenda-view-internal", inputs: { eventTemplate: "eventTemplate", slotClass: "slotClass", eventClass: "eventClass", eventStyles: "eventStyles", agendaTimeTemplate: "agendaTimeTemplate", agendaDateTemplate: "agendaDateTemplate", selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfDays: "numberOfDays" }, viewQueries: [{ propertyName: "headerWrap", first: true, predicate: ["headerWrap"], descendants: true, read: ElementRef, static: true }, { propertyName: "content", first: true, predicate: ["content"], descendants: true, read: ElementRef, static: true }], usesOnChanges: true, ngImport: i0, template: `
        <table class="k-scheduler-layout k-scheduler-agendaview" role="grid">
            <tbody role="none">
                <tr class="k-scheduler-head">
                    <td>
                        <div kendoSchedulerAgendaHeader [resources]="groupedResources" #headerWrap></div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div kendoSchedulerAgendaList #content
                            [editable]="editable"
                            [eventTemplate]="eventTemplateRef"
                            [slotClass]="slotClass"
                            [eventClass]="eventClass"
                            [eventStyles]="eventStyles"
                            [agendaTimeTemplate]="agendaTimeTemplateRef"
                            [agendaDateTemplate]="agendaDateTemplateRef"
                            [tasks]="tasks | async">
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `, isInline: true, dependencies: [{ kind: "component", type: AgendaHeaderComponent, selector: "[kendoSchedulerAgendaHeader]", inputs: ["resources"] }, { kind: "component", type: AgendaListComponent, selector: "[kendoSchedulerAgendaList]", inputs: ["tasks", "eventTemplate", "slotClass", "eventClass", "eventStyles", "agendaTimeTemplate", "agendaDateTemplate", "editable"] }, { kind: "pipe", type: AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaViewInternalComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'agenda-view-internal',
                    template: `
        <table class="k-scheduler-layout k-scheduler-agendaview" role="grid">
            <tbody role="none">
                <tr class="k-scheduler-head">
                    <td>
                        <div kendoSchedulerAgendaHeader [resources]="groupedResources" #headerWrap></div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div kendoSchedulerAgendaList #content
                            [editable]="editable"
                            [eventTemplate]="eventTemplateRef"
                            [slotClass]="slotClass"
                            [eventClass]="eventClass"
                            [eventStyles]="eventStyles"
                            [agendaTimeTemplate]="agendaTimeTemplateRef"
                            [agendaDateTemplate]="agendaDateTemplateRef"
                            [tasks]="tasks | async">
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
                    standalone: true,
                    imports: [AgendaHeaderComponent, AgendaListComponent, AsyncPipe]
                }]
        }], ctorParameters: function () { return [{ type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: PDFService }, { type: i1$1.LocalizationService }]; }, propDecorators: { eventTemplate: [{
                type: Input
            }], slotClass: [{
                type: Input
            }], eventClass: [{
                type: Input
            }], eventStyles: [{
                type: Input
            }], agendaTimeTemplate: [{
                type: Input
            }], agendaDateTemplate: [{
                type: Input
            }], selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfDays: [{
                type: Input
            }], headerWrap: [{
                type: ViewChild,
                args: ['headerWrap', { read: ElementRef, static: true }]
            }], content: [{
                type: ViewChild,
                args: ['content', { read: ElementRef, static: true }]
            }] } });

/**
 * The component for rendering the **Agenda** view.
 */
class AgendaViewComponent extends ConfigurationViewBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        /**
         * The long-date format for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:D} - {1:D}`,
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         */
        this.selectedDateFormat = '{0:D} - {1:D}';
        /**
         * The short-date format for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:d} - {1:d}`,
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         * @default '{0:d} - {1:d}'
         */
        this.selectedShortDateFormat = '{0:d} - {1:d}';
        /**
         * Specifies the number of days that the view will render.
         * @default 7
         */
        this.numberOfDays = 7;
        /**
         * The invariant name for this view (`agenda`).
         * @default 'agenda'
         */
        this.name = 'agenda';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('agendaViewTitle');
    }
}
AgendaViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
AgendaViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: AgendaViewComponent, isStandalone: true, selector: "kendo-scheduler-agenda-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfDays: "numberOfDays" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => AgendaViewComponent)
        }], queries: [{ propertyName: "eventTemplate", first: true, predicate: EventTemplateDirective, descendants: true }, { propertyName: "agendaTimeTemplate", first: true, predicate: AgendaTimeTemplateDirective, descendants: true }, { propertyName: "agendaDateTemplate", first: true, predicate: AgendaDateTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <agenda-view-internal
                [numberOfDays]="numberOfDays"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [agendaTimeTemplate]="agendaTimeTemplate?.templateRef"
                [agendaDateTemplate]="agendaDateTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </agenda-view-internal>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: AgendaViewInternalComponent, selector: "agenda-view-internal", inputs: ["eventTemplate", "slotClass", "eventClass", "eventStyles", "agendaTimeTemplate", "agendaDateTemplate", "selectedDateFormat", "selectedShortDateFormat", "numberOfDays"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: AgendaViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-agenda-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => AgendaViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <agenda-view-internal
                [numberOfDays]="numberOfDays"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [agendaTimeTemplate]="agendaTimeTemplate?.templateRef"
                [agendaDateTemplate]="agendaDateTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </agenda-view-internal>
        </ng-template>
    `,
                    standalone: true,
                    imports: [AgendaViewInternalComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfDays: [{
                type: Input
            }], eventTemplate: [{
                type: ContentChild,
                args: [EventTemplateDirective, { static: false }]
            }], agendaTimeTemplate: [{
                type: ContentChild,
                args: [AgendaTimeTemplateDirective, { static: false }]
            }], agendaDateTemplate: [{
                type: ContentChild,
                args: [AgendaDateTemplateDirective, { static: false }]
            }] } });

/** @hidden */
const MIDNIGHT_INVARIANT = new Date(1980, 0, 1);
/** @hidden */
const INVARIANT_END = new Date(1980, 0, 2);
/** @hidden */
const MS_PER_SECOND = 1000;
/** @hidden */
const MS_PER_MINUTE = 60 * MS_PER_SECOND;
/** @hidden */
const MS_PER_HOUR = 60 * MS_PER_MINUTE;
/** @hidden */
const MS_PER_DAY = 24 * MS_PER_HOUR;
//probably should calculate this
/** @hidden */
const BORDER_WIDTH = 1;
/** @hidden */
const DEFAULT_EVENT_HEIGHT = 25;
/** @hidden */
const ONGOING_EVENT_CSS_CLASS = 'k-event-ongoing';
/** @hidden */
const DAYS_IN_WEEK_COUNT = 7;
/** @hidden */
const WEEKS_COUNT = 6;

/**
 * @hidden
 */
class ItemMap {
    constructor() {
        this.count = 0;
        this.items = {};
    }
    get first() {
        if (this.count > 0) {
            return this.items[Object.keys(this.items)[0]];
        }
    }
    get last() {
        if (this.count > 0) {
            const keys = Object.keys(this.items);
            return this.items[keys[keys.length - 1]];
        }
    }
    addItem(index, item) {
        if (!this.items[index]) {
            this.count++;
        }
        this.items[index] = item;
    }
    removeItem(index, item) {
        const current = this.items[index];
        if (current === item) {
            delete this.items[index];
            this.count--;
        }
    }
    toArray() {
        return Object.keys(this.items).map(index => this.items[index]);
    }
}

/**
 * @hidden
 */
class BaseSlotService {
    constructor() {
        this.containerSize = 0;
        this.slotsChange = new EventEmitter();
        this.groups = [];
    }
    registerItem(component) {
        const group = this.itemGroup(component);
        group.registerItem(component);
    }
    unregisterItem(component, id) {
        id = id || {
            index: component.index,
            resourceIndex: component.resourceIndex,
            rangeIndex: component.rangeIndex
        };
        const group = this.groups[id.resourceIndex];
        if (group) {
            group.unregisterItem(component, id);
        }
    }
    registerSlot(slot) {
        const group = this.slotGroup(slot);
        group.registerSlot(slot);
    }
    unregisterSlot(slot) {
        const group = this.groups[slot.id.resourceIndex];
        if (group) {
            group.unregisterSlot(slot);
        }
    }
    invalidate() {
        this.clearEmptyGroups();
        this.cleanRanges();
        this.slotsChange.emit();
        this.forEachSlot(slot => {
            slot.invalidate();
        });
    }
    cleanRanges() {
        this.groups.forEach(group => {
            group.cleanRanges();
        });
    }
    clearEmptyGroups() {
        const groups = this.groups;
        let index = this.groups.length - 1;
        while (index > 0 && !groups[index].hasSlots) {
            groups.splice(index, 1);
            index--;
        }
    }
    itemGroup(item) {
        const index = item.resourceIndex;
        if (!this.groups[index]) {
            this.groups[index] = this.createGroup(index);
        }
        return this.groups[index];
    }
    slotGroup(slot) {
        const index = slot.id.resourceIndex;
        if (!this.groups[index]) {
            this.groups[index] = this.createGroup(index);
        }
        return this.groups[index];
    }
    calculateScaleX() {
        if (!isDocumentAvailable()) {
            return;
        }
        const schedulerEl = document.querySelector('.k-scheduler');
        const scaleX = schedulerEl.getBoundingClientRect().width / schedulerEl.offsetWidth;
        return scaleX;
    }
}

//better try to measure this one
const MORE_BUTTON_HEIGHT = 13;
const EVENT_OFFSET = 2;
/**
 * @hidden
 */
let SlotRange$1 = class SlotRange {
    constructor(index) {
        this.index = index;
        this.slotMap = new ItemMap();
        this.itemMap = new ItemMap();
    }
    get slots() {
        return this.slotMap.toArray();
    }
    get items() {
        return this.itemMap.toArray();
    }
    get start() {
        const first = this.slotMap.first;
        if (!first) {
            return null;
        }
        return first.start;
    }
    get end() {
        const last = this.slotMap.last;
        if (!last) {
            return null;
        }
        return addUTCDays(last.end, 1);
    }
    get hasSlots() {
        return this.slotMap.count > 0;
    }
    get hasItems() {
        return this.itemMap.count > 0;
    }
    get firstSlot() {
        return this.slotMap.first;
    }
    get lastSlot() {
        return this.slotMap.last;
    }
    get rect() {
        const first = this.firstSlot.rect;
        const last = this.lastSlot.rect;
        return {
            left: first.left,
            top: first.top,
            width: last.left - first.left + last.width,
            height: last.top - first.top + last.height
        };
    }
    registerItem(component) {
        this.itemMap.addItem(component.item.index, component);
    }
    unregisterItem(component, index) {
        this.itemMap.removeItem(index, component);
    }
    registerSlot(slot) {
        this.slotMap.addItem(slot.id.index, slot);
    }
    unregisterSlot(slot) {
        this.slotMap.removeItem(slot.id.index, slot);
    }
    layout(eventHeight) {
        if (!this.hasItems) {
            return;
        }
        const items = this.items;
        const sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
        const slotItems = {};
        const slots = this.slots;
        sorted.forEach(event => slots
            .filter(slot => intersects(event.item.startTime, event.item.endTime, slot.start, slot.end))
            .forEach(slot => {
            const value = slotItems[slot.key] = slotItems[slot.key] || { events: [], height: slot.linkHeight };
            value.slot = slot;
            const rect = slot.rect;
            const data = event.item.data[event.resourceIndex];
            data.rowIndex = findRowIndex(value.events, data);
            if (value.height + eventHeight + EVENT_OFFSET + MORE_BUTTON_HEIGHT > rect.height || data.hidden) {
                data.hidden = true;
                slot.showMore({ width: rect.width, left: rect.left, top: rect.top + slot.linkHeight + ((data.rowIndex) * (eventHeight + EVENT_OFFSET)) });
            }
            else {
                value.events[data.rowIndex] = event;
                if (!event.rect) {
                    event.rect = {
                        top: rect.top + slot.linkHeight + (data.rowIndex * (eventHeight + EVENT_OFFSET)),
                        left: rect.left,
                        height: eventHeight,
                        width: 0
                    };
                }
                event.rect.width += rect.width + BORDER_WIDTH;
                value.height += eventHeight + EVENT_OFFSET;
            }
        }));
        sorted.forEach(event => {
            if (event.rect) {
                event.rect.width -= BORDER_WIDTH;
            }
            event.reflow();
        });
    }
};
/**
 * @hidden
 */
class MonthResourceGroup {
    constructor(index) {
        this.index = index;
        this.dayRanges = [];
    }
    get hasSlots() {
        return Boolean(this.dayRanges.find(range => range && range.hasSlots));
    }
    registerSlot(slot) {
        const range = this.slotRange(slot);
        range.registerSlot(slot);
    }
    unregisterSlot(slot) {
        const range = this.dayRanges[slot.id.rangeIndex];
        range.unregisterSlot(slot);
        if (!range.hasSlots) {
            delete this.dayRanges[slot.id.rangeIndex];
        }
    }
    registerItem(component) {
        const range = this.dayRanges[component.rangeIndex];
        range.registerItem(component);
    }
    unregisterItem(component, id) {
        const range = this.dayRanges[id.rangeIndex];
        if (range) {
            range.unregisterItem(component, id.index);
        }
    }
    slotRange(slot) {
        const ranges = this.dayRanges;
        const rangeIndex = slot.id.rangeIndex;
        if (!ranges[rangeIndex]) {
            ranges[rangeIndex] = new SlotRange$1(rangeIndex);
        }
        return ranges[rangeIndex];
    }
    forEachRange(callback) {
        for (let i = 0; i < this.dayRanges.length; i++) {
            callback(this.dayRanges[i]);
        }
    }
    cleanRanges() {
        this.dayRanges = this.dayRanges.filter(r => Boolean(r));
    }
}
/**
 * @hidden
 */
class MonthSlotService extends BaseSlotService {
    layout(eventHeight) {
        this.groups.forEach((group) => group.forEachRange(range => range.layout(eventHeight)));
    }
    slotByIndex(slotIndex) {
        const [resourceIndex, rangeIndex, index] = slotIndex.split(':').map(part => parseInt(part, 10));
        return this.groups[resourceIndex].dayRanges[rangeIndex].slots[index];
    }
    forEachSlot(callback) {
        this.groups.forEach((group) => {
            group.dayRanges.forEach(range => {
                range.slots.forEach(slot => callback(slot));
            });
        });
    }
    forEachItem(callback) {
        this.groups.forEach((group) => {
            group.dayRanges.forEach(range => {
                range.items.forEach(viewItem => callback(viewItem));
            });
        });
    }
    createGroup(index) {
        return new MonthResourceGroup(index);
    }
    invalidate() {
        super.invalidate();
        this.forEachItem((viewItem) => {
            const data = viewItem.item.data;
            Object.keys(data).forEach(resourceIndex => {
                data[resourceIndex].hidden = false;
            });
        });
    }
    slotByPosition(x, y) {
        let range;
        this.groups.find((group) => {
            range = group.dayRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
            return range;
        });
        if (range) {
            return range.slots.find(slot => rectContains(slot.rect, x, y, this.calculateScaleX()));
        }
    }
    dragRanges(currentSlot, offset) {
        const start = new Date(currentSlot.start.getTime() - offset.start);
        const end = new Date(currentSlot.start.getTime() + offset.end);
        const group = this.groups[currentSlot.id.resourceIndex];
        const ranges = [];
        group.dayRanges.forEach(range => {
            const slots = range.slots.filter(s => intersects(start, end, s.start, s.end));
            if (slots.length) {
                ranges.push(slots);
            }
        });
        return {
            start,
            end,
            ranges
        };
    }
    groupSlotByPosition(currentSlot, x, y) {
        const range = this.groups[currentSlot.id.resourceIndex].dayRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
        if (range) {
            return range.slots.find(slot => rectContains(slot.rect, x, y, this.calculateScaleX()));
        }
    }
    resizeRanges(currentSlot, task, resizeStart, offset) {
        const group = this.groups[task.resources[0].leafIdx];
        const ranges = [];
        const startDate = task.start.toUTCDate();
        const endDate = task.end.toUTCDate();
        let start, end;
        if (resizeStart) {
            start = currentSlot.start.getTime() + offset.start;
            if (start > endDate.getTime()) {
                start = new Date(Math.min(dateWithTime(endDate, startDate).getTime(), endDate.getTime()));
            }
            end = endDate;
        }
        else {
            start = startDate;
            end = currentSlot.start.getTime() + offset.end;
            if (end < start.getTime()) {
                end = new Date(Math.max(dateWithTime(startDate, endDate).getTime(), start.getTime()));
            }
        }
        group.dayRanges.forEach(range => {
            const slots = range.slots.filter(s => intersects(start, end, s.start, s.end));
            if (slots.length) {
                ranges.push(slots);
            }
        });
        return {
            start: new Date(start),
            end: new Date(end),
            ranges: ranges
        };
    }
}

const last = (arr) => arr[arr.length - 1];
/**
 * @hidden
 */
const createTasks$3 = (periodStart, periodEnd, items, ranges) => {
    const tasks = [];
    const utcStart = toUTCDate(periodStart);
    const utcEnd = toUTCDate(periodEnd);
    for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const data = {};
        const startTime = item.start.toUTCDate();
        const end = item.end;
        const endTime = (item.end.getTime() !== end.getTime() ? end.addDays(1) : end).toUTCDate();
        if (intersects(startTime, endTime, utcStart, utcEnd)) {
            for (let rangeIdx = 0; rangeIdx < ranges.length; rangeIdx++) {
                const range = ranges[rangeIdx];
                const rangeStart = toUTCDate(range[0]);
                const rangeEnd = addUTCDays(toUTCDate(last(range)), 1);
                if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
                    const task = {
                        index,
                        startTime,
                        endTime,
                        start: item.start,
                        end: item.end,
                        event: item.event,
                        isAllDay: item.event.isAllDay,
                        rangeIndex: rangeIdx,
                        data: data
                    };
                    tasks.push(task);
                    task.head = task.endTime > rangeEnd;
                    task.tail = task.startTime < rangeStart;
                }
            }
        }
    }
    return sortTasksByTime(tasks);
};
function clearTaskData(task) {
    const data = task.data;
    for (const key in data) {
        if (data.hasOwnProperty(key)) {
            delete data[key];
        }
    }
}
/**
 * @hidden
 */
function updateTaskData(tasks) {
    for (let idx = 0; idx < tasks.length; idx++) {
        const task = tasks[idx];
        const resources = task.resources;
        clearTaskData(task);
        for (let resourceIdx = 0; resourceIdx < resources.length; resourceIdx++) {
            task.data[resources[resourceIdx].leafIdx] = {};
        }
    }
}

/**
 * @hidden
 */
class HintContainerComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.changeDetector.detach();
    }
    detectChanges() {
        this.changeDetector.detectChanges();
    }
}
HintContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: HintContainerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
HintContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: HintContainerComponent, isStandalone: true, selector: "kendo-hint-container", queries: [{ propertyName: "hintTemplate", first: true, predicate: TemplateRef, descendants: true }], ngImport: i0, template: `
        <ng-container [ngTemplateOutlet]="hintTemplate">
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: HintContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-hint-container',
                    template: `
        <ng-container [ngTemplateOutlet]="hintTemplate">
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { hintTemplate: [{
                type: ContentChild,
                args: [TemplateRef, { static: false }]
            }] } });

const SCROLL_CHANGE = 15;
const MIN_DISTANCE = 60;
const SCROLL_INTERVAL = 50;
const MIN_MOVE_DISTANCE = 10;
/** @hidden */
class BaseView {
    constructor(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, cdr, scrollBarWidthService) {
        this.viewContext = viewContext;
        this.viewState = viewState;
        this.intl = intl;
        this.slotService = slotService;
        this.zone = zone;
        this.renderer = renderer;
        this.element = element;
        this.pdfService = pdfService;
        this.localization = localization;
        this.cdr = cdr;
        this.scrollBarWidthService = scrollBarWidthService;
        /**
         * The non-all-day events.
         */
        this.items = new BehaviorSubject(null);
        this.horizontalResources = [];
        this.verticalResources = [];
        this.dragHints = [];
        this.resizeHints = [];
        this.getField = getField;
        this.changes = new BehaviorSubject(null);
        this.viewRangeChange = new BehaviorSubject(null);
        this.subs = new Subscription();
        this.groupedResources = [];
        this.spans = [];
        this.domEvents = [];
        this.resourcesCache = {};
        /**
         * The slot which is currently being dragged over while selecting a range of slots.
         */
        this.dragSelecting = null;
        /**
         * The slot where the drag-selecting originated. Used for flipping the start and end of the emitted range.
         */
        this.dragSelectOrigin = null;
        this.autoHeight = false;
        this.rtl = false;
        this.isSlotSelected = () => false;
        this.setSlotClass = this.setSlotClass.bind(this);
        this.setHintClass = this.setHintClass.bind(this);
        this.weekStart = intl.firstDay();
    }
    get eventTemplateRef() {
        return this.eventTemplate || (this.schedulerEventTemplate || {}).templateRef;
    }
    get groupHeaderTemplateRef() {
        return this.groupHeaderTemplate || (this.schedulerGroupHeaderTemplate || {}).templateRef;
    }
    /**
     * Generates a list of space-separated IDs based on a collection of items to associate scrollable containers
     * with the respective tasks through the aria-owns attribute for a11y compliance.
     */
    matchOwned(items) {
        const ids = items.reduce((acc, curr) => [...acc, ...curr.resources.map(ir => `${curr.elementId}_${ir.leafIdx}`)], []);
        return ids.join(' ');
    }
    ngOnInit() {
        const updateView = this.updateView.bind(this);
        this.resourcesByIndex = this.resourcesByIndex.bind(this);
        this.subs.add(this.viewContext.selectedDate.subscribe(this.onSelectDate.bind(this)));
        this.subs.add(this.viewState.optionsChange.subscribe(this.onStateOptionsChange.bind(this)));
        this.subs.add(this.viewContext.action.subscribe(this.onAction.bind(this)));
        this.subs.add(this.viewContext.execute.subscribe(this.execute.bind(this)));
        this.subs.add(this.viewContext.resize.subscribe(() => {
            this.toggleElement(false);
            this.updateView();
        }));
        this.subs.add(this.viewContext.optionsChange.subscribe(this.optionsChange.bind(this)));
        this.subs.add(this.changes.subscribe(() => {
            this.toggleElement(false);
        }));
        this.subs.add(combineLatest(this.viewContext.items, this.viewState.dateRange, this.viewRangeChange)
            .pipe(map(([items, dateRange]) => this.createTasks(items, dateRange)))
            .subscribe((tasks) => {
            this.tasks = tasks.map(t => ({ ...t, elementId: guid() }));
            this.assignResources();
            this.onTasksChange();
        }));
        this.subs.add(combineLatest(this.items, this.changes, this.localization.changes).pipe(switchMap(() => this.onStable()))
            .subscribe(updateView));
        this.subs.add(this.pdfService.createElement.subscribe(this.createPDFElement.bind(this)));
    }
    ngOnChanges(changes) {
        if (anyChanged(['selectedDateFormat', 'selectedShortDateFormat'], changes)) {
            this.viewState.notifyDateRange(this.dateRange(this.selectedDate));
        }
        if (changes.eventHeight) {
            this.changes.next(null);
        }
    }
    ngAfterViewInit() {
        this.bindEvents();
        this.subs.add(this.localization.changes.subscribe(({ rtl }) => {
            this.rtl = rtl;
        }));
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        this.domEvents.forEach(unbindHandler => unbindHandler());
        this.domEvents = [];
        if (this.draggable) {
            this.draggable.destroy();
            this.draggable = null;
        }
    }
    itemIndex(index, _) {
        return index;
    }
    resourcesByIndex(index) {
        if (!this.resources) {
            return [];
        }
        if (!this.group) { // When we have resources, but are not grouped, return all resources.
            return this.resources.reduce((result, resource) => result.concat(resource.data || []), []);
        }
        if (!this.resourcesCache[index]) {
            const resources = this.taskResources;
            const result = [];
            let currentIndex = index;
            for (let idx = 0; idx < resources.length; idx++) {
                const data = resources[idx].data || [];
                const dataIdx = Math.floor(currentIndex / this.spans[idx]);
                result.push(data[dataIdx]);
                currentIndex -= dataIdx * this.spans[idx];
            }
            this.resourcesCache[index] = result;
        }
        return this.resourcesCache[index];
    }
    dragResourcesByIndex(index) {
        const allResources = this.resources || [];
        const result = [];
        if (this.groupedResources.length) {
            const resources = this.resourcesByIndex(index).slice(0);
            const taskResources = this.taskResources;
            for (let idx = 0; idx < taskResources.length; idx++) {
                const index = this.resources.indexOf(taskResources[idx]);
                if (index >= 0) {
                    result[index] = resources[idx];
                }
            }
        }
        for (let idx = 0; idx < allResources.length; idx++) {
            if (!result[idx]) {
                result[idx] = resourceItemByValue(this.dragging.task.event, allResources[idx]);
            }
        }
        return result;
    }
    getEventClasses(item, resources, isAllDay) {
        if (this.eventClass) {
            return this.eventClass({
                event: item.event,
                resources,
                isAllDay
            });
        }
    }
    getEventStyles(item, itemResource, isAllDay) {
        const result = { backgroundColor: itemResource.color, borderColor: itemResource.color };
        if (this.eventStyles) {
            Object.assign(result, this.eventStyles({
                event: item.event,
                resources: itemResource.resources,
                isAllDay
            }));
        }
        return result;
    }
    // Similar to https://tc39.es/proposal-temporal/docs/plaindate.html
    // Stores a "plain date" in the UTC parts of a regular `Date`.
    toPlainDate(date) {
        const result = toUTCDateTime(this.convertDate(date));
        return result;
    }
    // Similar to https://tc39.es/proposal-temporal/docs/plaindatetime.html
    // Stores a "plain date-time" in the UTC parts of a regular `Date`.
    toPlainDateTime(date, time) {
        if (!date || !time) {
            return null;
        }
        return this.toPlainDate(dateWithTime(date, time));
    }
    optionsChange(options) {
        this.schedulerEventTemplate = options.eventTemplate;
        this.schedulerGroupHeaderTemplate = options.groupHeaderTemplate;
        this.min = options.min;
        this.max = options.max;
        this.editable = options.editable;
        this.timezone = options.timezone;
        this.selectable = options.selectable;
        this.isSlotSelected = options.isSlotSelected;
        if (!options.changes || anyChanged(['group', 'resources'], options.changes, false) ||
            options.group !== this.group || options.resources !== this.resources) {
            this.group = options.group;
            this.resources = options.resources;
            this.groupResources();
            this.resourcesCache = {};
            if (this.tasks && this.tasks.length) {
                this.assignResources();
                this.onTasksChange();
            }
            this.changes.next(null);
        }
        this.onStateOptionsChange(options);
    }
    toggleElement(visible) {
        if (this.element) {
            this.renderer.setStyle(this.element.nativeElement, 'display', visible ? 'block' : 'none');
        }
    }
    onStable() {
        return this.zone.onStable.asObservable().pipe(take(1));
    }
    updateView() {
        this.slotService.invalidate();
        this.toggleElement(true);
        this.reflow();
        this.viewState.notifyLayoutEnd();
        this.viewState.emitEvent(slotDragEventName.refreshSlotSelection);
    }
    assignResources() {
        assignTasksResources(this.tasks, {
            taskResources: this.taskResources,
            hasGroups: this.groupedResources.length > 0,
            allResources: this.resources,
            spans: this.spans
        });
    }
    bindEvents() {
        const contentElement = this.content.nativeElement;
        const element = this.element.nativeElement;
        this.zone.runOutsideAngular(() => {
            if (this.times) {
                this.subs.add(merge(fromEvent(this.times.nativeElement, 'mousewheel'), fromEvent(this.times.nativeElement, 'DOMMouseScroll')).pipe(filter((event) => !event.ctrlKey), tap(preventLockedScroll(contentElement)), map(wheelDeltaY))
                    .subscribe(x => contentElement.scrollTop -= x));
            }
            this.subs.add(merge(fromClick(contentElement), fromEvent(contentElement, 'contextmenu'))
                .subscribe(e => this.onClick(e)));
            this.subs.add(fromDoubleClick(contentElement)
                .subscribe(e => this.onClick(e, 'dblclick')));
            this.subs.add(fromEvent(element, 'keydown')
                .subscribe(e => this.onKeydown(e)));
            this.domEvents.push(this.renderer.listen(contentElement, 'scroll', () => {
                if (this.headerWrap) {
                    this.headerWrap.nativeElement.scrollLeft = contentElement.scrollLeft;
                }
                if (this.times) {
                    this.times.nativeElement.scrollTop = contentElement.scrollTop;
                }
            }));
            this.draggable = new Draggable({
                press: this.onPress.bind(this),
                drag: this.onDrag.bind(this),
                release: this.onRelease.bind(this)
            });
            this.draggable.bindTo(element);
        });
    }
    onPress(args) {
        const editResizable = this.editable && this.editable.resize !== false;
        const editDraggable = this.editable && this.editable.drag !== false;
        const target = args.originalEvent.target;
        if (hasClasses(target, 'k-resize-handle')) {
            if (!editResizable) {
                return;
            }
            this.initResize(args);
        }
        else if (editDraggable) {
            const task = this.targetTask(target);
            if (task) {
                if (!args.isTouch) {
                    args.originalEvent.preventDefault();
                }
                this.pressLocation = { x: args.pageX, y: args.pageY };
                this.pressTarget = task;
            }
        }
        const notDraggingEvent = !this.pressTarget;
        if (notDraggingEvent && this.selectable) {
            this.initDragSelect(args);
        }
        this.dragArgs = args;
    }
    onDrag(args) {
        if (this.resizing) {
            this.resize(args);
            this.scrollContainer(this.resize, args);
        }
        else {
            this.initDrag(args);
            if (this.dragging) {
                this.drag(args);
                args.originalEvent.preventDefault();
                this.scrollContainer(this.drag, args);
            }
            if (this.dragSelecting) {
                this.dragSelect(args);
            }
        }
        this.dragArgs = args;
    }
    onRelease(args) {
        clearInterval(this.scrollInterval);
        const { resizing, dragging, dragSelecting } = this;
        if (resizing) {
            this.emitEvent('resizeEnd', {
                event: resizing.task.event,
                dataItem: resizing.task.event.dataItem,
                start: this.convertDate(resizing.start),
                end: this.convertDate(resizing.end)
            });
            this.resizeHints = [];
        }
        if (dragging) {
            this.emitEvent('dragEnd', {
                event: dragging.task.event,
                dataItem: dragging.task.event.dataItem,
                start: dragging.start ? this.convertDate(dragging.start) : dragging.task.start.toLocalDate(),
                end: dragging.end ? this.convertDate(dragging.end) : dragging.task.end.toLocalDate(),
                resources: dragging.resources,
                isAllDay: this.draggedIsAllDay(dragging.task, dragging.slot)
            });
            this.dragHints = [];
        }
        if (resizing || dragging) {
            this.removeSlotClass();
            this.updateHintContainer();
            this.resizing = null;
            this.dragging = null;
        }
        if (dragSelecting) {
            const { start, end } = normaliseRangeStartAndEnd(this.dragSelectOrigin, this.dragSelecting);
            const range = {
                start: this.convertDate(start),
                end: this.convertDate(end),
                isAllDay: this.dragSelecting.isDaySlot,
                resources: this.resourcesByIndex(this.dragSelecting.id.resourceIndex),
                originalEvent: args.originalEvent
            };
            this.viewState.notifySlotSelectionEnd(range);
            this.dragSelectOrigin = null;
            this.dragSelecting = null;
            this.cdr.markForCheck();
        }
        this.container = null;
        this.dragArgs = null;
        this.pressLocation = null;
        this.pressTarget = null;
    }
    setHintClass(className) {
        (this.dragging || this.resizing).hintClass = className;
    }
    updateHintClass() {
        const current = this.dragging || this.resizing;
        let update = false;
        this.hints.forEach(hint => {
            if (hint.class !== current.hintClass) {
                hint.class = current.hintClass;
                update = true;
            }
        });
        if (update) {
            this.updateHintContainer();
        }
    }
    removeHintClass() {
        (this.dragging || this.resizing).hintClass = null;
    }
    setSlotClass(className) {
        const current = this.dragging || this.resizing;
        current.slotClass = className;
        this.renderer.addClass(current.slot.nativeElement, current.slotClass);
    }
    removeSlotClass() {
        const current = this.dragging || this.resizing;
        if (current.slotClass) {
            this.renderer.removeClass(current.slot.nativeElement, current.slotClass);
            current.slotClass = null;
        }
    }
    get hints() {
        return this.dragging ? this.dragHints : this.resizeHints;
    }
    initDrag(args) {
        if (!this.dragging && this.pressLocation && pointDistance(this.pressLocation.x, this.pressLocation.y, args.pageX, args.pageY) >= MIN_MOVE_DISTANCE) {
            const dragging = this.pressTarget;
            const task = dragging.task;
            if (this.emitEvent('dragStart', { event: task.event, dataItem: task.event.dataItem })) {
                this.pressLocation = null;
                this.pressTarget = null;
                return;
            }
            this.updateDragContainer(args);
            if (this.containerOffset === undefined) {
                return;
            }
            const { x, y } = this.coordinatesOffset(this.pressLocation.x, this.pressLocation.y);
            const slot = this.slotByPosition(Math.ceil(x), Math.ceil(y), this.container);
            if (!slot) {
                return;
            }
            this.dragging = dragging;
            this.dragging.offset = {
                start: slot.start.getTime() - task.start.toUTCDate().getTime(),
                end: task.end.toUTCDate().getTime() - slot.start.getTime()
            };
            this.dragging.slot = slot;
            this.dragging.startResources = this.dragging.resourceItems = this.dragResourcesByIndex(slot.id.resourceIndex);
            this.dragging.resources = this.resourceValues(task, this.dragging.startResources);
        }
    }
    updateDragContainer(_args) {
        if (!this.container) {
            this.container = this.content.nativeElement;
            this.containerOffset = elementOffset(this.container);
        }
    }
    drag(args) {
        this.updateDragContainer(args);
        if (!this.container) {
            return;
        }
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const slot = this.slotByPosition(x, y, this.container);
        if (slot && (slot !== this.dragging.slot || !this.dragHints.length)) {
            const dragging = this.dragging;
            const { slot: currentSlot, task } = dragging;
            const { ranges, start, end, isAllDay } = this.dragRanges(slot);
            let resourceItems, resourceValues;
            if (currentSlot.id.resourceIndex !== slot.id.resourceIndex) {
                resourceItems = this.dragResourcesByIndex(slot.id.resourceIndex);
                resourceValues = this.resourceValues(task, resourceItems);
            }
            else {
                resourceItems = dragging.resourceItems;
                resourceValues = dragging.resources;
            }
            this.removeSlotClass();
            dragging.start = start;
            dragging.end = end;
            dragging.slot = slot;
            dragging.resources = resourceValues;
            dragging.resourceItems = resourceItems;
            dragging.hintClass = null;
            if (this.emitEvent('drag', {
                event: task.event,
                dataItem: task.event.dataItem,
                start: this.convertDate(start),
                end: this.convertDate(end),
                resources: resourceValues,
                isAllDay,
                setHintClass: this.setHintClass,
                setSlotClass: this.setSlotClass
            })) {
                this.updateHintClass();
                return;
            }
            const color = this.dragResourceColor(task, resourceItems);
            const hintClasses = this.dragHintClasses();
            this.dragHints = [];
            for (let idx = 0; idx < ranges.length; idx++) {
                const slots = ranges[idx];
                const first = slots[0];
                const last = slots[slots.length - 1];
                const size = this.dragHintSize(first, last);
                const origin = first.rect.left;
                const styles = {
                    top: toPx(first.rect.top),
                    left: this.localization.rtl ? '' : toPx(origin),
                    right: !this.localization.rtl ? '' : toPx(origin),
                    width: size.width,
                    height: size.height,
                    backgroundColor: color,
                    borderColor: color
                };
                if (this.eventStyles) {
                    Object.assign(styles, this.eventStyles(this.dragHintEventStyleArgs()));
                }
                this.dragHints.push({
                    item: Object.assign({}, this.dragging.task, {
                        startTime: start,
                        endTime: end
                    }),
                    resources: resourceItems,
                    class: hintClasses,
                    style: styles
                });
            }
            this.updateHintContainer();
        }
    }
    initDragSelect(args) {
        this.updateDragContainer(args);
        if (!this.containerOffset) {
            return;
        }
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const slot = this.slotByPosition(x, y, this.container);
        if (!slot) {
            return;
        }
        const range = {
            start: this.convertDate(slot.start),
            end: this.convertDate(slot.end),
            isAllDay: slot.isDaySlot,
            resources: this.resourcesByIndex(slot.id.resourceIndex),
            originalEvent: args.originalEvent
        };
        const slotDragStartEvent = new SlotDragStartEvent(null, range);
        this.viewState.notifySlotSelectionStart(slotDragStartEvent);
        if (!slotDragStartEvent.isDefaultPrevented()) {
            this.dragSelecting = slot;
            this.dragSelectOrigin = slot;
            this.cdr.markForCheck();
        }
    }
    dragSelect(args) {
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const slot = this.slotByPosition(x, y, this.container);
        if (!slot) {
            return;
        }
        if (this.dragSelecting !== slot) {
            this.dragSelecting = slot;
            const { start, end } = normaliseRangeStartAndEnd(this.dragSelectOrigin, this.dragSelecting);
            const range = {
                start: this.convertDate(start),
                end: this.convertDate(end),
                isAllDay: slot.isDaySlot,
                resources: this.resourcesByIndex(slot.id.resourceIndex),
                originalEvent: args.originalEvent
            };
            this.viewState.notifySlotSelectionDrag(range);
            this.cdr.markForCheck();
        }
    }
    dragHintClasses() {
        const hintClass = this.dragging.hintClass;
        let result = [];
        if (hintClass) {
            result.push(hintClass);
        }
        if (this.eventClass) {
            const eventClass = this.eventClass(this.dragHintEventStyleArgs());
            result = result.concat(convertNgClassBindings(eventClass));
        }
        return result;
    }
    dragHintEventStyleArgs() {
        return {
            event: this.dragging.task.event,
            resources: this.dragging.resourceItems
        };
    }
    draggedIsAllDay(task, _slot) {
        return Boolean(task.event.isAllDay);
    }
    dragResourceColor(task, slotResources) {
        if (this.groupedResources.length) {
            const index = this.resources.indexOf(this.groupedResources[0]);
            return getField(slotResources[index], this.groupedResources[0].colorField);
        }
        else if (this.resources && this.resources.length) {
            return task.resources[0].color;
        }
        return '';
    }
    resourceValues(task, currentResources) {
        const result = {};
        for (let idx = 0; idx < currentResources.length; idx++) {
            const resource = this.resources[idx];
            const resourceItem = currentResources[idx];
            let value;
            if (Array.isArray(resourceItem)) { // not grouped multiple resource
                value = getField(task.event, resource.field);
            }
            else {
                value = getField(currentResources[idx], resource.valueField);
                if (resource.multiple) {
                    const startValue = getField(this.dragging.startResources[idx], resource.valueField);
                    if (startValue !== value) {
                        value = [value];
                    }
                    else {
                        value = getField(task.event.dataItem, resource.field);
                    }
                }
            }
            setField(result, resource.field, value);
        }
        return result;
    }
    initResize(args) {
        args.originalEvent.preventDefault();
        const target = args.originalEvent.target;
        const resizing = this.targetTask(target);
        if (this.emitEvent('resizeStart', { event: resizing.task.event, dataItem: resizing.task.event.dataItem })) {
            return;
        }
        this.resizing = resizing;
        resizing.start = resizing.task.start.toUTCDate();
        resizing.end = resizing.task.end.toUTCDate();
        if (hasClasses(target, 'k-resize-n')) {
            resizing.direction = 'n';
        }
        else if (hasClasses(target, 'k-resize-s')) {
            resizing.direction = 's';
        }
        else if (hasClasses(target, 'k-resize-w')) {
            resizing.direction = 'w';
        }
        else {
            resizing.direction = 'e';
        }
        this.updateDragContainer(args);
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        resizing.slot = this.slotByPosition(Math.ceil(x), Math.ceil(y), this.container);
        resizing.offset = {
            start: resizing.task.start.toUTCDate().getTime() - resizing.slot.start.getTime(),
            end: resizing.task.end.toUTCDate().getTime() - resizing.slot.start.getTime()
        };
    }
    resize(args) {
        const { x, y } = this.coordinatesOffset(args.pageX, args.pageY);
        const resizing = this.resizing;
        const { direction, task, offset } = resizing;
        const slot = this.slotService.groupSlotByPosition(resizing.slot, x, y);
        if (!slot || slot === resizing.slot) {
            return;
        }
        this.removeSlotClass();
        const { start, end, ranges } = this.slotService.resizeRanges(slot, task, direction === 'w' || direction === 'n', offset);
        resizing.hintClass = null;
        resizing.start = start;
        resizing.end = end;
        resizing.slot = slot;
        if (this.emitEvent('resize', {
            event: task.event,
            dataItem: task.event.dataItem,
            start: this.convertDate(start),
            end: this.convertDate(end),
            setHintClass: this.setHintClass,
            setSlotClass: this.setSlotClass
        })) {
            this.updateHintClass();
            return;
        }
        this.updateResizeHints(ranges, start, end);
        this.updateHintContainer();
    }
    updateResizeHints(ranges, _start, _end) {
        const resizing = this.resizing;
        const direction = resizing.direction;
        const horizontal = direction === 'w' || direction === 'e';
        const resizeStart = direction === 'w' || direction === 'n';
        this.resizeHints = [];
        for (let idx = 0; idx < ranges.length; idx++) {
            const range = ranges[idx];
            const firstSlot = range[0];
            const lastSlot = range[range.length - 1];
            const first = idx === 0;
            const last = idx === ranges.length - 1;
            this.resizeHints.push({
                first: first,
                last: last,
                rect: {
                    left: firstSlot.rect.left,
                    top: firstSlot.top,
                    height: horizontal ? firstSlot.height : Math.abs(lastSlot.rect.top - firstSlot.rect.top) + lastSlot.rect.height,
                    width: horizontal ? Math.abs(lastSlot.rect.left - firstSlot.rect.left) + lastSlot.rect.width : firstSlot.width
                },
                start: first && !resizeStart ? resizing.start : firstSlot.start,
                end: last && resizeStart ? resizing.end : lastSlot.end,
                class: resizing.hintClass
            });
        }
    }
    coordinatesOffset(x, y, container = this.container, offset = this.containerOffset) {
        const position = x - offset.left + container.scrollLeft;
        return {
            x: !this.localization.rtl ? position : this.slotService.containerSize - position,
            y: y - offset.top + container.scrollTop
        };
    }
    scrollContainer(callback, args) {
        clearInterval(this.scrollInterval);
        const container = this.container;
        if (!container) {
            return;
        }
        const viewPortY = args.pageY - this.containerOffset.top;
        const pointerYDistance = Math.abs(container.offsetHeight - viewPortY);
        const deltaY = args.pageY - this.dragArgs.pageY;
        const viewPortX = args.pageX - this.containerOffset.left;
        const pointerXDistance = Math.abs(container.offsetWidth - viewPortX);
        const deltaX = args.pageX - this.dragArgs.pageX;
        let scroll = false;
        let leftChange = 0;
        let topChange = 0;
        if (pointerYDistance < MIN_DISTANCE && container.scrollTop + container.offsetHeight < container.scrollHeight && deltaY > 0) {
            scroll = true;
            topChange = SCROLL_CHANGE;
            this.container.scrollTop += MIN_DISTANCE - pointerYDistance;
        }
        else if (viewPortY < MIN_DISTANCE && container.scrollTop > 0 && deltaY < 0) {
            scroll = true;
            topChange = -SCROLL_CHANGE;
            this.container.scrollTop -= MIN_DISTANCE - viewPortY;
        }
        if (pointerXDistance < MIN_DISTANCE && container.scrollLeft + container.offsetWidth < container.scrollWidth && deltaX > 0) {
            scroll = true;
            leftChange = SCROLL_CHANGE;
            this.container.scrollLeft += MIN_DISTANCE - pointerXDistance;
        }
        else if (viewPortX < MIN_DISTANCE && container.scrollLeft > 0 && deltaY < 0) {
            scroll = true;
            leftChange = -SCROLL_CHANGE;
            this.container.scrollLeft -= MIN_DISTANCE - viewPortX;
        }
        if (scroll) {
            this.scrollInterval = setInterval(() => {
                if (this.container) {
                    this.container.scrollLeft += leftChange;
                    this.container.scrollTop += topChange;
                    callback.call(this, args);
                }
                else {
                    clearInterval(this.scrollInterval);
                }
            }, SCROLL_INTERVAL);
        }
    }
    emitEvent(name, args) {
        this.viewState.emitEvent(name, args);
        return args.prevented;
    }
    targetTask(target) {
        const eventTarget = closestInScope(target, node => node.hasAttribute('data-task-index'), this.element.nativeElement);
        if (eventTarget) {
            const index = parseInt(eventTarget.getAttribute('data-task-index'), 10);
            return {
                target: eventTarget,
                task: this.tasks.find(t => t.index === index)
            };
        }
    }
    updateHintContainer() {
        if (this.hintContainer) {
            this.hintContainer.detectChanges();
        }
    }
    /**
     * Converts a "view date" (date stored in the UTC parts of a Date object) to a local date.
     */
    convertDate(date) {
        return ZonedDate.fromUTCDate(date, this.timezone).toLocalDate();
    }
    onClick(e, eventType = e.type) {
        this.emitSlotEvent(e, eventType);
        this.emitTaskEvent(e, eventType);
    }
    emitSlotEvent(e, eventType) {
        const targetSlot = closestInScope(e.target, node => node.hasAttribute('data-slot-index'), this.element.nativeElement);
        if (targetSlot) {
            const slotIndex = targetSlot.getAttribute('data-slot-index');
            const name = eventType === 'dblclick' ? 'slotDblClick' : 'slotClick';
            const slot = this.slotByIndex(slotIndex, e);
            this.viewState.emitEvent(name, {
                type: eventType,
                slot: slot,
                start: this.convertDate(slot.start),
                end: this.convertDate(slot.end),
                isAllDay: slot.isDaySlot,
                originalEvent: e,
                resources: this.resources && this.resources.length ?
                    this.resourcesByIndex(slot.id.resourceIndex) : []
            });
        }
    }
    emitTaskEvent(e, eventType) {
        const targetTask = this.targetTask(e.target);
        if (targetTask) {
            const task = targetTask.task;
            const isSingle = eventType === 'click';
            const isDouble = eventType === 'dblclick';
            if (isSingle && closestInScope(e.target, node => hasClasses(node, 'k-event-delete'), targetTask.target)) {
                this.viewState.emitEvent('remove', { event: task.event, dataItem: task.event.dataItem });
            }
            else {
                const name = isDouble ? 'eventDblClick' : 'eventClick';
                this.viewState.emitEvent(name, { type: eventType, event: task.event, originalEvent: e });
                targetTask.target.focus();
            }
        }
    }
    onKeydown(e) {
        const targetTask = this.targetTask(e.target);
        if (targetTask) {
            const task = targetTask.task;
            this.viewState.emitEvent('eventKeydown', { event: task.event, dataItem: task.event.dataItem, originalEvent: e });
        }
    }
    syncTables() {
        if (this.timesTable) {
            this.renderer.setStyle(this.timesTable.nativeElement, 'height', `${this.contentTable.nativeElement.offsetHeight}px`);
        }
        // Need to explicitly set 'padding-inline-xxx' to 0px when the Scheduler has no height set
        if (!hasScrollbar(this.content.nativeElement, 'vertical')) {
            this.renderer.setStyle(this.header.nativeElement, !this.localization.rtl ? 'padding-inline-end' : 'padding-inline-start', '0px');
        }
        this.renderer.removeStyle(this.header.nativeElement, this.localization.rtl ? 'padding-inline-end' : 'padding-inline-start');
        if (this.times) {
            const times = this.times.nativeElement;
            this.timesHeader.nativeElement.style.width = `${times.offsetWidth}px`;
            const contentHeight = this.contentHeight === 'auto' ? this.content.nativeElement.offsetHeight : this.contentHeight;
            this.renderer.setStyle(times, 'height', `${contentHeight - (hasScrollbar(this.content.nativeElement, 'horizontal') ? scrollbarWidth() : 0)}px`);
            times.scrollTop = this.content.nativeElement.scrollTop;
        }
    }
    updateContentHeight() {
        const element = this.element.nativeElement;
        const parent = element.parentNode;
        const content = this.content.nativeElement;
        const autoHeight = this.autoHeight || !parent?.style.height;
        const scrollLeft = content.scrollLeft;
        const scrollTop = content.scrollTop;
        this.renderer.setStyle(content, 'height', '');
        if (this.times) {
            this.renderer.setStyle(this.times.nativeElement, 'height', '');
        }
        if (autoHeight) {
            this.contentHeight = 'auto';
            return;
        }
        let height = parent.clientHeight;
        for (let idx = 0; idx < parent.children.length; idx++) {
            const child = parent.children[idx];
            if (child !== element && !ignoreContentChild(child)) {
                height -= child.offsetHeight;
            }
        }
        height -= this.headerWrap ? this.headerWrap.nativeElement.offsetHeight : 0;
        this.renderer.setStyle(content, 'height', `${height}px`);
        this.contentHeight = height;
        content.scrollLeft = scrollLeft;
        content.scrollTop = scrollTop;
    }
    groupResources() {
        const resources = this.resources || [];
        const group = this.group || {};
        this.groupedResources = groupResources(group, resources);
        if (group.orientation !== 'vertical') {
            this.horizontalResources = this.groupedResources;
            this.verticalResources = [];
        }
        else {
            this.verticalResources = this.groupedResources;
            this.horizontalResources = [];
        }
        this.spans = this.resourceSpans();
    }
    get taskResources() {
        if (this.groupedResources.length) {
            return this.groupedResources;
        }
        else if (this.resources && this.resources.length) {
            return [this.resources[0]];
        }
        else {
            return [{}];
        }
    }
    resourceSpans() {
        const spans = [1];
        const resources = this.groupedResources;
        let span = 1;
        for (let idx = resources.length - 1; idx > 0; idx--) {
            span *= ((resources[idx].data || []).length || 1);
            spans.unshift(span);
        }
        return spans;
    }
    isInRange(date) {
        const dateRange = this.dateRange(date);
        return (!this.min || this.min < dateRange.end) && (!this.max || dateRange.start <= this.max);
    }
    createPDFElement() {
        const contentHeight = this.contentHeight;
        const scrollTop = this.content.nativeElement.scrollTop;
        if (contentHeight !== 'auto') {
            this.autoHeight = true;
            this.updateView();
        }
        const element = this.element.nativeElement.cloneNode(true);
        element.style.width = `${this.pdfWidth()}px`;
        if (contentHeight !== 'auto') {
            this.autoHeight = false;
            this.updateView();
        }
        this.pdfService.elementReady.emit({
            element: element
        });
        this.content.nativeElement.scrollTop = scrollTop;
    }
    pdfWidth() {
        return this.element.nativeElement.offsetWidth;
    }
    containerByPosition({ x, y }) {
        const content = this.content.nativeElement;
        const offset = elementOffset(content);
        if (offset.top <= y && y <= offset.top + offset.height && offset.left <= x && x <= offset.left + offset.width) {
            return {
                element: content,
                offset: offset
            };
        }
    }
    execute(e) {
        if (e.name === 'slotByPosition') {
            const container = this.containerByPosition(e.args);
            if (container) {
                const offset = this.coordinatesOffset(e.args.x, e.args.y, container.element, container.offset);
                const slot = this.slotByPosition(offset.x, offset.y, container.element);
                e.result(this.slotFields(slot));
            }
        }
        else if (e.name === 'eventFromElement') {
            const target = this.targetTask(e.args.element);
            if (target) {
                e.result(target.task.event);
            }
        }
    }
    slotFields(slot) {
        return {
            element: slot.element,
            resources: this.groupedResources.length ? this.resourcesByIndex(slot.id.resourceIndex) : [],
            start: this.convertDate(slot.start),
            end: this.convertDate(slot.end)
        };
    }
    onStateOptionsChange(changes) {
        if (changes?.showFooter || changes?.showToolbar) {
            this.zone.onStable.pipe(take(1)).subscribe(() => this.updateView());
        }
    }
}
BaseView.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseView, deps: [{ token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: BaseSlotService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: PDFService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: i7.ScrollbarWidthService }], target: i0.ɵɵFactoryTarget.Directive });
BaseView.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: BaseView, inputs: { eventTemplate: "eventTemplate", groupHeaderTemplate: "groupHeaderTemplate", selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", eventHeight: "eventHeight", showToolbar: "showToolbar", showFooter: "showFooter", slotClass: "slotClass", eventClass: "eventClass", eventStyles: "eventStyles", weekStart: "weekStart" }, viewQueries: [{ propertyName: "content", first: true, predicate: ["content"], descendants: true }, { propertyName: "header", first: true, predicate: ["header"], descendants: true }, { propertyName: "contentTable", first: true, predicate: ["contentTable"], descendants: true }, { propertyName: "times", first: true, predicate: ["times"], descendants: true }, { propertyName: "timesHeader", first: true, predicate: ["timesHeader"], descendants: true }, { propertyName: "timesTable", first: true, predicate: ["timesTable"], descendants: true }, { propertyName: "headerWrap", first: true, predicate: ["headerWrap"], descendants: true }, { propertyName: "hintContainer", first: true, predicate: ["hintContainer"], descendants: true }], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseView, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: BaseSlotService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: PDFService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: i7.ScrollbarWidthService }]; }, propDecorators: { eventTemplate: [{
                type: Input
            }], groupHeaderTemplate: [{
                type: Input
            }], selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], showToolbar: [{
                type: Input
            }], showFooter: [{
                type: Input
            }], slotClass: [{
                type: Input
            }], eventClass: [{
                type: Input
            }], eventStyles: [{
                type: Input
            }], weekStart: [{
                type: Input
            }], content: [{
                type: ViewChild,
                args: ['content', { static: false }]
            }], header: [{
                type: ViewChild,
                args: ['header', { static: false }]
            }], contentTable: [{
                type: ViewChild,
                args: ['contentTable', { static: false }]
            }], times: [{
                type: ViewChild,
                args: ['times', { static: false }]
            }], timesHeader: [{
                type: ViewChild,
                args: ['timesHeader', { static: false }]
            }], timesTable: [{
                type: ViewChild,
                args: ['timesTable', { static: false }]
            }], headerWrap: [{
                type: ViewChild,
                args: ['headerWrap', { static: false }]
            }], hintContainer: [{
                type: ViewChild,
                args: ['hintContainer', { static: false }]
            }] } });

/**
 * @hidden
 */
class BaseViewItem {
    constructor(slotService, localization, focusService, element, renderer, localeId) {
        this.slotService = slotService;
        this.localization = localization;
        this.focusService = focusService;
        this.element = element;
        this.renderer = renderer;
        this.localeId = localeId;
        this.className = true;
        this.caretAltLeftIcon = caretAltLeftIcon;
        this.caretAltRightIcon = caretAltRightIcon;
        this.subs = new Subscription();
    }
    get taskIndex() {
        return this.item.index;
    }
    get touchAction() {
        return this.editable && this.editable.drag !== false ? 'none' : null;
    }
    get eventTitle() {
        const startTime = toLocalDate(this.item.startTime);
        const endTime = toLocalDate(this.item.endTime);
        const time = formatEventTime(startTime, endTime, this.item.isAllDay, this.localeId);
        return `${time}, ${this.item.event.title}`;
    }
    get deleteMessage() {
        return this.localization.get('deleteTitle');
    }
    get resizable() {
        return this.editable && this.editable.resize !== false;
    }
    get removable() {
        return this.editable && this.editable.remove !== false;
    }
    get isRecurrence() {
        return isRecurrence(this.item);
    }
    get isRecurrenceException() {
        return isRecurrenceException(this.item);
    }
    get nativeElement() {
        if (this.element) {
            return this.element.nativeElement;
        }
    }
    setStyles(styles) {
        const element = this.nativeElement;
        if (element) {
            for (const name in styles) {
                if (styles.hasOwnProperty(name)) {
                    this.renderer.setStyle(element, name, styles[name]);
                }
            }
        }
    }
    toggle(visible) {
        this.setStyles({ display: visible ? null : 'none' });
    }
    reflow() {
        const rect = this.rect;
        if (rect) {
            this.setStyles({
                left: !this.localization.rtl ? `${rect.left}px` : '',
                right: this.localization.rtl ? `${rect.left}px` : '',
                top: `${rect.top}px`,
                width: `${rect.width}px`,
                height: `${rect.height}px`
            });
        }
    }
    ngOnInit() {
        if (this.dragHint) {
            return;
        }
        this.subs.add(this.slotService.slotsChange.subscribe(() => {
            this.rect = null;
            this.setStyles({
                width: 0,
                left: 0,
                bottom: 0
            });
            const slotId = { index: this.index, resourceIndex: this.resourceIndex, rangeIndex: this.rangeIndex };
            this.slotService.unregisterItem(this, slotId);
            if (this.resourceIndex >= 0) {
                this.slotService.registerItem(this);
            }
        }));
    }
    ngOnChanges(changes) {
        if (this.dragHint) {
            return;
        }
        if (anyChanged(['index', 'resourceIndex', 'rangeIndex'], changes)) {
            const { resourceIndex, index, rangeIndex } = changes;
            const previousResourceIndex = resourceIndex ? resourceIndex.previousValue : this.resourceIndex;
            const previousIndex = index ? index.previousValue : this.index;
            const previousRangeIndex = rangeIndex ? rangeIndex.previousValue : this.rangeIndex;
            const slotId = {
                index: previousIndex,
                resourceIndex: previousResourceIndex,
                rangeIndex: previousRangeIndex
            };
            this.slotService.unregisterItem(this, slotId);
            if (this.resourceIndex >= 0) {
                this.slotService.registerItem(this);
                this.toggle(true);
            }
            else {
                this.toggle(false);
            }
        }
    }
    ngOnDestroy() {
        if (this.dragHint) {
            return;
        }
        this.slotService.unregisterItem(this);
        this.subs.unsubscribe();
    }
    get arrowIcons() {
        return !this.localization.rtl ? ['caret-alt-left', 'caret-alt-right'] : ['caret-alt-right', 'caret-alt-left'];
    }
    get arrowSVGIcons() {
        return !this.localization.rtl ? [this.caretAltLeftIcon, this.caretAltRightIcon] : [this.caretAltRightIcon, this.caretAltLeftIcon];
    }
}
BaseViewItem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseViewItem, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
BaseViewItem.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: BaseViewItem, inputs: { item: "item", resourceIndex: "resourceIndex", rangeIndex: "rangeIndex", index: "index", eventTemplate: "eventTemplate", editable: "editable", dragHint: "dragHint", resources: "resources" }, host: { properties: { "class.k-event": "this.className", "attr.data-task-index": "this.taskIndex", "style.touch-action": "this.touchAction", "attr.aria-label": "this.eventTitle" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseViewItem, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: BaseSlotService }, { type: i1$1.LocalizationService }, { type: FocusService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: undefined }]; }, propDecorators: { item: [{
                type: Input
            }], resourceIndex: [{
                type: Input
            }], rangeIndex: [{
                type: Input
            }], index: [{
                type: Input
            }], eventTemplate: [{
                type: Input
            }], editable: [{
                type: Input
            }], dragHint: [{
                type: Input
            }], resources: [{
                type: Input
            }], className: [{
                type: HostBinding,
                args: ['class.k-event']
            }], taskIndex: [{
                type: HostBinding,
                args: ['attr.data-task-index']
            }], touchAction: [{
                type: HostBinding,
                args: ['style.touch-action']
            }], eventTitle: [{
                type: HostBinding,
                args: ['attr.aria-label']
            }] } });

/**
 * @hidden
 */
class MonthViewItemComponent extends BaseViewItem {
    constructor(slotService, localization, focusService, element, renderer, localeId) {
        super(slotService, localization, focusService, element, renderer, localeId);
        this.localeId = localeId;
        this.caretAltLeftIcon = caretAltLeftIcon;
        this.caretAltRightIcon = caretAltRightIcon;
        this.arrowRotateCwIcon = arrowRotateCwIcon;
        this.arrowsNoRepeatIcon = arrowsNoRepeatIcon;
        this.xIcon = xIcon;
    }
    reflow() {
        if (this.item.data[this.resourceIndex].hidden) {
            this.toggle(false);
            return;
        }
        else {
            this.toggle(true);
        }
        super.reflow();
    }
}
MonthViewItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewItemComponent, deps: [{ token: MonthSlotService }, { token: i1$1.LocalizationService }, { token: FocusService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
MonthViewItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MonthViewItemComponent, isStandalone: true, selector: "[monthViewItem]", usesInheritance: true, ngImport: i0, template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewItemComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[monthViewItem]',
                    template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: MonthSlotService }, { type: i1$1.LocalizationService }, { type: FocusService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });

class ResourceIterator {
    constructor(resources, lastIndex = resources.length - 1) {
        this.resources = resources;
        this.lastIndex = lastIndex;
    }
    *[iterator]() {
        let resources = this.resources;
        const lastIndex = Math.max(0, this.lastIndex);
        if (!(resources && resources.length)) {
            resources = [{}];
        }
        const lastData = resources[lastIndex].data || [];
        const length = lastData.length;
        let count = 1;
        for (let idx = 0; idx <= lastIndex; idx++) {
            count *= (resources[idx].data || []).length || 1;
        }
        for (let idx = 0; idx < count; idx++) {
            yield lastData[idx % length];
        }
    }
}
/**
 * @hidden
 */
class ResourceIteratorPipe {
    transform(resources = [], lastIndex) {
        return new ResourceIterator(resources, lastIndex);
    }
}
ResourceIteratorPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResourceIteratorPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ResourceIteratorPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: ResourceIteratorPipe, isStandalone: true, name: "resourceIterator" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResourceIteratorPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'resourceIterator',
                    standalone: true
                }]
        }] });

class NumberIterator {
    constructor(count) {
        this.count = count;
    }
    *[iterator]() {
        for (let i = 0; i < this.count; i++) {
            yield i;
        }
    }
}
/**
 * @hidden
 */
class RepeatPipe {
    transform(value) {
        return new NumberIterator(value);
    }
}
RepeatPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RepeatPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
RepeatPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: RepeatPipe, isStandalone: true, name: "repeat" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RepeatPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'repeat',
                    standalone: true
                }]
        }] });

/**
 * @hidden
 */
class ResizeHintComponent {
    constructor() {
        this.marqueeClasses = true;
    }
    get left() {
        return this.hint.rect.left;
    }
    get top() {
        return this.hint.rect.top;
    }
    get width() {
        return this.hint.rect.width;
    }
    get height() {
        return this.hint.rect.height;
    }
    get start() {
        return toLocalDate(this.hint.start);
    }
    get end() {
        return toLocalDate(this.hint.end);
    }
}
ResizeHintComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResizeHintComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ResizeHintComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: ResizeHintComponent, isStandalone: true, selector: "[kendoResizeHint]", inputs: { hint: "hint", format: "format" }, host: { properties: { "class.k-marquee": "this.marqueeClasses", "class.k-scheduler-marquee": "this.marqueeClasses", "class.k-first": "this.marqueeClasses", "class.k-last": "this.marqueeClasses", "style.left.px": "this.left", "style.right.px": "this.left", "style.top.px": "this.top", "style.width.px": "this.width", "style.height.px": "this.height" } }, ngImport: i0, template: `
        <div class="k-marquee-color"></div>
        <div class="k-marquee-text">
            <div class="k-label-top" *ngIf="hint.first">{{ start | kendoDate : format }}</div>
            <div class="k-label-bottom" *ngIf="hint.last">{{ end | kendoDate : format }}</div>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: DatePipe, name: "kendoDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ResizeHintComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[kendoResizeHint]',
                    template: `
        <div class="k-marquee-color"></div>
        <div class="k-marquee-text">
            <div class="k-label-top" *ngIf="hint.first">{{ start | kendoDate : format }}</div>
            <div class="k-label-bottom" *ngIf="hint.last">{{ end | kendoDate : format }}</div>
        </div>
    `,
                    standalone: true,
                    imports: [NgIf, DatePipe]
                }]
        }], propDecorators: { hint: [{
                type: Input
            }], format: [{
                type: Input
            }], marqueeClasses: [{
                type: HostBinding,
                args: ['class.k-marquee']
            }, {
                type: HostBinding,
                args: ['class.k-scheduler-marquee']
            }, {
                type: HostBinding,
                args: ['class.k-first']
            }, {
                type: HostBinding,
                args: ['class.k-last']
            }], left: [{
                type: HostBinding,
                args: ['style.left.px']
            }, {
                type: HostBinding,
                args: ['style.right.px']
            }], top: [{
                type: HostBinding,
                args: ['style.top.px']
            }], width: [{
                type: HostBinding,
                args: ['style.width.px']
            }], height: [{
                type: HostBinding,
                args: ['style.height.px']
            }] } });

/**
 * @hidden
 */
class BaseSlotDirective {
    constructor(element, slotService, localization) {
        this.element = element;
        this.slotService = slotService;
        this.localization = localization;
        this._rect = null;
    }
    get slotIndex() {
        return this.key;
    }
    get start() {
        return this._start;
    }
    set start(value) {
        this._start = value;
    }
    get end() {
        return this._end;
    }
    set end(value) {
        this._end = value;
    }
    get rect() {
        if (this._rect) {
            return this._rect;
        }
        const el = this.nativeElement;
        this._rect = {
            left: !this.localization.rtl ? el.offsetLeft : this.slotService.containerSize - (el.offsetLeft + el.clientWidth),
            top: el.offsetTop,
            width: el.clientWidth,
            height: el.clientHeight
        };
        return this._rect;
    }
    get top() {
        return this.element ? this.nativeElement.offsetTop : 0;
    }
    get padding() {
        if (!this.element || !isDocumentAvailable()) {
            return 0;
        }
        return parseInt(window.getComputedStyle(this.nativeElement).paddingTop, 10) * 2;
    }
    get height() {
        return this.element ? this.nativeElement.offsetHeight : 0;
    }
    set height(value) {
        if (this.element) {
            this.nativeElement.style.height = `${value}px`;
        }
        if (this._rect) {
            this._rect.height = value;
        }
    }
    get width() {
        return this.element ? this.nativeElement.offsetWidth : 0;
    }
    get key() {
        return `${this.id.resourceIndex}:${this.id.rangeIndex}:${this.id.index}`;
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    ngOnInit() {
        this.slotService.registerSlot(this);
    }
    ngOnDestroy() {
        this.slotService.unregisterSlot(this);
    }
    invalidate() {
        this._rect = null;
    }
}
BaseSlotDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseSlotDirective, deps: [{ token: i0.ElementRef }, { token: BaseSlotService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
BaseSlotDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: BaseSlotDirective, inputs: { id: "id" }, host: { properties: { "attr.data-slot-index": "this.slotIndex" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: BaseSlotDirective, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: BaseSlotService }, { type: i1$1.LocalizationService }]; }, propDecorators: { id: [{
                type: Input
            }], slotIndex: [{
                type: HostBinding,
                args: ['attr.data-slot-index']
            }] } });

/**
 * @hidden
 */
class MonthSlotComponent extends BaseSlotDirective {
    constructor(element, slotService, localization, cdr) {
        super(element, slotService, localization);
        this.cdr = cdr;
        this.moreHorizontalIcon = moreHorizontalIcon;
        this.isDaySlot = true;
        this._linkHeight = null;
    }
    set day(value) {
        this._day = value;
        this.start = value;
    }
    /**
     * For the slot template we need the day value without the UTC conversion
     * - timezone does not matter for the day part in this case as the calendar month view is the same for every timezone
     * otherwise the date is incorrect for some timezones (e.g. LA timezone) -
     * For example, it displays Feb. 8, 2023 to be Thursday, wherease it is Wednesday
     */
    get day() {
        return this._day;
    }
    set start(value) {
        this.startDate = toUTCDate(value);
    }
    get start() {
        return this.startDate;
    }
    get end() {
        return addUTCDays(this.start, 1);
    }
    isFirstDayOfMonth(day) {
        return isEqualDate(day, firstDayOfMonth(day));
    }
    get linkHeight() {
        if (this._linkHeight === null) {
            const element = firstElementChild(this.nativeElement);
            this._linkHeight = element ? element.offsetHeight + element.offsetTop : 0;
        }
        return this._linkHeight;
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeShowMore();
    }
    showMore(rect) {
        this.showMoreButton = true;
        this.style = `width: ${rect.width}px; left: ${rect.left}px; top: ${rect.top}px; border-color: inherit;`;
        this.cdr.detectChanges();
    }
    hideMore() {
        this.showMoreButton = false;
        this.removeShowMore();
    }
    invalidate() {
        super.invalidate();
        this._linkHeight = null;
        this.showMoreButton = false;
        this.removeShowMore();
    }
    removeShowMore() {
        this.showMoreButton = false;
        this.cdr.detectChanges();
    }
}
MonthSlotComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthSlotComponent, deps: [{ token: i0.ElementRef }, { token: MonthSlotService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MonthSlotComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MonthSlotComponent, isStandalone: true, selector: "[monthSlot]", inputs: { resourcesByIndex: "resourcesByIndex", monthDaySlotTemplateRef: "monthDaySlotTemplateRef", day: ["monthSlot", "day"] }, usesInheritance: true, ngImport: i0, template: `
        <span *ngIf="!monthDaySlotTemplateRef" aria-hidden="true" class="k-link k-nav-day">
            {{ day | kendoDate: isFirstDayOfMonth(day) ? 'MMM dd' : 'dd' }}
        </span>
        <ng-container
            *ngIf="monthDaySlotTemplateRef"
            [ngTemplateOutlet]="monthDaySlotTemplateRef"
            [ngTemplateOutletContext]="{ date: day, resources: resourcesByIndex }"
        >
        </ng-container>

        <div *ngIf="showMoreButton" class="k-more-events k-button" [style]="style">
            <kendo-icon-wrapper
                name="more-horizontal"
                [svgIcon]="moreHorizontalIcon"
            >
            </kendo-icon-wrapper>
        </div>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "pipe", type: DatePipe, name: "kendoDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthSlotComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[monthSlot]',
                    template: `
        <span *ngIf="!monthDaySlotTemplateRef" aria-hidden="true" class="k-link k-nav-day">
            {{ day | kendoDate: isFirstDayOfMonth(day) ? 'MMM dd' : 'dd' }}
        </span>
        <ng-container
            *ngIf="monthDaySlotTemplateRef"
            [ngTemplateOutlet]="monthDaySlotTemplateRef"
            [ngTemplateOutletContext]="{ date: day, resources: resourcesByIndex }"
        >
        </ng-container>

        <div *ngIf="showMoreButton" class="k-more-events k-button" [style]="style">
            <kendo-icon-wrapper
                name="more-horizontal"
                [svgIcon]="moreHorizontalIcon"
            >
            </kendo-icon-wrapper>
        </div>
    `,
                    standalone: true,
                    imports: [NgIf, NgTemplateOutlet, IconWrapperComponent, DatePipe]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: MonthSlotService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { resourcesByIndex: [{
                type: Input
            }], monthDaySlotTemplateRef: [{
                type: Input
            }], day: [{
                type: Input,
                args: ['monthSlot']
            }] } });

/**
 * @hidden
 */
class MonthViewRendererComponent extends BaseView {
    constructor(viewContext, viewState, intl, slotService, zone, element, renderer, pdfService, localization, changeDetector, scrollBarWidthService) {
        super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
        /**
         * The number of weeks to be rendered in the view
         */
        this.numberOfWeeks = WEEKS_COUNT;
        this.resizeHintFormat = { skeleton: 'Md' };
        this.weeks = [];
        this.updateOngoingEvents = this.updateOngoingEvents.bind(this);
    }
    get monthDaySlotTemplateRef() {
        return this.monthDaySlotTemplate || (this.schedulerMonthDaySlotTemplate || {}).templateRef;
    }
    ngOnChanges(changes) {
        if (isChanged('weekStart', changes)) {
            this.onSelectDate(this.selectedDate);
        }
        super.ngOnChanges(changes);
    }
    ngAfterViewInit() {
        this.updateOngoingEvents();
        super.ngAfterViewInit();
    }
    ngOnDestroy() {
        clearTimeout(this.ongoingEventsTimeout);
        super.ngOnDestroy();
    }
    horizontalColspan(resourceIndex) {
        const resources = this.horizontalResources;
        let result = DAYS_IN_WEEK_COUNT;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    verticalRowspan(resourceIndex) {
        const resources = this.verticalResources;
        let result = this.numberOfWeeks;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    verticalItem(leafIndex, resourceIndex) {
        const data = this.verticalResources[resourceIndex].data || [];
        const resources = this.verticalResources;
        let result = 1;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= ((resources[idx].data || []).length || 1);
        }
        return data[(leafIndex / result) % data.length];
    }
    daySlotClass(day, resourceIndex) {
        if (this.slotClass) {
            return this.slotClass({
                start: day,
                end: addDays(day, 1),
                resources: this.resourcesByIndex(resourceIndex),
                isAllDay: false
            });
        }
    }
    cellTitle(value) {
        return this.intl.formatDate(value, 'D');
    }
    addDay(dayStart) {
        return addDays(dayStart, 1);
    }
    isDayInPreviousMonth(day) {
        const beginningOfMonth = new Date(firstDayOfMonth(this.selectedDate).setHours(0, 0, 0, 0));
        return day < beginningOfMonth;
    }
    isDayInNextMonth(day) {
        const endOfMonth = new Date(lastDayOfMonth(this.selectedDate).setHours(23, 59, 59, 59));
        return day > endOfMonth;
    }
    optionsChange(changes) {
        this.schedulerMonthDaySlotTemplate = changes[`${this.type}DaySlotTemplate`];
        super.optionsChange(changes);
    }
    createTasks(items, dateRange) {
        this.weeks = this.createDaySlots(dateRange);
        return createTasks$3(dateRange.start, dateRange.end, items, this.weeks);
    }
    onTasksChange() {
        updateTaskData(this.tasks);
        this.items.next(this.tasks);
    }
    reflow() {
        this.updateContentHeight();
        const content = this.content.nativeElement;
        this.slotService.containerSize = content.scrollWidth;
        if (this.contentHeight === 'auto') {
            // bigger size changes cause the table to overflow the container and in horizontal scrollbars
            // this changes the table and slots size during rendering before the browser re-adjusts the 100% table width
            content.style.overflow = 'visible';
        }
        this.slotService.layout(this.eventHeight);
        if (this.contentHeight === 'auto') {
            content.style.overflow = 'auto';
        }
        this.syncTables();
    }
    onClick(e, eventType = e.type) {
        if (eventType === 'click') {
            const eventSlot = closestInScope(e.target, node => node.hasAttribute('data-slot-index'), this.element.nativeElement);
            const navigateToDay = closestInScope(e.target, node => hasClasses(node, 'k-more-events k-nav-day'), eventSlot);
            if (eventSlot && navigateToDay) {
                const index = eventSlot.getAttribute('data-slot-index');
                const slot = this.slotService.slotByIndex(index);
                this.zone.run(() => {
                    this.viewState.navigateTo({ viewName: 'day', date: toLocalDate(slot.start) });
                });
                return;
            }
        }
        super.onClick(e, eventType);
    }
    slotByIndex(index, _args) {
        return this.slotService.slotByIndex(index);
    }
    onSelectDate(date) {
        const dateRange = this.dateRange(date);
        this.selectedDate = date;
        this.viewState.notifyDateRange(dateRange);
        this.weeks = this.createDaySlots(dateRange);
    }
    onAction(e) {
        const now = getDate(this.selectedDate);
        if (e.type === 'next') {
            const next = this.newRange(now);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'prev') {
            const next = this.newRange(now, -1);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
    }
    dateRange(date = this.selectedDate) {
        return this.dateRangeFn(date, this.weekStart);
    }
    dragRanges(slot) {
        return this.slotService.dragRanges(slot, this.dragging.offset);
    }
    dragHintSize(first, last) {
        return {
            width: toPx(last.rect.left - first.rect.left + last.rect.width),
            height: toPx(first.height)
        };
    }
    slotByPosition(x, y) {
        return this.slotService.slotByPosition(x, y);
    }
    updateOngoingEvents() {
        const disabled = !this.highlightOngoingEvents || this.highlightOngoingEvents.enabled === false;
        if (!isDocumentAvailable() || disabled) {
            return;
        }
        clearTimeout(this.ongoingEventsTimeout);
        this.zone.runOutsideAngular(() => {
            this.ongoingEventsTimeout = setTimeout(this.updateOngoingEvents, this.highlightOngoingEvents.updateInterval || MS_PER_MINUTE);
        });
        this.toggleOngoingClass();
    }
    currentTime() {
        return new Date();
    }
    toggleOngoingClass() {
        const now = this.currentTime();
        const cssClass = isPresent(this.highlightOngoingEvents.cssClass) ? this.highlightOngoingEvents.cssClass : ONGOING_EVENT_CSS_CLASS;
        this.eventElements.forEach((event) => {
            const isOngoing = dateInRange(now, event.item.start, event.item.end);
            this.renderer[isOngoing ? 'addClass' : 'removeClass'](event.nativeElement, cssClass);
        });
    }
    createDaySlots({ start }) {
        const weeks = [];
        let date = start;
        for (let idx = 0; idx < this.numberOfWeeks; idx++) {
            const week = [];
            weeks.push(week);
            for (let dayIdx = 0; dayIdx < DAYS_IN_WEEK_COUNT; dayIdx++) {
                week.push(date);
                date = addDays(date, 1);
            }
        }
        return weeks;
    }
}
MonthViewRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewRendererComponent, deps: [{ token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: MonthSlotService }, { token: i0.NgZone }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: PDFService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: i7.ScrollbarWidthService }], target: i0.ɵɵFactoryTarget.Component });
MonthViewRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MonthViewRendererComponent, isStandalone: true, selector: "month-view", inputs: { monthDaySlotTemplate: "monthDaySlotTemplate", highlightOngoingEvents: "highlightOngoingEvents", type: "type", numberOfWeeks: "numberOfWeeks", newRange: "newRange", dateRangeFn: "dateRangeFn" }, providers: [
        MonthSlotService
    ], viewQueries: [{ propertyName: "eventElements", predicate: MonthViewItemComponent, descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
        <table class="k-scheduler-layout k-scheduler-monthview">
            <tbody>
                <tr class="k-scheduler-head">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times" #timesHeader *ngIf="verticalResources.length">
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr>
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <!-- Days of the weeks titles -->
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr>
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex">
                                                <th *ngFor="let day of weeks[0]; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    {{ day | kendoDate: 'EEEE' }}
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times k-scheduler-resources" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex">
                                        <tr>
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-heading-cell" [ngClass]="{ 'k-last-resource': resourceIndex === verticalResources.length - 1 }">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th class="k-slot-cell k-heading-cell k-empty-slot">
                                            </th>
                                        </tr>
                                        <tr *ngFor="let index of (numberOfWeeks - 1) | repeat; trackBy: itemIndex">
                                            <th class="k-slot-cell k-heading-cell k-empty-slot"></th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div 
                            class="k-scheduler-content"
                            tabindex="0"
                            #content
                            role="group"
                            [attr.aria-owns]="matchOwned(items | async)"
                            [style.overflowY]="'auto'">
                            <!-- Main content -->
                            <table class="k-scheduler-table" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex">
                                        <tr *ngFor="let week of weeks;  let rangeIndex = index; trackBy: itemIndex">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex">
                                                <td *ngFor="let day of week; let index = index; trackBy: itemIndex"
                                                    [monthSlot]="day"
                                                    [monthDaySlotTemplateRef]="monthDaySlotTemplateRef"
                                                    [resourcesByIndex]="resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [ngClass]="daySlotClass(day, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                    [title]="cellTitle(day)"
                                                    [class.k-selected]="isSlotSelected({
                                                        start: toPlainDate(day),
                                                        end: addDay(toPlainDate(day)),
                                                        isAllDay: true,
                                                        resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                    })"
                                                    class="k-scheduler-cell"
                                                    [class.k-other-month]="isDayInPreviousMonth(day) || isDayInNextMonth(day)"
                                                    >
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    monthViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        monthViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>

                                    <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                        kendoResizeHint
                                            [hint]="hint"
                                            [ngClass]="hint.class"
                                            [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: MonthSlotComponent, selector: "[monthSlot]", inputs: ["resourcesByIndex", "monthDaySlotTemplateRef", "monthSlot"] }, { kind: "component", type: MonthViewItemComponent, selector: "[monthViewItem]" }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "component", type: HintContainerComponent, selector: "kendo-hint-container" }, { kind: "component", type: ResizeHintComponent, selector: "[kendoResizeHint]", inputs: ["hint", "format"] }, { kind: "pipe", type: RepeatPipe, name: "repeat" }, { kind: "pipe", type: ResourceIteratorPipe, name: "resourceIterator" }, { kind: "pipe", type: DatePipe, name: "kendoDate" }, { kind: "pipe", type: AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewRendererComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'month-view',
                    providers: [
                        MonthSlotService
                    ],
                    template: `
        <table class="k-scheduler-layout k-scheduler-monthview">
            <tbody>
                <tr class="k-scheduler-head">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times" #timesHeader *ngIf="verticalResources.length">
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr>
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <!-- Days of the weeks titles -->
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr>
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex">
                                                <th *ngFor="let day of weeks[0]; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    {{ day | kendoDate: 'EEEE' }}
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td *ngIf="verticalResources.length">
                        <div class="k-scheduler-times k-scheduler-resources" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex">
                                        <tr>
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-heading-cell" [ngClass]="{ 'k-last-resource': resourceIndex === verticalResources.length - 1 }">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th class="k-slot-cell k-heading-cell k-empty-slot">
                                            </th>
                                        </tr>
                                        <tr *ngFor="let index of (numberOfWeeks - 1) | repeat; trackBy: itemIndex">
                                            <th class="k-slot-cell k-heading-cell k-empty-slot"></th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div 
                            class="k-scheduler-content"
                            tabindex="0"
                            #content
                            role="group"
                            [attr.aria-owns]="matchOwned(items | async)"
                            [style.overflowY]="'auto'">
                            <!-- Main content -->
                            <table class="k-scheduler-table" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex">
                                        <tr *ngFor="let week of weeks;  let rangeIndex = index; trackBy: itemIndex">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex">
                                                <td *ngFor="let day of week; let index = index; trackBy: itemIndex"
                                                    [monthSlot]="day"
                                                    [monthDaySlotTemplateRef]="monthDaySlotTemplateRef"
                                                    [resourcesByIndex]="resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [ngClass]="daySlotClass(day, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                    [title]="cellTitle(day)"
                                                    [class.k-selected]="isSlotSelected({
                                                        start: toPlainDate(day),
                                                        end: addDay(toPlainDate(day)),
                                                        isAllDay: true,
                                                        resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                    })"
                                                    class="k-scheduler-cell"
                                                    [class.k-other-month]="isDayInPreviousMonth(day) || isDayInNextMonth(day)"
                                                    >
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    monthViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        monthViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>

                                    <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                        kendoResizeHint
                                            [hint]="hint"
                                            [ngClass]="hint.class"
                                            [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
                    standalone: true,
                    imports: [NgIf, NgFor, NgTemplateOutlet, NgClass, MonthSlotComponent, MonthViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, RepeatPipe, ResourceIteratorPipe, DatePipe, AsyncPipe]
                }]
        }], ctorParameters: function () { return [{ type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: MonthSlotService }, { type: i0.NgZone }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: PDFService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: i7.ScrollbarWidthService }]; }, propDecorators: { monthDaySlotTemplate: [{
                type: Input
            }], highlightOngoingEvents: [{
                type: Input
            }], type: [{
                type: Input
            }], numberOfWeeks: [{
                type: Input
            }], newRange: [{
                type: Input
            }], dateRangeFn: [{
                type: Input
            }], eventElements: [{
                type: ViewChildren,
                args: [MonthViewItemComponent]
            }] } });

/**
 * The component for rendering the **Month** view.
 */
class MonthViewComponent extends ConfigurationViewBase {
    constructor(localization, changeDetector, viewContext, viewState, intl) {
        super(localization, changeDetector, viewContext, viewState);
        this.intl = intl;
        /**
         * The long-date format for displaying the
         * selected date in the Scheduler toolbar.
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         * @default '{0:Y}'
         */
        this.selectedDateFormat = '{0:Y}';
        /**
         * The short-date format for displaying the
         * selected date in the Scheduler toolbar.
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting.
         * @default '{0:y}'
         */
        this.selectedShortDateFormat = '{0:y}';
        /**
         * The invariant name for this view.
         * @default 'month'
         */
        this.name = 'month';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('monthViewTitle');
    }
    get viewEventHeight() {
        return isPresent(this.eventHeight) ? this.eventHeight : (this.schedulerOptions.eventHeight || DEFAULT_EVENT_HEIGHT);
    }
    /**
     * @hidden
     */
    dateRange(date, weekStart) {
        const monthStart = firstDayOfMonth(getDate(date));
        const start = firstDayInWeek(monthStart, weekStart);
        const end = addDays(start, DAYS_IN_WEEK_COUNT * WEEKS_COUNT);
        const text = this.intl.format(this.selectedDateFormat, monthStart);
        const shortText = this.intl.format(this.selectedShortDateFormat, monthStart);
        return { start, end, text, shortText };
    }
    /**
     * @hidden
     */
    newRange(date, direction = 1) {
        return firstDayOfMonth(addMonths(date, direction));
    }
}
MonthViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }], target: i0.ɵɵFactoryTarget.Component });
MonthViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MonthViewComponent, isStandalone: true, selector: "kendo-scheduler-month-view", inputs: { eventHeight: "eventHeight", selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => MonthViewComponent)
        }], queries: [{ propertyName: "monthDaySlotTemplate", first: true, predicate: MonthDaySlotTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <month-view
                type="month"
                [eventHeight]="viewEventHeight"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="monthDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MonthViewRendererComponent, selector: "month-view", inputs: ["monthDaySlotTemplate", "highlightOngoingEvents", "type", "numberOfWeeks", "newRange", "dateRangeFn"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-month-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => MonthViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <month-view
                type="month"
                [eventHeight]="viewEventHeight"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="monthDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MonthViewRendererComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }]; }, propDecorators: { eventHeight: [{
                type: Input
            }], selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], monthDaySlotTemplate: [{
                type: ContentChild,
                args: [MonthDaySlotTemplateDirective, { static: false }]
            }] } });

/**
 * The component for rendering the **Multi-Week** view.
 */
class MultiWeekViewComponent extends ConfigurationViewBase {
    constructor(localization, changeDetector, viewContext, viewState, intl) {
        super(localization, changeDetector, viewContext, viewState);
        this.intl = intl;
        /**
         * The number of weeks to be rendered.
         * @default 6
         */
        this.numberOfWeeks = WEEKS_COUNT;
        /**
         * The long-date format for displaying the
         * selected date in the Scheduler toolbar.
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         * @default '{0:D} - {1:D}'
         */
        this.selectedDateFormat = '{0:D} - {1:D}';
        /**
         * The short-date format for displaying the
         * selected date in the Scheduler toolbar.
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting.
         * @default '{0:d} - {1:d}'
         */
        this.selectedShortDateFormat = '{0:d} - {1:d}';
        /**
         * The invariant name for this view (`multiWeek`).
         */
        this.name = 'multiWeek';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('multiWeekViewTitle');
    }
    get viewEventHeight() {
        return isPresent(this.eventHeight) ? this.eventHeight : (this.schedulerOptions.eventHeight || DEFAULT_EVENT_HEIGHT);
    }
    /**
     * @hidden
     */
    dateRange(date, weekStart) {
        const periodStart = getDate(date);
        const start = firstDayInWeek(periodStart, weekStart);
        const end = addDays(start, (DAYS_IN_WEEK_COUNT * this.numberOfWeeks));
        const text = this.intl.format(this.selectedDateFormat, start, end);
        const shortText = this.intl.format(this.selectedShortDateFormat, start, end);
        return { start, end, text, shortText };
    }
    /**
     * @hidden
     */
    newRange(date, direction = 1) {
        return firstDayInWeek(addWeeks(date, this.numberOfWeeks * direction));
    }
}
MultiWeekViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiWeekViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }], target: i0.ɵɵFactoryTarget.Component });
MultiWeekViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MultiWeekViewComponent, isStandalone: true, selector: "kendo-scheduler-multi-week-view", inputs: { eventHeight: "eventHeight", numberOfWeeks: "numberOfWeeks", selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => MultiWeekViewComponent)
        }], queries: [{ propertyName: "multiWeekDaySlotTemplate", first: true, predicate: MultiWeekDaySlotTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <month-view
                type="multiWeek"
                [eventHeight]="viewEventHeight"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="multiWeekDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [numberOfWeeks]="numberOfWeeks"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MonthViewRendererComponent, selector: "month-view", inputs: ["monthDaySlotTemplate", "highlightOngoingEvents", "type", "numberOfWeeks", "newRange", "dateRangeFn"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiWeekViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-multi-week-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => MultiWeekViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <month-view
                type="multiWeek"
                [eventHeight]="viewEventHeight"
                [eventTemplate]="eventTemplate?.templateRef"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [monthDaySlotTemplate]="multiWeekDaySlotTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [weekStart]="viewWeekStart"
                [numberOfWeeks]="numberOfWeeks"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </month-view>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MonthViewRendererComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }]; }, propDecorators: { eventHeight: [{
                type: Input
            }], numberOfWeeks: [{
                type: Input
            }], selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], multiWeekDaySlotTemplate: [{
                type: ContentChild,
                args: [MultiWeekDaySlotTemplateDirective]
            }] } });

const EVENT_HEIGHT = 'eventHeight';
const SHOW_WORK_HOURS = 'showWorkHours';
const START_TIME = 'startTime';
const END_TIME = 'endTime';
const WORK_DAY_START = 'workDayStart';
const WORK_DAY_END = 'workDayEnd';
const WORK_WEEK_START = 'workWeekStart';
const WORK_WEEK_END = 'workWeekEnd';
const SLOT_DURATION = 'slotDuration';
const SLOT_DIVISIONS = 'slotDivisions';
const CURRENT_TIME_MARKER = 'currentTimeMarker';
const HIGHLIGHT_ONGOING_EVENTS = 'highlightOngoingEvents';
/**
 * @hidden
 */
class DayTimeViewBase extends ConfigurationViewBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
    }
    /**
     * @hidden
     */
    get viewEventHeight() {
        return this.optionValue(EVENT_HEIGHT) || DEFAULT_EVENT_HEIGHT;
    }
    /**
     * @hidden
     */
    get shouldShowWorkHours() {
        return this.optionValue(SHOW_WORK_HOURS);
    }
    /**
     * @hidden
     */
    get viewStartTime() {
        return this.optionValue(START_TIME);
    }
    /**
     * @hidden
     */
    get viewEndTime() {
        return this.optionValue(END_TIME);
    }
    /**
     * @hidden
     */
    get viewWorkDayStart() {
        return this.optionValue(WORK_DAY_START);
    }
    /**
     * @hidden
     */
    get viewWorkDayEnd() {
        return this.optionValue(WORK_DAY_END);
    }
    /**
     * @hidden
     */
    get viewWorkWeekStart() {
        return this.optionValue(WORK_WEEK_START);
    }
    /**
     * @hidden
     */
    get viewWorkWeekEnd() {
        return this.optionValue(WORK_WEEK_END);
    }
    /**
     * @hidden
     */
    get viewSlotDuration() {
        return this.optionValue(SLOT_DURATION);
    }
    /**
     * @hidden
     */
    get viewSlotDivisions() {
        return this.optionValue(SLOT_DIVISIONS);
    }
    /**
     * @hidden
     */
    get viewCurrentTimeMarker() {
        return this.optionValue(CURRENT_TIME_MARKER);
    }
    /**
     * @hidden
     */
    get viewHighlightOngoingEvents() {
        return this.optionValue(HIGHLIGHT_ONGOING_EVENTS);
    }
    /**
     * @hidden
     */
    get viewScrollTime() {
        return this.optionValue('scrollTime');
    }
    /**
     * @hidden
     */
    get viewShowFooter() {
        return isPresent(this.showFooter) ? this.showFooter : this.schedulerOptions.showFooter;
    }
    optionValue(name) {
        return isPresent(this[name]) ? this[name] : this.schedulerOptions[name];
    }
}
DayTimeViewBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewBase, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Directive });
DayTimeViewBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: DayTimeViewBase, inputs: { showWorkHours: "showWorkHours", showFooter: "showFooter", eventHeight: "eventHeight", startTime: "startTime", scrollTime: "scrollTime", endTime: "endTime", workDayStart: "workDayStart", workDayEnd: "workDayEnd", workWeekStart: "workWeekStart", workWeekEnd: "workWeekEnd", slotDuration: "slotDuration", slotDivisions: "slotDivisions", currentTimeMarker: "currentTimeMarker", highlightOngoingEvents: "highlightOngoingEvents" }, queries: [{ propertyName: "timeSlotTemplate", first: true, predicate: TimeSlotTemplateDirective, descendants: true }, { propertyName: "dateHeaderTemplate", first: true, predicate: DateHeaderTemplateDirective, descendants: true }, { propertyName: "majorTimeHeaderTemplate", first: true, predicate: MajorTimeHeaderTemplateDirective, descendants: true }, { propertyName: "minorTimeHeaderTemplate", first: true, predicate: MinorTimeHeaderTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { timeSlotTemplate: [{
                type: ContentChild,
                args: [TimeSlotTemplateDirective, { static: false }]
            }], dateHeaderTemplate: [{
                type: ContentChild,
                args: [DateHeaderTemplateDirective, { static: false }]
            }], majorTimeHeaderTemplate: [{
                type: ContentChild,
                args: [MajorTimeHeaderTemplateDirective, { static: false }]
            }], minorTimeHeaderTemplate: [{
                type: ContentChild,
                args: [MinorTimeHeaderTemplateDirective, { static: false }]
            }], showWorkHours: [{
                type: Input
            }], showFooter: [{
                type: Input
            }], eventHeight: [{
                type: Input
            }], startTime: [{
                type: Input
            }], scrollTime: [{
                type: Input
            }], endTime: [{
                type: Input
            }], workDayStart: [{
                type: Input
            }], workDayEnd: [{
                type: Input
            }], workWeekStart: [{
                type: Input
            }], workWeekEnd: [{
                type: Input
            }], slotDuration: [{
                type: Input
            }], slotDivisions: [{
                type: Input
            }], currentTimeMarker: [{
                type: Input
            }], highlightOngoingEvents: [{
                type: Input
            }] } });

const SLOT_FILL = 'slotFill';
const ALL_DAY_SLOT = 'allDaySlot';
/**
 * @hidden
 */
class MultiDayViewBase extends DayTimeViewBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
    }
    /**
     * @hidden
     */
    get viewSlotFill() {
        return this.optionValue(SLOT_FILL);
    }
    /**
     * @hidden
     */
    get viewAllDaySlot() {
        return this.optionValue(ALL_DAY_SLOT);
    }
}
MultiDayViewBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewBase, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Directive });
MultiDayViewBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: MultiDayViewBase, inputs: { slotFill: "slotFill", allDaySlot: "allDaySlot" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { slotFill: [{
                type: Input
            }], allDaySlot: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class ViewFooterComponent {
    constructor(viewState) {
        this.hostClasses = true;
        this.toolbarRole = 'toolbar';
        /**
         * @hidden
         * TODO: Drop in next MAJOR version
         */
        this.inlineJustifyContentStyle = 'start';
        this.itemClick = new EventEmitter();
        this.sub = viewState.toggleWorkHours.subscribe(() => this.itemClick.emit());
    }
    ngOnDestroy() {
        // eslint-disable-next-line no-unused-expressions
        this.sub && this.sub.unsubscribe();
    }
    onItemClick(e, item) {
        e.preventDefault();
        this.itemClick.emit(item);
    }
}
ViewFooterComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewFooterComponent, deps: [{ token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
ViewFooterComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: ViewFooterComponent, isStandalone: true, selector: "[viewFooter]", inputs: { items: "items" }, outputs: { itemClick: "itemClick" }, host: { properties: { "class.k-scheduler-footer": "this.hostClasses", "class.k-toolbar": "this.hostClasses", "class.k-toolbar-md": "this.hostClasses", "attr.role": "this.toolbarRole", "style.justify-content": "this.inlineJustifyContentStyle" } }, ngImport: i0, template: `
        <span class="k-scheduler-navigation">
            <button
                *ngFor="let item of items"
                type="button"
                kendoButton
                [icon]="item.fontIcon"
                [svgIcon]="item.svgIcon"
                [ngClass]="item.cssClass"
                (click)="onItemClick($event, item)"
                [kendoSchedulerFocusIndex]="0"
                containerType='footer'>
                <span class="k-button-text">{{ item.text }}</span>
            </button>
        </span>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewFooterComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[viewFooter]',
                    template: `
        <span class="k-scheduler-navigation">
            <button
                *ngFor="let item of items"
                type="button"
                kendoButton
                [icon]="item.fontIcon"
                [svgIcon]="item.svgIcon"
                [ngClass]="item.cssClass"
                (click)="onItemClick($event, item)"
                [kendoSchedulerFocusIndex]="0"
                containerType='footer'>
                <span class="k-button-text">{{ item.text }}</span>
            </button>
        </span>
    `,
                    standalone: true,
                    imports: [NgFor, ButtonComponent, NgClass, FocusableDirective]
                }]
        }], ctorParameters: function () { return [{ type: ViewStateService }]; }, propDecorators: { hostClasses: [{
                type: HostBinding,
                args: ['class.k-scheduler-footer']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar']
            }, {
                type: HostBinding,
                args: ['class.k-toolbar-md']
            }], toolbarRole: [{
                type: HostBinding,
                args: ['attr.role']
            }], inlineJustifyContentStyle: [{
                type: HostBinding,
                args: ['style.justify-content']
            }], itemClick: [{
                type: Output
            }], items: [{
                type: Input
            }] } });

/**
 * @hidden
 */
class WorkHoursFooterDirective {
    constructor(footer, localization) {
        this.footer = footer;
        this.localization = localization;
        this.showWorkHours = false;
        this.footerItems = [{ cssClass: 'k-scheduler-fullday', fontIcon: 'clock', svgIcon: clockIcon, text: '' }];
    }
    ngOnInit() {
        this.toggleWorkHours();
        this.footer.items = this.footerItems;
    }
    ngOnChanges() {
        this.toggleWorkHours();
    }
    toggleWorkHours() {
        this.footerItems[0].text = this.showWorkHours ? this.localization.get('showFullDay') : this.localization.get('showWorkDay');
    }
}
WorkHoursFooterDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WorkHoursFooterDirective, deps: [{ token: ViewFooterComponent }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
WorkHoursFooterDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: WorkHoursFooterDirective, isStandalone: true, selector: "[kendoWorkHoursFooter]", inputs: { showWorkHours: "showWorkHours" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WorkHoursFooterDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoWorkHoursFooter]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: ViewFooterComponent }, { type: i1$1.LocalizationService }]; }, propDecorators: { showWorkHours: [{
                type: Input
            }] } });

const EVENTS_OFFSET = 10;
const MIN_EVENT_HEIGHT = 25;
const minHeightOverlaps = (top1, top2) => top1 <= top2 && top2 <= top1 + MIN_EVENT_HEIGHT;
const timeOffset = (slot, date, vertical = true) => {
    if (slot.start.getTime() <= date.getTime()) {
        return (vertical ? slot.height : slot.width) * ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
    }
    return 0;
};
const columnIndexComparer = (a, b) => {
    const indexA = isNumber(a.columnIndex) ? a.columnIndex : Number.MAX_VALUE;
    const indexB = isNumber(b.columnIndex) ? b.columnIndex : Number.MAX_VALUE;
    // a un b def = 0
    // b un a def = 0
    if (indexA === indexB) {
        return a.item.startTime.getTime() - b.item.startTime.getTime();
    }
    return indexA - indexB;
};
function initTimeColumns(slotKeys, slotItems) {
    // Break slots into groups with overlapping events.
    let columns = 0;
    let groupSlots = [];
    slotKeys.forEach(key => {
        const { slot, events } = slotItems[key];
        const count = events.length;
        let groupEnd = true;
        events.sort(columnIndexComparer);
        columns = Math.max(count, columns);
        groupSlots.push(slot);
        for (let eventIdx = 0; eventIdx < count; eventIdx++) {
            const event = events[eventIdx];
            groupEnd = groupEnd && event.item.endTime.getTime() <= slot.end.getTime();
            if (isNumber(event.columnIndex)) {
                continue;
            }
            event.rect = {
                top: slot.rect.top + timeOffset(slot, event.item.startTime)
            };
            event.columnIndex = eventIdx;
            event.lastColumn = true;
            for (let idx = 0, previousIdx = -1; idx < eventIdx; idx++) {
                const current = events[idx];
                if (current.columnIndex > previousIdx + 1) {
                    event.columnIndex = previousIdx + 1;
                    event.lastColumn = false;
                    events.splice(eventIdx, 1);
                    events.splice(event.columnIndex, 0, event);
                    break;
                }
                if (!intersects(event.item.startTime, event.item.endTime, current.item.startTime, current.item.endTime) &&
                    !minHeightOverlaps(current.rect.top, event.rect.top)) {
                    event.columnIndex = idx;
                    event.lastColumn = !events.some(e => e.columnIndex && idx < e.columnIndex &&
                        intersects(event.item.startTime, event.item.endTime, e.item.startTime, e.item.endTime));
                    events.splice(eventIdx, 1);
                    events.splice(idx, 0, event);
                    break;
                }
                previousIdx = current.columnIndex;
                current.lastColumn = false;
            }
        }
        if (groupEnd) {
            groupSlots.forEach(item => item.columns = columns);
            groupSlots = [];
            columns = 0;
        }
    });
    // The maximum number of overlapping events in the group is used to create the same number of columns.
    groupSlots.forEach(slot => slot.columns = columns);
}
function findTimeRowIndex(events, event) {
    if (event.rowIndex !== undefined) {
        return event.rowIndex;
    }
    for (let idx = 0; idx < events.length; idx++) {
        const current = events[idx];
        if (!current || !intersects(event.item.startTime, event.item.endTime, current.item.startTime, current.item.endTime)) {
            return idx;
        }
    }
    return events.length;
}
function initHorizontalSlots(slots, items, rowHeight, eventHeight, getRowIndex) {
    const padding = slots[0].padding;
    if (!items.length) {
        return {
            height: rowHeight - padding
        };
    }
    items.forEach(item => {
        item.rowIndex = undefined;
        item.rect = {
            height: eventHeight,
            width: 0
        };
    });
    const sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
    const slotItems = {};
    sorted.forEach(event => slots
        .filter(slot => intersects(event.item.startTime, event.item.endTime, slot.start, slot.end))
        .forEach(slot => {
        const value = slotItems[slot.key] = slotItems[slot.key] || { rows: [], slot: slot, events: [] };
        event.rowIndex = getRowIndex(value.rows, event);
        value.rows[event.rowIndex] = event;
        value.events.push(event);
    }));
    const top = slots[0].top;
    let maxOffset = 0;
    Object.keys(slotItems).forEach((key) => {
        const events = slotItems[key].events;
        let slotOffset = 0;
        for (let idx = 0; idx < events.length; idx++) {
            const event = events[idx];
            if (event) {
                event.rect.top = top + event.rowIndex * (EVENTS_OFFSET + event.rect.height);
                slotOffset = Math.max(slotOffset, (event.rect.top - top) + event.rect.height);
            }
        }
        maxOffset = Math.max(slotOffset, maxOffset);
    });
    maxOffset += rowHeight - padding;
    return {
        height: maxOffset,
        slotItems
    };
}
function setHorizontalOffsets(slotItems, items, measureTime) {
    Object.keys(slotItems).forEach((key) => {
        const { slot, events } = slotItems[key];
        const rect = slot.rect;
        for (let idx = 0; idx < events.length; idx++) {
            const event = events[idx];
            if (event) {
                if (!isNumber(event.rect.left)) {
                    event.rect.left = slot.rect.left +
                        (measureTime ? timeOffset(slot, event.item.startTime, false) : 0);
                }
                const slotOffset = measureTime && event.item.endTime.getTime() < slot.end.getTime() ?
                    timeOffset(slot, event.item.endTime, false) : rect.width;
                event.rect.width = slot.rect.left + slotOffset - event.rect.left;
            }
        }
    });
    items.forEach(item => {
        item.reflow();
    });
}
/** @hidden */
class SlotRange {
    constructor(index) {
        this.index = index;
        this.slotMap = new ItemMap();
        this.itemMap = new ItemMap();
    }
    get slots() {
        return this.slotMap.toArray();
    }
    get firstSlot() {
        return this.slotMap.first;
    }
    get lastSlot() {
        return this.slotMap.last;
    }
    get items() {
        return this.itemMap.toArray();
    }
    get rect() {
        const first = this.firstSlot.rect;
        const last = this.lastSlot.rect;
        return {
            left: first.left,
            top: first.top,
            width: last.left - first.left + last.width,
            height: last.top - first.top + last.height
        };
    }
    get start() {
        const first = this.slotMap.first;
        if (!first) {
            return null;
        }
        return first.start;
    }
    get end() {
        const last = this.slotMap.last;
        if (!last) {
            return null;
        }
        return last.end;
    }
    get hasSlots() {
        return this.slotMap.count > 0;
    }
    get hasItems() {
        return this.itemMap.count > 0;
    }
    registerItem(component) {
        this.itemMap.addItem(component.item.index, component);
    }
    unregisterItem(component, id) {
        this.itemMap.removeItem(id.index, component);
    }
    registerSlot(slot) {
        this.slotMap.addItem(slot.id.index, slot);
    }
    unregisterSlot(slot) {
        this.slotMap.removeItem(slot.id.index, slot);
    }
    layout(options) {
        const items = this.items;
        if (!items.length) {
            return;
        }
        const fill = Math.max(Math.min(options.fill || 0.9, 1), 0.1);
        const sorted = orderBy(items, [{ field: "item.startTime", dir: "asc" }, { field: "item.endTime", dir: "desc" }]);
        items.forEach((item, _index) => {
            item.rect = null;
            item.columnIndex = undefined;
        });
        const slotItems = {};
        const slots = this.slots;
        // Map each populated slot to the events in it
        sorted.forEach(event => slots
            .filter(slot => intersects(event.item.startTime, event.item.endTime, slot.start, slot.end))
            .forEach(slot => {
            const value = slotItems[slot.key] = slotItems[slot.key] || { events: [] };
            value.slot = slot;
            value.events.push(event);
        }));
        const slotKeys = Object.keys(slotItems);
        initTimeColumns(slotKeys, slotItems);
        slotKeys.forEach((key) => {
            const { slot, events } = slotItems[key];
            const spacing = 2;
            const startOffset = 2;
            const slotRect = slot.rect;
            const slotLeft = slotRect.left;
            const columns = slot.columns;
            const slotWidth = slotRect.width * fill - (columns - 1) * spacing - startOffset;
            const origin = slotLeft + startOffset;
            const eventWidth = slotWidth / columns;
            const slotEnd = origin + slotWidth + (columns - 1) * spacing;
            events.forEach(event => {
                if (!isNumber(event.rect.left)) {
                    event.rect.left = origin + event.columnIndex * (eventWidth + spacing);
                    event.rect.width = event.lastColumn ? slotEnd - event.rect.left : eventWidth;
                    event.origin = {
                        left: slotLeft,
                        right: slotLeft + slotRect.width
                    };
                }
                // Expand the event to the last group slot
                const slotOffset = slot.end.getTime() <= event.item.endTime.getTime() ? slotRect.height : timeOffset(slot, event.item.endTime);
                event.rect.height = slotRect.top + slotOffset - event.rect.top;
            });
        });
        sorted.forEach(event => event.reflow());
    }
    initDaySlots(rowHeight, eventHeight) {
        const slots = this.slots;
        if (!slots.length) {
            return;
        }
        const { height, slotItems } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight, findRowIndex);
        this.setSlotsHeight(height);
        this.slotItems = slotItems;
    }
    setDayOffsets() {
        if (!this.itemMap.count || !this.slotItems) {
            return;
        }
        setHorizontalOffsets(this.slotItems, this.items);
        this.slotItems = null;
    }
    setSlotsHeight(height) {
        this.firstSlot.height = height;
    }
}
/**
 * @hidden
 */
class DayTimeResourceGroup {
    constructor(index) {
        this.index = index;
        this.dayRanges = [];
        this.timeRanges = [];
    }
    registerSlot(slot) {
        const range = this.slotRange(slot);
        range.registerSlot(slot);
    }
    unregisterSlot(slot) {
        const range = this.slotRange(slot);
        range.unregisterSlot(slot);
        if (!range.hasSlots) {
            const ranges = this.slotRanges(slot);
            delete ranges[slot.id.rangeIndex];
        }
    }
    registerItem(component) {
        const range = this.itemRange(component);
        if (range) {
            range.registerItem(component);
            component.rangeIndex = range.index;
            if (component.resourceIndex >= 0) {
                component.toggle(true);
            }
        }
        else {
            component.rangeIndex = undefined;
            component.toggle(false);
        }
    }
    unregisterItem(component, id) {
        if (component.rangeIndex !== undefined) {
            const ranges = component.item.isAllDay ? this.dayRanges : this.timeRanges;
            if (ranges[id.rangeIndex]) {
                ranges[id.rangeIndex].unregisterItem(component, id);
            }
            component.rangeIndex = undefined;
        }
    }
    forEachDateRange(callback) {
        for (let i = 0; i < this.dayRanges.length; i++) {
            callback(this.dayRanges[i]);
        }
    }
    forEachTimeRange(callback) {
        for (let i = 0; i < this.timeRanges.length; i++) {
            callback(this.timeRanges[i]);
        }
    }
    slotRange(slot) {
        const ranges = this.slotRanges(slot);
        const rangeIndex = slot.id.rangeIndex;
        if (!ranges[rangeIndex]) {
            ranges[rangeIndex] = new SlotRange(rangeIndex);
        }
        return ranges[rangeIndex];
    }
    slotRanges(slot) {
        return slot.isDaySlot ? this.dayRanges : this.timeRanges;
    }
    initTimeSlots(rowHeight, eventHeight, resourceRowHeight) {
        const slots = this.slots;
        if (!slots.length) {
            return;
        }
        const { height, slotItems } = initHorizontalSlots(slots, this.items, rowHeight, eventHeight, findTimeRowIndex);
        this.setSlotsHeight(Math.max(height, resourceRowHeight));
        this.slotItems = slotItems;
    }
    setTimelineOffsets() {
        const items = this.items;
        if (!this.slotItems || !items.length) {
            return;
        }
        setHorizontalOffsets(this.slotItems, items, true);
        this.slotItems = null;
    }
    setSlotsHeight(height) {
        //setting the first slot height should be sufficient
        this.timeRanges[0].setSlotsHeight(height);
    }
    get items() {
        return this.timeRanges.reduce((acc, range) => acc.concat(range.items), []);
    }
    get slots() {
        return this.timeRanges.reduce((acc, range) => acc.concat(range.slots), []);
    }
    get hasSlots() {
        return Boolean(this.dayRanges.find(range => range && range.hasSlots) || this.timeRanges.find(range => range && range.hasSlots));
    }
    cleanRanges() {
        this.dayRanges = this.dayRanges.filter(r => Boolean(r));
        this.timeRanges = this.timeRanges.filter(r => Boolean(r));
    }
    itemRange(component) {
        const task = component.item;
        const ranges = task.isAllDay ? this.dayRanges : this.timeRanges;
        if (isNumber(task.rangeIndex)) {
            return ranges[task.rangeIndex];
        }
        return ranges.find(r => intersects(task.startTime, task.endTime, r.start, r.end));
    }
}
/**
 * @hidden
 */
class DayTimeSlotService extends BaseSlotService {
    layoutDays(eventHeight = 25) {
        this.groups.forEach((group) => group.forEachDateRange(range => range?.slots.forEach(slot => {
            slot.element.nativeElement.style.height = '';
        })));
        const rowHeight = this.groups[0].dayRanges[0]?.slots[0].height;
        this.groups.forEach((group) => {
            group.forEachDateRange(range => range.initDaySlots(rowHeight, eventHeight));
        });
        this.groups.forEach((group) => {
            group.forEachDateRange(range => range.setDayOffsets());
        });
    }
    layoutTimeline(eventHeight, resourceRows) {
        this.groups.forEach((group) => group.forEachTimeRange(range => range?.slots.forEach(slot => {
            slot.element.nativeElement.style.height = '';
        })));
        const rowHeight = this.groups[0].timeRanges[0]?.slots[0].height;
        this.groups.forEach((group, index) => {
            group.initTimeSlots(rowHeight, eventHeight, resourceRows && resourceRows[index] ? resourceRows[index].nativeElement.children[0]?.children[0].offsetHeight : 0);
        });
        this.groups.forEach((group) => group.setTimelineOffsets());
    }
    layoutTimes(options) {
        this.groups.forEach((group) => group.forEachTimeRange(range => range.layout(options)));
    }
    forEachDateRange(callback) {
        this.groups.forEach((group, index) => {
            callback(group.dayRanges[0], index);
        });
    }
    syncDateRanges() {
        let maxHeight = 0;
        this.groups.forEach((group) => {
            const slot = group.dayRanges[0]?.firstSlot;
            if (slot) {
                maxHeight = Math.max(slot.rect.height - slot.padding, maxHeight);
            }
        });
        this.groups.forEach((group) => {
            group.dayRanges[0]?.setSlotsHeight(maxHeight);
        });
        return maxHeight;
    }
    forEachGroup(callback) {
        this.groups.forEach(callback);
    }
    forEachSlot(callback) {
        this.groups.forEach((group) => {
            group.dayRanges.forEach(range => {
                range?.slots.forEach(slot => callback(slot));
            });
            group.timeRanges.forEach(range => {
                range?.slots.forEach(slot => callback(slot));
            });
        });
    }
    createGroup(index) {
        return new DayTimeResourceGroup(index);
    }
    slotByIndex(slotIndex, allDay = false) {
        const [resourceIndex, rangeIndex, index] = slotIndex.split(':').map(part => parseInt(part, 10));
        return this.groups[resourceIndex][allDay ? 'dayRanges' : 'timeRanges'][rangeIndex]?.slots[index];
    }
    slotByPosition(x, y, isDaySlot, includeDayRanges) {
        let range;
        if (isDaySlot) {
            this.groups.find((group) => {
                range = group.dayRanges.find(r => rectContainsX(r.rect, x, this.calculateScaleX()));
                return range;
            });
            if (range) {
                return range.slots.find(slot => rectContainsX(slot.rect, x, this.calculateScaleX()));
            }
        }
        else {
            this.groups.find((group) => {
                if (includeDayRanges) {
                    range = group.dayRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
                }
                if (!range) {
                    range = group.timeRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
                }
                return range;
            });
            if (range) {
                return range.slots.find(slot => rectContains(slot.rect, x, y, this.calculateScaleX()));
            }
        }
    }
    groupSlotByPosition(currentSlot, x, y) {
        const group = this.groups[currentSlot.id.resourceIndex];
        let range;
        if (currentSlot.isDaySlot) {
            range = group.dayRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
        }
        else {
            range = group.timeRanges.find(r => rectContains(r.rect, x, y, this.calculateScaleX()));
        }
        if (range) {
            return range.slots.find(slot => rectContains(slot.rect, x, y, this.calculateScaleX()));
        }
    }
    dragRanges(currentSlot, offset, timeRanges) {
        const start = new Date(currentSlot.start.getTime() - offset.start);
        const end = new Date(currentSlot.start.getTime() + offset.end);
        const group = this.groups[currentSlot.id.resourceIndex];
        let result;
        if (timeRanges) {
            const slotRanges = [];
            group.timeRanges.forEach(range => {
                const slots = range?.slots.filter(s => intersects(start, end, s.start, s.end));
                if (slots.length) {
                    slotRanges.push(slots);
                }
            });
            const lastRange = slotRanges[slotRanges.length - 1];
            result = [slotRanges[0][0], lastRange[lastRange.length - 1]];
        }
        else {
            result = group.slotRange(currentSlot)?.slots.filter(s => intersects(start, end, s.start, s.end));
        }
        return {
            start,
            end,
            ranges: [result]
        };
    }
    resizeRanges(currentSlot, task, resizeStart, offset) {
        const group = this.groups[currentSlot.id.resourceIndex];
        const ranges = task.isAllDay ? group.dayRanges : group.timeRanges;
        const result = [];
        const startDate = task.start.toUTCDate();
        const endDate = task.end.toUTCDate();
        let start, end;
        if (resizeStart) {
            const startTime = currentSlot.start.getTime() + offset.start;
            end = startDate.getTime() === endDate.getTime() ? this.findDateSlot(endDate, ranges, true).end : endDate;
            if (startTime >= endDate.getTime()) {
                if (task.isAllDay) {
                    start = new Date(Math.min(dateWithTime(endDate, startDate).getTime(), endDate.getTime()));
                }
                else {
                    start = this.findDateSlot(end, ranges).start;
                }
            }
            else if (offset.start && task.isAllDay) {
                start = new Date(startTime);
            }
            else {
                start = new Date(currentSlot.start.getTime());
            }
        }
        else {
            start = startDate;
            if (currentSlot.start.getTime() <= start.getTime()) {
                if (task.isAllDay) {
                    end = new Date(Math.max(dateWithTime(startDate, endDate).getTime(), startDate.getTime()));
                }
                else {
                    end = this.findDateSlot(start, ranges, true).end;
                }
            }
            else if (offset.end && task.isAllDay) {
                end = new Date(currentSlot.start.getTime() + offset.end);
            }
            else {
                end = currentSlot.end;
            }
        }
        ranges.forEach(range => {
            const slots = range.slots.filter(s => intersects(start, end, s.start, s.end));
            if (slots.length) {
                result.push(slots);
            }
        });
        return {
            start,
            end,
            ranges: result
        };
    }
    timePosition(date, resourceIndex, vertical) {
        const group = this.groups[resourceIndex];
        const range = group.timeRanges.find(r => dateInRange(date, r.start, r.end));
        if (!range) {
            return;
        }
        const slot = range.slots.find(s => dateInRange(date, s.start, s.end));
        if (slot) {
            const position = (vertical ? slot.height : slot.width) *
                ((date.getTime() - slot.start.getTime()) / (slot.end.getTime() - slot.start.getTime()));
            return vertical ? slot.rect.top + position : slot.rect.left + position;
        }
    }
    findDateSlot(date, ranges, excludeEnd) {
        let result;
        ranges.forEach(range => {
            const slots = excludeEnd ? range.slots.filter(s => intersects(date, date, s.start, s.end)) :
                range.slots.filter(s => dateInRange(date, s.start, s.end));
            if (slots.length) {
                result = slots[0];
            }
        });
        return result;
    }
}

/** @hidden */
const isMultiDay = ({ start, end }) => {
    const startDate = start.stripTime();
    const endDate = end.stripTime();
    return startDate.getTime() !== endDate.getTime() &&
        (endDate.getTime() !== end.getTime() || startDate.addDays(1).getTime() !== endDate.getTime());
};
//check start and times or update day ranges to have them
/** @hidden */
const createTasks$2 = (periodStart, periodEnd, items, ranges) => {
    const tasks = [];
    const utcStart = toUTCDate(periodStart);
    const utcEnd = toUTCDate(periodEnd);
    for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const multiDay = isMultiDay(item);
        const multipleRanges = multiDay && !item.event.isAllDay;
        const isAllDay = typeof item.event.isAllDay === 'boolean' ? item.event.isAllDay : (multiDay && !multipleRanges);
        const endTime = (isAllDay ? roundAllDayEnd(item) : item.end).toUTCDate();
        const startTime = (isAllDay ? item.start.stripTime() : item.start).toUTCDate();
        for (let rangeIndex = 0; rangeIndex < ranges.length; rangeIndex++) {
            const rangeStart = ranges[rangeIndex].start;
            const rangeEnd = ranges[rangeIndex].end;
            if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
                const task = {
                    index,
                    isAllDay,
                    startTime,
                    endTime,
                    rangeIndex: isAllDay ? 0 : rangeIndex,
                    start: item.start,
                    end: item.end,
                    event: item.event
                };
                tasks.push(task);
                if (!multipleRanges) {
                    task.head = utcEnd < endTime;
                    task.tail = startTime < utcStart;
                    break;
                }
                else {
                    const nextRange = ranges[rangeIndex + 1];
                    const previousRange = ranges[rangeIndex - 1];
                    task.head = (nextRange ? nextRange.start : utcEnd) < endTime;
                    task.tail = startTime < (previousRange ? previousRange.end : utcStart);
                }
            }
        }
    }
    return sortTasksByTime(tasks);
};

/**
 * @hidden
 */
function createTimeSlots(intlService, { showWorkHours, startTime, endTime, workDayStart, workDayEnd, slotDivisions, slotDuration }) {
    const startDate = intlService.parseDate(showWorkHours ? workDayStart : startTime);
    const start = toInvariantTime(startDate).getTime();
    const endDate = intlService.parseDate(showWorkHours ? workDayEnd : endTime);
    let end = toInvariantTime(endDate).getTime();
    if (end <= start) {
        end = toInvariantTime(MIDNIGHT_INVARIANT).getTime() + MS_PER_DAY;
    }
    const slots = [];
    const duration = Math.round((slotDuration / slotDivisions) * MS_PER_MINUTE);
    let slotTime = start;
    let index = 0;
    while (slotTime < end) {
        slots.push({
            start: new Date(slotTime),
            end: new Date(slotTime + duration),
            isMajor: index % slotDivisions === 0
        });
        index++;
        slotTime += duration;
    }
    return slots;
}

/**
 * @hidden
 */
class DayTimeViewItemComponent extends BaseViewItem {
    constructor(intlService, slotService, localization, focusService, element, renderer, localeId) {
        super(slotService, localization, focusService, element, renderer, localeId);
        this.intlService = intlService;
        this.localeId = localeId;
        this.caretAltLeftIcon = caretAltLeftIcon;
        this.caretAltRightIcon = caretAltRightIcon;
        this.caretAltUpIcon = caretAltUpIcon;
        this.caretAltDownIcon = caretAltDownIcon;
        this.arrowRotateCwIcon = arrowRotateCwIcon;
        this.arrowsNoRepeatIcon = arrowsNoRepeatIcon;
        this.xIcon = xIcon;
    }
    get eventTime() {
        return this.intlService.format('{0:t}–{1:t}', toLocalDate(this.item.startTime), toLocalDate(this.item.endTime));
    }
}
DayTimeViewItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewItemComponent, deps: [{ token: i1$2.IntlService }, { token: DayTimeSlotService }, { token: i1$1.LocalizationService }, { token: FocusService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
DayTimeViewItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: DayTimeViewItemComponent, isStandalone: true, selector: "[dayTimeViewItem]", inputs: { vertical: "vertical", isAllDay: "isAllDay" }, usesInheritance: true, ngImport: i0, template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail && !vertical"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template k-event-time" *ngIf="!isAllDay">{{ eventTime }}</div>
            <div class="k-event-template" aria-hidden="true">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head && !vertical"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <span class="k-event-top-actions" *ngIf="item.tail && vertical">
            <kendo-icon-wrapper name="caret-alt-up" [svgIcon]="caretAltUpIcon"></kendo-icon-wrapper>
        </span>

        <span class="k-event-bottom-actions" *ngIf="item.head && vertical">
            <kendo-icon-wrapper name="caret-alt-down" [svgIcon]="caretAltDownIcon"></kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable && vertical">
            <span class="k-resize-handle k-resize-n" *ngIf="!item.tail"></span>
            <span class="k-resize-handle k-resize-s" *ngIf="!item.head"></span>
        </ng-container>

        <ng-container *ngIf="resizable && !vertical">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewItemComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: '[dayTimeViewItem]',
                    template: `
        <span class="k-event-actions">
            <kendo-icon-wrapper
                *ngIf="item.tail && !vertical"
                [name]="arrowIcons[0]"
                [svgIcon]="arrowSVGIcons[0]"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrence"
                name="arrow-rotate-cw"
                [svgIcon]="arrowRotateCwIcon"
                >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isRecurrenceException"
                name="arrows-no-repeat"
                [svgIcon]="arrowsNoRepeatIcon"
                >
            </kendo-icon-wrapper>
        </span>
        <ng-container *ngIf="eventTemplate" [ngTemplateOutlet]="eventTemplate"
            [ngTemplateOutletContext]="{ $implicit: item.event, event: item.event, resources: resources }">
        </ng-container>
        <div *ngIf="!eventTemplate" [attr.title]="eventTitle">
            <div class="k-event-template k-event-time" *ngIf="!isAllDay">{{ eventTime }}</div>
            <div class="k-event-template" aria-hidden="true">{{ item.event.title }}</div>
        </div>

        <span class="k-event-actions">
            <span *ngIf="removable" class="k-link k-event-delete" aria-hidden="true" [attr.title]="deleteMessage">
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"></kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="item.head && !vertical"
                [name]="arrowIcons[1]"
                [svgIcon]="arrowSVGIcons[1]"
                >
            </kendo-icon-wrapper>
        </span>

        <span class="k-event-top-actions" *ngIf="item.tail && vertical">
            <kendo-icon-wrapper name="caret-alt-up" [svgIcon]="caretAltUpIcon"></kendo-icon-wrapper>
        </span>

        <span class="k-event-bottom-actions" *ngIf="item.head && vertical">
            <kendo-icon-wrapper name="caret-alt-down" [svgIcon]="caretAltDownIcon"></kendo-icon-wrapper>
        </span>

        <ng-container *ngIf="resizable && vertical">
            <span class="k-resize-handle k-resize-n" *ngIf="!item.tail"></span>
            <span class="k-resize-handle k-resize-s" *ngIf="!item.head"></span>
        </ng-container>

        <ng-container *ngIf="resizable && !vertical">
            <span class="k-resize-handle k-resize-w"></span>
            <span class="k-resize-handle k-resize-e"></span>
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: DayTimeSlotService }, { type: i1$1.LocalizationService }, { type: FocusService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { vertical: [{
                type: Input
            }], isAllDay: [{
                type: Input
            }] } });

const getStartDate = date => getDate(date);
const getEndDate = (start, numberOfDays) => getDate(addDays(start, numberOfDays || 1));
const getNextDate = (date, count, numberOfDays) => getDate(addDays(date, numberOfDays * count));
/**
 * @hidden
 */
class DayTimeViewComponent extends BaseView {
    constructor(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollBarWidthService) {
        super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
        this.changeDetector = changeDetector;
        this.numberOfDays = 1;
        this.startTime = '00:00';
        this.endTime = '00:00';
        this.workDayStart = '08:00';
        this.workDayEnd = '17:00';
        this.workWeekStart = 1;
        this.workWeekEnd = 5;
        this.slotDuration = 60;
        this.slotDivisions = 2;
        this.showWorkHours = false;
        this.getStartDate = getStartDate;
        this.getEndDate = getEndDate;
        this.getNextDate = getNextDate;
        this.daySlots = [];
        this.timeSlots = [];
        this.resizeHintFormat = 't';
        this.showCurrentTime = false;
        this.verticalTime = true;
        this.initialUpdate = true;
        this.updateCurrentTime = this.updateCurrentTime.bind(this);
        this.toggleOngoingClass = this.toggleOngoingClass.bind(this);
        this.updateOngoingEvents = this.updateOngoingEvents.bind(this);
    }
    get classNames() {
        return `k-scheduler-${this.name}view`;
    }
    get timeSlotTemplateRef() {
        return this.timeSlotTemplate || (this.schedulerTimeSlotTemplate || {}).templateRef;
    }
    get dateHeaderTemplateRef() {
        return this.dateHeaderTemplate || (this.schedulerDateHeaderTemplate || {}).templateRef;
    }
    get majorTimeHeaderTemplateRef() {
        return this.majorTimeHeaderTemplate || (this.schedulerMajorTimeHeaderTemplate || {}).templateRef;
    }
    get minorTimeHeaderTemplateRef() {
        return this.minorTimeHeaderTemplate || (this.schedulerMinorTimeHeaderTemplate || {}).templateRef;
    }
    ngOnChanges(changes) {
        if (changes.startTime || changes.endTime || changes.showWorkHours || changes.workDayStart || changes.workDayEnd ||
            changes.workWeekStart || changes.workWeekEnd || changes.slotDivisions || changes.slotDuration) {
            this.timeSlots = this.createTimeSlots();
            this.initWorkDay();
            this.changes.next(null);
        }
        if (isChanged('currentTimeMarker', changes)) {
            this.showCurrentTime = this.enableCurrentTime();
        }
        if (isChanged('weekStart', changes)) {
            this.onSelectDate(this.selectedDate);
        }
        super.ngOnChanges(changes);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        clearTimeout(this.currentTimeTimeout);
        clearTimeout(this.ongoingEventsTimeout);
    }
    verticalItem(leafIndex, resourceIndex) {
        const data = this.verticalResources[resourceIndex].data || [];
        const resources = this.verticalResources;
        let result = 1;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= ((resources[idx].data || []).length || 1);
        }
        return data[(leafIndex / result) % data.length];
    }
    timeSlotClass(slot, date, resourceIndex) {
        if (this.slotClass) {
            return this.slotClass({
                start: dateWithTime(date, slot.start),
                end: dateWithTime(date, slot.end),
                resources: this.resourcesByIndex(resourceIndex),
                isAllDay: false
            });
        }
    }
    toggleOngoingClass() {
        const now = this.currentTime();
        const cssClass = isPresent(this.highlightOngoingEvents.cssClass) ? this.highlightOngoingEvents.cssClass : ONGOING_EVENT_CSS_CLASS;
        this.eventElements.forEach((event) => {
            const isOngoing = dateInRange(now, event.item.start, event.item.end);
            this.renderer[isOngoing ? 'addClass' : 'removeClass'](event.nativeElement, cssClass);
        });
    }
    scrollToTime(time = this.scrollTime) {
        let date;
        if (typeof time === 'string') {
            const scrollDate = this.intl.parseDate(time);
            if (!scrollDate) {
                return;
            }
            date = toUTCTime(this.daySlots[0].start, scrollDate);
        }
        else {
            date = toUTCDateTime(time);
        }
        const position = this.slotService.timePosition(date, 0, this.verticalTime);
        if (isNumber(position)) {
            const contentElement = this.content.nativeElement;
            contentElement[this.verticalTime ? 'scrollTop' : 'scrollLeft'] =
                (this.localization.rtl && !this.verticalTime) ? rtlScrollPosition(contentElement, position) : position;
        }
    }
    optionsChange(options) {
        this.schedulerTimeSlotTemplate = options.timeSlotTemplate;
        this.schedulerDateHeaderTemplate = options.dateHeaderTemplate;
        this.schedulerMajorTimeHeaderTemplate = options.majorTimeHeaderTemplate;
        this.schedulerMinorTimeHeaderTemplate = options.minorTimeHeaderTemplate;
        super.optionsChange(options);
    }
    updateView() {
        super.updateView();
        this.updateCurrentTime();
        this.updateOngoingEvents();
        if (this.initialUpdate) {
            this.scrollToTime();
            this.initialUpdate = false;
        }
    }
    enableCurrentTime() {
        if (!this.currentTimeMarker || this.currentTimeMarker.enabled === false || !this.selectedDate) {
            return false;
        }
        const dateRange = this.dateRange();
        this.currentDate = ZonedDate.fromLocalDate(this.currentTime(), this.currentTimeMarker.localTimezone !== false ? '' : this.timezone);
        const localTime = this.currentDate.toLocalDate();
        const invariantTime = toInvariantTime(localTime);
        const timeSlots = this.timeSlots;
        const inDateRange = dateInRange(localTime, dateRange.start, dateRange.end);
        const inTimeRange = timeSlots.length && dateInRange(invariantTime, timeSlots[0].start, timeSlots[timeSlots.length - 1].end);
        return inDateRange && inTimeRange;
    }
    currentTime() {
        return new Date();
    }
    updateCurrentTime() {
        if (!isDocumentAvailable()) {
            return;
        }
        const enable = this.enableCurrentTime();
        if (enable !== this.showCurrentTime) {
            this.showCurrentTime = enable;
            this.changeDetector.detectChanges();
        }
        clearTimeout(this.currentTimeTimeout);
        if (enable) {
            this.zone.runOutsideAngular(() => {
                this.currentTimeTimeout = setTimeout(this.updateCurrentTime, this.currentTimeMarker.updateInterval || MS_PER_MINUTE);
            });
            this.positionCurrentTime();
        }
    }
    updateOngoingEvents() {
        const disabled = !this.highlightOngoingEvents || this.highlightOngoingEvents.enabled === false;
        if (!isDocumentAvailable() || disabled) {
            return;
        }
        clearTimeout(this.ongoingEventsTimeout);
        this.zone.runOutsideAngular(() => {
            this.ongoingEventsTimeout = setTimeout(this.updateOngoingEvents, this.highlightOngoingEvents.updateInterval || MS_PER_MINUTE);
        });
        this.toggleOngoingClass();
    }
    positionCurrentTime() {
        if (this.currentTimeElements && this.currentTimeElements.length) {
            const date = this.currentDate.toUTCDate();
            const currentTimeArrows = this.currentTimeArrows ? this.currentTimeArrows.toArray() : [];
            const arrowOffset = currentTimeArrows.length ? this.currentTimeArrowOffset() : 0;
            const arrowMid = currentTimeArrows.length ? (currentTimeArrows[0].nativeElement.offsetHeight / 2) : 4;
            const tableWidth = this.contentTable.nativeElement.clientWidth;
            const tableHeight = this.contentTable.nativeElement.clientHeight;
            const vertical = this.verticalTime;
            this.currentTimeElements.forEach((element, index) => {
                const position = this.slotService.timePosition(date, index, vertical);
                if (position !== undefined) {
                    const line = element.nativeElement;
                    if (currentTimeArrows[index]) {
                        const arrow = currentTimeArrows[index].nativeElement;
                        const origin = vertical ? arrowOffset : position - arrowMid;
                        setCoordinates(arrow, {
                            top: vertical ? position - arrowMid : arrowOffset,
                            left: origin,
                            right: origin
                        });
                    }
                    const origin = vertical ? 0 : position;
                    setCoordinates(line, {
                        top: vertical ? position : 0,
                        left: origin,
                        right: origin,
                        width: vertical ? tableWidth : 1,
                        height: vertical ? 1 : tableHeight
                    });
                }
            });
        }
    }
    bindEvents() {
        super.bindEvents();
        this.zone.runOutsideAngular(() => {
            this.subs.add(fromClick(this.headerWrap.nativeElement)
                .subscribe(e => this.onHeaderClick(e)));
            this.subs.add(fromEvent(this.headerWrap.nativeElement, 'contextmenu')
                .subscribe(e => this.onClick(e)));
            this.subs.add(fromDoubleClick(this.headerWrap.nativeElement)
                .subscribe(e => this.onClick(e, 'dblclick')));
        });
    }
    onHeaderClick(e) {
        this.onClick(e);
        if (this.daySlots.length <= 1) {
            return;
        }
        const daySlotIndex = e.target.getAttribute('data-dayslot-index');
        if (daySlotIndex) {
            const slot = this.daySlots[parseInt(daySlotIndex, 10)];
            this.zone.run(() => {
                this.viewState.navigateTo({ viewName: 'day', date: slot.start });
            });
        }
    }
    slotByIndex(slotIndex, args) {
        return this.slotService.slotByIndex(slotIndex, args.target.hasAttribute('data-day-slot'));
    }
    onSelectDate(date) {
        this.selectedDate = date;
        this.daySlots = this.createDaySlots();
        this.showCurrentTime = this.enableCurrentTime();
        this.viewState.notifyDateRange(this.dateRange());
    }
    onAction(e) {
        const now = getDate(this.selectedDate);
        if (e.type === 'next') {
            const next = this.getNextDate(now, 1, this.numberOfDays);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'prev') {
            const next = this.getNextDate(now, -1, this.numberOfDays);
            if (this.isInRange(next)) {
                this.viewState.notifyNextDate(next);
            }
        }
        if (e.type === 'scroll-time') {
            this.scrollToTime(e.time);
        }
    }
    dateRange(date = this.selectedDate) {
        const start = this.getStartDate(date);
        const end = this.getEndDate(start, this.numberOfDays);
        const rangeEnd = this.getEndDate(start, this.numberOfDays - 1);
        const text = this.intl.format(this.selectedDateFormat, start, rangeEnd);
        const shortText = this.intl.format(this.selectedShortDateFormat, start, rangeEnd);
        return { start, end, text, shortText };
    }
    createDaySlots() {
        let current = this.getStartDate(this.selectedDate);
        const end = this.getEndDate(current, this.numberOfDays);
        const dates = [];
        while (current < end) {
            const next = addDays(current, 1);
            dates.push({
                start: current,
                end: next
            });
            current = next;
        }
        return dates;
    }
    createTimeSlots() {
        return createTimeSlots(this.intl, {
            showWorkHours: this.showWorkHours,
            startTime: this.startTime,
            endTime: this.endTime,
            workDayStart: this.workDayStart,
            workDayEnd: this.workDayEnd,
            slotDivisions: this.slotDivisions,
            slotDuration: this.slotDuration
        });
    }
    initWorkDay() {
        const startDate = this.intl.parseDate(this.workDayStart);
        this.workDayStartTime = toInvariantTime(startDate);
        const endDate = this.intl.parseDate(this.workDayEnd);
        if (endDate <= startDate) {
            this.workDayEndTime = addDays(MIDNIGHT_INVARIANT, 1);
        }
        else {
            this.workDayEndTime = toInvariantTime(endDate);
        }
    }
    slotByPosition(x, y, container) {
        const isDaySlot = container ? hasClasses(container.parentNode, 'k-scheduler-header-wrap') : y < 0;
        return this.slotService.slotByPosition(x, y, isDaySlot, Boolean(this.verticalResources.length));
    }
    slotFields(slot) {
        const fields = super.slotFields(slot);
        if (slot.isDaySlot) {
            fields.isAllDay = true;
        }
        else {
            fields.start = this.convertDate(slot.start);
            fields.end = this.convertDate(slot.end);
        }
        return fields;
    }
}
DayTimeViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: DayTimeSlotService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: PDFService }, { token: i1$1.LocalizationService }, { token: i7.ScrollbarWidthService }], target: i0.ɵɵFactoryTarget.Component });
DayTimeViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: DayTimeViewComponent, selector: "kendo-day-time-view", inputs: { timeSlotTemplate: "timeSlotTemplate", dateHeaderTemplate: "dateHeaderTemplate", majorTimeHeaderTemplate: "majorTimeHeaderTemplate", minorTimeHeaderTemplate: "minorTimeHeaderTemplate", numberOfDays: "numberOfDays", scrollTime: "scrollTime", startTime: "startTime", endTime: "endTime", workDayStart: "workDayStart", workDayEnd: "workDayEnd", workWeekStart: "workWeekStart", workWeekEnd: "workWeekEnd", slotDuration: "slotDuration", slotDivisions: "slotDivisions", showWorkHours: "showWorkHours", getStartDate: "getStartDate", getEndDate: "getEndDate", getNextDate: "getNextDate", currentTimeMarker: "currentTimeMarker", highlightOngoingEvents: "highlightOngoingEvents" }, viewQueries: [{ propertyName: "currentTimeElements", predicate: ["currentTimeMarker"], descendants: true }, { propertyName: "eventElements", predicate: DayTimeViewItemComponent, descendants: true }, { propertyName: "currentTimeArrows", predicate: ["currentTimeArrow"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'kendo-day-time-view', template: '' }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: DayTimeSlotService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: PDFService }, { type: i1$1.LocalizationService }, { type: i7.ScrollbarWidthService }]; }, propDecorators: { timeSlotTemplate: [{
                type: Input
            }], dateHeaderTemplate: [{
                type: Input
            }], majorTimeHeaderTemplate: [{
                type: Input
            }], minorTimeHeaderTemplate: [{
                type: Input
            }], numberOfDays: [{
                type: Input
            }], scrollTime: [{
                type: Input
            }], startTime: [{
                type: Input
            }], endTime: [{
                type: Input
            }], workDayStart: [{
                type: Input
            }], workDayEnd: [{
                type: Input
            }], workWeekStart: [{
                type: Input
            }], workWeekEnd: [{
                type: Input
            }], slotDuration: [{
                type: Input
            }], slotDivisions: [{
                type: Input
            }], showWorkHours: [{
                type: Input
            }], getStartDate: [{
                type: Input
            }], getEndDate: [{
                type: Input
            }], getNextDate: [{
                type: Input
            }], currentTimeMarker: [{
                type: Input
            }], highlightOngoingEvents: [{
                type: Input
            }], currentTimeElements: [{
                type: ViewChildren,
                args: ['currentTimeMarker']
            }], eventElements: [{
                type: ViewChildren,
                args: [DayTimeViewItemComponent]
            }], currentTimeArrows: [{
                type: ViewChildren,
                args: ['currentTimeArrow']
            }] } });

/**
 * @hidden
 */
class TimeSlotDirective extends BaseSlotDirective {
    constructor(element, slotService, localization) {
        super(element, slotService, localization);
        this.isDaySlot = false;
    }
    get nonWorkHour() {
        const date = this.date.getDay();
        return this.invariantStart < this.workDayStart || this.workDayEnd < this.invariantEnd || !isWorkWeekDay(date, this.workWeekStart, this.workWeekEnd);
    }
    get startLocalTime() {
        if (!this.date || !this.invariantStart) {
            return null;
        }
        return dateWithTime(this.date, this.invariantStart);
    }
    get endLocalTime() {
        if (!this.date || !this.invariantEnd) {
            return null;
        }
        return dateWithTime(this.date, this.invariantEnd);
    }
    get start() {
        if (!this.date || !this.invariantStart) {
            return null;
        }
        return toUTCTime(this.date, this.invariantStart);
    }
    get end() {
        if (!this.date || !this.invariantEnd) {
            return null;
        }
        const localEnd = toUTCTime(this.date, this.invariantEnd);
        if (INVARIANT_END.getTime() <= this.invariantEnd.getTime()) {
            return addUTCDays(localEnd, 1);
        }
        return localEnd;
    }
}
TimeSlotDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeSlotDirective, deps: [{ token: i0.ElementRef }, { token: DayTimeSlotService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
TimeSlotDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: TimeSlotDirective, isStandalone: true, selector: "[timeSlot]", inputs: { invariantStart: "invariantStart", invariantEnd: "invariantEnd", workDayStart: "workDayStart", workDayEnd: "workDayEnd", workWeekStart: "workWeekStart", workWeekEnd: "workWeekEnd", date: "date" }, host: { properties: { "class.k-nonwork-hour": "this.nonWorkHour" } }, exportAs: ["timeSlot"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimeSlotDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[timeSlot]',
                    exportAs: 'timeSlot',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DayTimeSlotService }, { type: i1$1.LocalizationService }]; }, propDecorators: { invariantStart: [{
                type: Input
            }], invariantEnd: [{
                type: Input
            }], workDayStart: [{
                type: Input
            }], workDayEnd: [{
                type: Input
            }], workWeekStart: [{
                type: Input
            }], workWeekEnd: [{
                type: Input
            }], date: [{
                type: Input
            }], nonWorkHour: [{
                type: HostBinding,
                args: ['class.k-nonwork-hour']
            }] } });
/**
 * @hidden
 */
class DaySlotDirective extends BaseSlotDirective {
    constructor(element, slotService, localization) {
        super(element, slotService, localization);
        this.isDaySlot = true;
    }
    set start(value) {
        this.startDate = value;
    }
    get start() {
        if (!this.startDate) {
            return null;
        }
        return toUTCDate(this.startDate);
    }
    set end(value) {
        this.endDate = value;
    }
    get end() {
        if (!this.endDate) {
            return null;
        }
        return toUTCDate(this.endDate);
    }
    get daySlot() {
        return true;
    }
}
DaySlotDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DaySlotDirective, deps: [{ token: i0.ElementRef }, { token: DayTimeSlotService }, { token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Directive });
DaySlotDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: DaySlotDirective, isStandalone: true, selector: "[daySlot]", inputs: { start: "start", end: "end" }, host: { properties: { "attr.data-day-slot": "this.daySlot" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DaySlotDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[daySlot]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: DayTimeSlotService }, { type: i1$1.LocalizationService }]; }, propDecorators: { start: [{
                type: Input
            }], end: [{
                type: Input
            }], daySlot: [{
                type: HostBinding,
                args: ['attr.data-day-slot']
            }] } });

/**
 * @hidden
 */
class MultiDayViewRendererComponent extends DayTimeViewComponent {
    constructor(localization, viewContext, viewState, intl, slotService, zone, renderer, element, changeDetector, pdfService, scrollbarWidthService) {
        super(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollbarWidthService);
        this.name = 'day';
        this.dateFormat = { skeleton: 'MEd' };
        this.allDayResizeHintFormat = { skeleton: 'Md' };
        this.allDayItems = new BehaviorSubject(null);
    }
    get allDaySlotTemplateRef() {
        return this.allDaySlotTemplate || (this.schedulerAllDaySlotTemplate || {}).templateRef;
    }
    get allDayEventTemplateRef() {
        return this.allDayEventTemplate || (this.schedulerAllDayEventTemplate || {}).templateRef;
    }
    get allDayMessage() {
        return this.localization.get('allDay');
    }
    get allDayResizeHint() {
        return this.resizing && this.resizing.task.isAllDay;
    }
    get allDayDragHint() {
        return this.dragging && this.dragging.slot.isDaySlot;
    }
    optionsChange(changes) {
        this.schedulerAllDaySlotTemplate = changes.allDaySlotTemplate;
        this.schedulerAllDayEventTemplate = changes.allDayEventTemplate;
        super.optionsChange(changes);
    }
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes.slotFill) {
            this.changes.next(null);
        }
        if (anyChanged(['startTime', 'endTime', 'showWorkHours', 'workDayStart',
            'workDayEnd', 'workWeekStart', 'workWeekEnd', 'allDaySlot'], changes)) {
            this.viewRangeChange.next(null);
        }
        if (isChanged('numberOfDays', changes, true /* skipFirstChange */) ||
            isChanged('weekStart', changes)) {
            this.daySlots = this.createDaySlots();
            this.viewState.notifyDateRange(this.dateRange());
        }
    }
    horizontalColspan(resourceIndex) {
        const resources = this.horizontalResources;
        let result = this.daySlots.length;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    verticalRowspan(resourceIndex) {
        const resources = this.verticalResources;
        let result = this.timeSlots.length + 1;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    allDaySlotClass(slot, resourceIndex) {
        if (this.slotClass) {
            return this.slotClass({
                start: slot.start,
                end: slot.end,
                resources: this.resourcesByIndex(resourceIndex),
                isAllDay: true
            });
        }
    }
    createTasks(items, dateRange) {
        const startTimeSlot = this.timeSlots[0];
        const endTimeSlot = this.timeSlots[this.timeSlots.length - 1].end;
        const nextDateEnd = !(endTimeSlot.getHours() || endTimeSlot.getMinutes());
        const ranges = this.daySlots.map(daySlot => ({
            start: toUTCTime(daySlot.start, startTimeSlot.start),
            end: nextDateEnd ? toUTCDate(daySlot.end) : toUTCTime(daySlot.start, endTimeSlot)
        }));
        return createTasks$2(dateRange.start, dateRange.end, items, ranges);
    }
    onTasksChange() {
        this.items.next(this.tasks.filter(task => !task.isAllDay));
        this.allDayItems.next(this.tasks.filter(task => task.isAllDay));
    }
    reflow() {
        const slotService = this.slotService;
        if (!this.verticalResources.length) {
            this.updateContentHeight();
            this.syncTables();
        }
        this.slotService.containerSize = this.content.nativeElement.clientWidth;
        slotService.layoutDays(this.eventHeight);
        this.updateContentHeight();
        this.syncTables();
        if (this.dayCells.length) {
            const cells = this.dayCells.toArray();
            if (this.verticalResources.length) {
                slotService.forEachDateRange((range, index) => {
                    const slot = range.firstSlot;
                    cells[index].nativeElement.style.height = `${slot.rect.height - slot.padding}px`;
                });
            }
            else {
                const size = slotService.syncDateRanges();
                cells[0].nativeElement.style.height = `${size}px`;
            }
        }
        slotService.layoutTimes({ fill: this.slotFill });
        this.syncTables();
    }
    dragHorizontal(slot) {
        return slot.isDaySlot;
    }
    updateHintContainer() {
        if (this.headerHintContainer) {
            this.headerHintContainer.detectChanges();
        }
        super.updateHintContainer();
    }
    onRelease(args) {
        super.onRelease(args);
        this.dragContainers = null;
    }
    updateDragContainer(args) {
        if (!this.dragContainers) {
            this.dragContainers = this.containers;
        }
        const container = this.dragContainers.find(c => {
            const offset = c.offset;
            return offset.top <= args.pageY && args.pageY <= offset.top + offset.height;
        }) || {};
        this.container = container.element;
        this.containerOffset = container.offset;
    }
    containerByPosition({ x, y }) {
        return this.containers.find(c => {
            const offset = c.offset;
            return offset.top <= y && y <= offset.top + offset.height && offset.left <= x && x <= offset.left + offset.width;
        });
    }
    get containers() {
        const header = this.headerWrap.nativeElement.children[1];
        const content = this.content.nativeElement;
        return [{
                element: content,
                offset: elementOffset(content)
            }, {
                element: header,
                offset: elementOffset(header)
            }];
    }
    scrollContainer(callback, args) {
        clearInterval(this.scrollInterval);
        if (this.container && this.container === this.content.nativeElement) {
            super.scrollContainer(callback, args);
        }
    }
    dragRanges(slot) {
        const task = this.dragging.task;
        if (slot.isDaySlot && !task.isAllDay) {
            return {
                ranges: [[slot]],
                start: dateWithTime(slot.start, task.start.toUTCDate()),
                end: dateWithTime(slot.start, task.end.toUTCDate()),
                isAllDay: true
            };
        }
        const allDayToTime = task.isAllDay && !slot.isDaySlot;
        const result = this.slotService.dragRanges(slot, allDayToTime ? { start: 0, end: 0 } : this.dragging.offset);
        if (allDayToTime) {
            result.end = slot.end;
        }
        result.isAllDay = this.draggedIsAllDay(task, slot);
        return result;
    }
    dragHintEventStyleArgs() {
        return {
            event: this.dragging.task.event,
            resources: this.dragging.resourceItems,
            isAllDay: Boolean(this.allDayDragHint)
        };
    }
    draggedIsAllDay(task, slot) {
        return Boolean(slot.isDaySlot && (task.event.isAllDay || !isMultiDay(task)));
    }
    dragHintSize(firstSlot, lastSlot) {
        let width, height;
        if (firstSlot.isDaySlot) {
            width = toPx(lastSlot.rect.left - firstSlot.rect.left + lastSlot.rect.width);
            height = toPx(firstSlot.height);
        }
        else {
            width = toPx(firstSlot.rect.width * 0.9);
            height = toPx(this.dragging.task.isAllDay ? firstSlot.rect.height : lastSlot.rect.top - firstSlot.rect.top + lastSlot.rect.height);
        }
        return { width, height };
    }
    currentTimeArrowOffset() {
        if (this.verticalResources.length) {
            const el = this.times.nativeElement.querySelector('.k-scheduler-times-all-day');
            const timesEl = this.times.nativeElement;
            return this.localization.rtl ? timesEl.offsetWidth - el.offsetWidth : el.offsetLeft;
        }
        return 0;
    }
    isMiddleSlot(index) {
        return index + 1 < this.timeSlots.length && !this.timeSlots[index + 1].isMajor;
    }
}
MultiDayViewRendererComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewRendererComponent, deps: [{ token: i1$1.LocalizationService }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: DayTimeSlotService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: PDFService }, { token: i7.ScrollbarWidthService }], target: i0.ɵɵFactoryTarget.Component });
MultiDayViewRendererComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MultiDayViewRendererComponent, isStandalone: true, selector: "multi-day-view", inputs: { allDaySlot: "allDaySlot", name: "name", slotFill: "slotFill", allDaySlotTemplate: "allDaySlotTemplate", allDayEventTemplate: "allDayEventTemplate" }, providers: [
        DayTimeSlotService
    ], viewQueries: [{ propertyName: "headerHintContainer", first: true, predicate: ["headerHintContainer"], descendants: true }, { propertyName: "dayCells", predicate: ["allDayCell"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
        <table class="k-scheduler-layout" role="presentation" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr [style.height]="'auto'">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr *ngIf="allDaySlot && !verticalResources.length">
                                        <th class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr class="k-scheduler-date-group">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                                <th *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ slot.start | kendoDate: dateFormat }}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                                <div [style.position]="'relative'" *ngIf="allDaySlot && !verticalResources.length">
                                    <table class="k-scheduler-table k-scheduler-header-all-day" aria-hidden="true">
                                        <tbody>
                                            <tr>
                                                <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                                    <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                        daySlot
                                                        [start]="slot.start"
                                                        [end]="slot.end"
                                                        [id]="{ resourceIndex: resourceIndex, rangeIndex: 0, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDate(slot.start),
                                                            end: toPlainDate(slot.end),
                                                            isAllDay: true,
                                                            resources: resourcesByIndex(resourceIndex)
                                                        })"
                                                        [ngClass]="allDaySlotClass(slot, resourceIndex)"
                                                        class="k-scheduler-cell">
                                                        <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                            [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(resourceIndex) }"></ng-container>
                                                    </td>
                                                </ng-container>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                        <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                            [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                            [ngStyle]="getEventStyles(item, itemResource, true)"
                                            role="button"
                                            [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                            [id]="item.elementId + '_' + itemResource.leafIdx"
                                            dayTimeViewItem
                                                [isAllDay]="true"
                                                [editable]="editable"
                                                [eventTemplate]="allDayEventTemplateRef"
                                                [item]="item"
                                                [index]="item.index"
                                                [rangeIndex]="item.rangeIndex"
                                                [resources]="itemResource.resources"
                                                [resourceIndex]="itemResource.leafIdx">
                                        </div>
                                    </ng-container>
                                    <kendo-hint-container #headerHintContainer>
                                        <ng-template>
                                            <div *ngIf="dragHints.length && allDayDragHint"
                                                class="k-event-drag-hint"
                                                dayTimeViewItem
                                                    [isAllDay]="true"
                                                    [ngStyle]="dragHints[0].style"
                                                    [ngClass]="dragHints[0].class"
                                                    [dragHint]="true"
                                                    [eventTemplate]="eventTemplateRef"
                                                    [item]="dragHints[0].item"
                                                    [resources]="dragHints[0].resources">
                                            </div>

                                            <div *ngIf="resizeHints.length && allDayResizeHint"
                                                kendoResizeHint
                                                    [hint]="resizeHints[0]"
                                                    [ngClass]="resizeHints[0].class"
                                                    [format]="allDayResizeHintFormat">
                                            </div>
                                        </ng-template>
                                    </kendo-hint-container>
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-right">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                        <tr *ngIf="verticalResources.length">
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-scheduler-cell k-slot-cell k-heading-cell">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th *ngIf="allDaySlot" class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; let timeSlotIndex = index;trackBy: itemIndex">
                                            <th *ngIf="slot.isMajor" [ngClass]="{ 'k-slot-cell': slotDivisions === 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ slot.start | kendoDate: 't' }}</ng-container>
                                                <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                            </th>
                                            <th *ngIf="!slot.isMajor" [ngClass]="{ 'k-slot-cell': timeSlotIndex % slotDivisions === slotDivisions - 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="minorTimeHeaderTemplateRef" [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }">
                                                </ng-container>
                                            </th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content" 
                            #content
                            role="group"
                            tabindex="0"
                            [attr.aria-owns]="matchOwned(items | async)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeMarker class="k-current-time">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <tr class="k-scheduler-header-all-day" *ngIf="allDaySlot && verticalResources.length">
                                            <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                daySlot
                                                [start]="slot.start"
                                                [end]="slot.end"
                                                [class.k-selected]="isSlotSelected({
                                                    start: toPlainDate(slot.start),
                                                    end: toPlainDate(slot.end),
                                                    isAllDay: true,
                                                    resources: resourcesByIndex(verticalIndex)
                                                })"
                                                [id]="{ resourceIndex: verticalIndex, rangeIndex: 0, index: index }">
                                                <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                    [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(verticalIndex) }"></ng-container>
                                            </td>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; index as index; trackBy: itemIndex" [class.k-middle-row]="isMiddleSlot(index)">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let daySlot of daySlots; index as rangeIndex; trackBy: itemIndex"
                                                    [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [vertical]="true"
                                        [eventTemplate]="eventTemplateRef"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <ng-container *ngIf="verticalResources.length">
                                <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                    <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                        [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                        [ngStyle]="getEventStyles(item, itemResource, true)"
                                        role="button"
                                        [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                        [id]="item.elementId + '_' + itemResource.leafIdx"
                                        dayTimeViewItem
                                            [isAllDay]="true"
                                            [editable]="editable"
                                            [eventTemplate]="allDayEventTemplateRef"
                                            [item]="item"
                                            [index]="item.index"
                                            [rangeIndex]="item.rangeIndex"
                                            [resources]="itemResource.resources"
                                            [resourceIndex]="itemResource.leafIdx">
                                    </div>
                                </ng-container>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngIf="dragHints.length && (!allDayDragHint || verticalResources.length)"
                                        class="k-event-drag-hint"
                                        role="button"
                                        dayTimeViewItem
                                            [isAllDay]="allDayDragHint"
                                            [ngStyle]="dragHints[0].style"
                                            [ngClass]="dragHints[0].class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [resources]="dragHints[0].resources"
                                            [item]="dragHints[0].item">
                                    </div>

                                    <ng-container *ngIf="resizeHints.length && (!allDayResizeHint || verticalResources.length)">
                                        <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                            kendoResizeHint
                                                [hint]="hint"
                                                [ngClass]="hint.class"
                                                [format]="allDayResizeHint ? allDayResizeHintFormat : resizeHintFormat">
                                        </div>
                                    </ng-container>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: DaySlotDirective, selector: "[daySlot]", inputs: ["start", "end"] }, { kind: "component", type: DayTimeViewItemComponent, selector: "[dayTimeViewItem]", inputs: ["vertical", "isAllDay"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "component", type: HintContainerComponent, selector: "kendo-hint-container" }, { kind: "component", type: ResizeHintComponent, selector: "[kendoResizeHint]", inputs: ["hint", "format"] }, { kind: "directive", type: TimeSlotDirective, selector: "[timeSlot]", inputs: ["invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "date"], exportAs: ["timeSlot"] }, { kind: "pipe", type: ResourceIteratorPipe, name: "resourceIterator" }, { kind: "pipe", type: DatePipe, name: "kendoDate" }, { kind: "pipe", type: AsyncPipe, name: "async" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewRendererComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'multi-day-view',
                    providers: [
                        DayTimeSlotService
                    ],
                    template: `
        <table class="k-scheduler-layout" role="presentation" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr [style.height]="'auto'">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                    <tr *ngIf="allDaySlot && !verticalResources.length">
                                        <th class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div class="k-scheduler-header" #header>
                            <div class="k-scheduler-header-wrap" #headerWrap>
                                <table class="k-scheduler-table" aria-hidden="true">
                                    <tbody>
                                        <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                            <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                                class="k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                                <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                                <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef" [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                            </th>
                                        </tr>
                                        <tr class="k-scheduler-date-group">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                                <th *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex" class="k-scheduler-cell k-heading-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ slot.start | kendoDate: dateFormat }}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </tr>
                                    </tbody>
                                </table>
                                <div [style.position]="'relative'" *ngIf="allDaySlot && !verticalResources.length">
                                    <table class="k-scheduler-table k-scheduler-header-all-day" aria-hidden="true">
                                        <tbody>
                                            <tr>
                                                <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                                    <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                        daySlot
                                                        [start]="slot.start"
                                                        [end]="slot.end"
                                                        [id]="{ resourceIndex: resourceIndex, rangeIndex: 0, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDate(slot.start),
                                                            end: toPlainDate(slot.end),
                                                            isAllDay: true,
                                                            resources: resourcesByIndex(resourceIndex)
                                                        })"
                                                        [ngClass]="allDaySlotClass(slot, resourceIndex)"
                                                        class="k-scheduler-cell">
                                                        <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                            [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(resourceIndex) }"></ng-container>
                                                    </td>
                                                </ng-container>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                        <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                            [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                            [ngStyle]="getEventStyles(item, itemResource, true)"
                                            role="button"
                                            [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                            [id]="item.elementId + '_' + itemResource.leafIdx"
                                            dayTimeViewItem
                                                [isAllDay]="true"
                                                [editable]="editable"
                                                [eventTemplate]="allDayEventTemplateRef"
                                                [item]="item"
                                                [index]="item.index"
                                                [rangeIndex]="item.rangeIndex"
                                                [resources]="itemResource.resources"
                                                [resourceIndex]="itemResource.leafIdx">
                                        </div>
                                    </ng-container>
                                    <kendo-hint-container #headerHintContainer>
                                        <ng-template>
                                            <div *ngIf="dragHints.length && allDayDragHint"
                                                class="k-event-drag-hint"
                                                dayTimeViewItem
                                                    [isAllDay]="true"
                                                    [ngStyle]="dragHints[0].style"
                                                    [ngClass]="dragHints[0].class"
                                                    [dragHint]="true"
                                                    [eventTemplate]="eventTemplateRef"
                                                    [item]="dragHints[0].item"
                                                    [resources]="dragHints[0].resources">
                                            </div>

                                            <div *ngIf="resizeHints.length && allDayResizeHint"
                                                kendoResizeHint
                                                    [hint]="resizeHints[0]"
                                                    [ngClass]="resizeHints[0].class"
                                                    [format]="allDayResizeHintFormat">
                                            </div>
                                        </ng-template>
                                    </kendo-hint-container>
                                </div>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-right">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                        <tr *ngIf="verticalResources.length">
                                            <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-scheduler-cell k-slot-cell k-heading-cell">
                                                    <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                    <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                        [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                </th>
                                            </ng-container>
                                            <th *ngIf="allDaySlot" class="k-scheduler-times-all-day k-scheduler-cell k-heading-cell" #allDayCell>{{ allDayMessage }}</th>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; let timeSlotIndex = index;trackBy: itemIndex">
                                            <th *ngIf="slot.isMajor" [ngClass]="{ 'k-slot-cell': slotDivisions === 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ slot.start | kendoDate: 't' }}</ng-container>
                                                <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }"></ng-container>
                                            </th>
                                            <th *ngIf="!slot.isMajor" [ngClass]="{ 'k-slot-cell': timeSlotIndex % slotDivisions === slotDivisions - 1 }" class="k-scheduler-cell k-heading-cell">
                                                <ng-container *ngIf="minorTimeHeaderTemplateRef" [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: slot.start }">
                                                </ng-container>
                                            </th>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content" 
                            #content
                            role="group"
                            tabindex="0"
                            [attr.aria-owns]="matchOwned(items | async)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of verticalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeMarker class="k-current-time">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation">
                                <tbody>
                                    <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <tr class="k-scheduler-header-all-day" *ngIf="allDaySlot && verticalResources.length">
                                            <td *ngFor="let slot of daySlots; let index = index; trackBy: itemIndex"
                                                daySlot
                                                [start]="slot.start"
                                                [end]="slot.end"
                                                [class.k-selected]="isSlotSelected({
                                                    start: toPlainDate(slot.start),
                                                    end: toPlainDate(slot.end),
                                                    isAllDay: true,
                                                    resources: resourcesByIndex(verticalIndex)
                                                })"
                                                [id]="{ resourceIndex: verticalIndex, rangeIndex: 0, index: index }">
                                                <ng-container *ngIf="allDaySlotTemplateRef" [ngTemplateOutlet]="allDaySlotTemplateRef"
                                                    [ngTemplateOutletContext]="{ date: slot.start, resources: resourcesByIndex(verticalIndex) }"></ng-container>
                                            </td>
                                        </tr>
                                        <tr *ngFor="let slot of timeSlots; index as index; trackBy: itemIndex" [class.k-middle-row]="isMiddleSlot(index)">
                                            <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let daySlot of daySlots; index as rangeIndex; trackBy: itemIndex"
                                                    [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                    timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </tr>
                                    </ng-container>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [vertical]="true"
                                        [eventTemplate]="eventTemplateRef"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <ng-container *ngIf="verticalResources.length">
                                <ng-container *ngFor="let item of allDayItems | async; trackBy: itemIndex;">
                                    <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                        [ngClass]="getEventClasses(item, itemResource.resources, true)"
                                        [ngStyle]="getEventStyles(item, itemResource, true)"
                                        role="button"
                                        [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                        [id]="item.elementId + '_' + itemResource.leafIdx"
                                        dayTimeViewItem
                                            [isAllDay]="true"
                                            [editable]="editable"
                                            [eventTemplate]="allDayEventTemplateRef"
                                            [item]="item"
                                            [index]="item.index"
                                            [rangeIndex]="item.rangeIndex"
                                            [resources]="itemResource.resources"
                                            [resourceIndex]="itemResource.leafIdx">
                                    </div>
                                </ng-container>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngIf="dragHints.length && (!allDayDragHint || verticalResources.length)"
                                        class="k-event-drag-hint"
                                        role="button"
                                        dayTimeViewItem
                                            [isAllDay]="allDayDragHint"
                                            [ngStyle]="dragHints[0].style"
                                            [ngClass]="dragHints[0].class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [resources]="dragHints[0].resources"
                                            [item]="dragHints[0].item">
                                    </div>

                                    <ng-container *ngIf="resizeHints.length && (!allDayResizeHint || verticalResources.length)">
                                        <div *ngFor="let hint of resizeHints; trackBy: itemIndex;"
                                            kendoResizeHint
                                                [hint]="hint"
                                                [ngClass]="hint.class"
                                                [format]="allDayResizeHint ? allDayResizeHintFormat : resizeHintFormat">
                                        </div>
                                    </ng-container>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
                    standalone: true,
                    imports: [NgClass, NgFor, NgIf, NgTemplateOutlet, DaySlotDirective, DayTimeViewItemComponent, NgStyle, FocusableDirective, HintContainerComponent, ResizeHintComponent, TimeSlotDirective, ResourceIteratorPipe, DatePipe, AsyncPipe]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: DayTimeSlotService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: PDFService }, { type: i7.ScrollbarWidthService }]; }, propDecorators: { allDaySlot: [{
                type: Input
            }], name: [{
                type: Input
            }], slotFill: [{
                type: Input
            }], allDaySlotTemplate: [{
                type: Input
            }], allDayEventTemplate: [{
                type: Input
            }], dayCells: [{
                type: ViewChildren,
                args: ['allDayCell']
            }], headerHintContainer: [{
                type: ViewChild,
                args: ['headerHintContainer', { static: false }]
            }] } });

/**
 * The component for rendering the **Day** view.
 */
class DayViewComponent extends MultiDayViewBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        /**
         * The invariant name for this view.
         * @default 'day'
         */
        this.name = 'day';
        this._selectedDateFormat = '{0:D}';
        this._selectedShortDateFormat = '{0:d}';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('dayViewTitle');
    }
    /**
     * The long-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * @default '{0:D}'
     */
    set selectedDateFormat(value) {
        this._selectedDateFormat = value;
    }
    get selectedDateFormat() {
        return this._selectedDateFormat;
    }
    /**
     * The short-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * @default '{0:d}'
     */
    set selectedShortDateFormat(value) {
        this._selectedShortDateFormat = value;
    }
    get selectedShortDateFormat() {
        return this._selectedShortDateFormat;
    }
}
DayViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
DayViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: DayViewComponent, isStandalone: true, selector: "kendo-scheduler-day-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => DayViewComponent)
        }], queries: [{ propertyName: "allDaySlotTemplate", first: true, predicate: AllDaySlotTemplateDirective, descendants: true }, { propertyName: "allDayEventTemplate", first: true, predicate: AllDayEventTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiDayViewRendererComponent, selector: "multi-day-view", inputs: ["allDaySlot", "name", "slotFill", "allDaySlotTemplate", "allDayEventTemplate"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-day-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => DayViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], allDaySlotTemplate: [{
                type: ContentChild,
                args: [AllDaySlotTemplateDirective, { static: false }]
            }], allDayEventTemplate: [{
                type: ContentChild,
                args: [AllDayEventTemplateDirective, { static: false }]
            }] } });

/**
 * The component for rendering the **Multi-Day** view.
 */
class MultiDayViewComponent extends DayViewComponent {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        /**
         * Specifies the number of days that the view will render.
         * @default 1
         */
        this.numberOfDays = 1;
        /**
         * The invariant name for this view.
         * @default 'multi-day'
         */
        this.name = 'multiDay';
    }
    /**
     * The long-date format for displaying the
     * selected date in the Scheduler toolbar.
     * Defaults to `{0:D} - {1:D}` for multiple days and `{0:D}` for a single day
     * ([more information](slug:parsingandformatting_intl#toc-date-formatting)).
     * @default '{0:D} - {1:D}'
     */
    set selectedDateFormat(value) {
        this.dateFormat = value;
    }
    get selectedDateFormat() {
        return this.dateFormat || this.defaultDateFormat;
    }
    /**
     * The short date format for displaying the
     * selected date in the Scheduler toolbar.
     * Defaults to `{0:d} - {1:d}` for multiple days and `{0:d}` for a single day
     * ([more information](slug:parsingandformatting_intl#toc-date-formatting)).
     * @default '{0:d} - {1:d}'
     */
    set selectedShortDateFormat(value) {
        this.shortDateFormat = value;
    }
    get selectedShortDateFormat() {
        return this.shortDateFormat || this.defaultShortDateFormat;
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('multiDayViewTitle');
    }
    get defaultDateFormat() {
        return this.numberOfDays === 1 ? '{0:D}' : '{0:D} - {1:D}';
    }
    get defaultShortDateFormat() {
        return this.numberOfDays === 1 ? '{0:d}' : '{0:d} - {1:d}';
    }
}
MultiDayViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
MultiDayViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: MultiDayViewComponent, isStandalone: true, selector: "kendo-scheduler-multi-day-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfDays: "numberOfDays" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => MultiDayViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <multi-day-view
                viewName="day"
                [allDaySlot]="allDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiDayViewRendererComponent, selector: "multi-day-view", inputs: ["allDaySlot", "name", "slotFill", "allDaySlotTemplate", "allDayEventTemplate"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-multi-day-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => MultiDayViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <multi-day-view
                viewName="day"
                [allDaySlot]="allDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfDays: [{
                type: Input
            }] } });

/**
 * The component for rendering the **Week** view.
 */
class WeekViewComponent extends MultiDayViewBase {
    constructor(intl, localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        this.intl = intl;
        /**
         * The long-date format for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:D} - {1:D}`,
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting).
         * @default '{0:D} - {1:D}'
         */
        this.selectedDateFormat = '{0:D} - {1:D}';
        /**
         * The short date format for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:d} - {1:d}`,
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting).
         * @default '{0:d} - {1:d}'
         */
        this.selectedShortDateFormat = '{0:d} - {1:d}';
        /**
         * The invariant name for this view.
         * @default 'week'
         */
        this.name = 'week';
        this.getStartDate = this.getStartDate.bind(this);
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('weekViewTitle');
    }
    /**
     * @hidden
     */
    getStartDate(selectedDate) {
        return firstDayInWeek(getDate(selectedDate), this.viewWeekStart);
    }
}
WeekViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WeekViewComponent, deps: [{ token: i1$2.IntlService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
WeekViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: WeekViewComponent, isStandalone: true, selector: "kendo-scheduler-week-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => WeekViewComponent)
        }], queries: [{ propertyName: "allDaySlotTemplate", first: true, predicate: AllDaySlotTemplateDirective, descendants: true }, { propertyName: "allDayEventTemplate", first: true, predicate: AllDayEventTemplateDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [numberOfDays]="7"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiDayViewRendererComponent, selector: "multi-day-view", inputs: ["allDaySlot", "name", "slotFill", "allDaySlotTemplate", "allDayEventTemplate"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WeekViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-week-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => WeekViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <multi-day-view
                [name]="name"
                [allDaySlot]="viewAllDaySlot"
                [numberOfDays]="7"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], allDaySlotTemplate: [{
                type: ContentChild,
                args: [AllDaySlotTemplateDirective, { static: false }]
            }], allDayEventTemplate: [{
                type: ContentChild,
                args: [AllDayEventTemplateDirective, { static: false }]
            }] } });

const DAYS_IN_WEEK = 7;
/**
 * The component for rendering the **Work Week** view.
 */
class WorkWeekViewComponent extends WeekViewComponent {
    constructor(intl, localization, changeDetector, viewContext, viewState) {
        super(intl, localization, changeDetector, viewContext, viewState);
        /**
         * The invariant name for this view.
         * @default 'workWeek'
         */
        this.name = 'workWeek';
        this.getNextDate = this.getNextDate.bind(this);
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('workWeekViewTitle');
    }
    /**
     * @hidden
     */
    get numberOfDays() {
        if (this.viewWorkWeekStart > this.viewWorkWeekEnd) {
            return (DAYS_IN_WEEK - this.viewWorkWeekStart + this.viewWorkWeekEnd) + 1;
        }
        return (this.viewWorkWeekEnd - this.viewWorkWeekStart) + 1;
    }
    /**
     * @hidden
     */
    getStartDate(selectedDate) {
        return firstDayInWeek(getDate(selectedDate), this.viewWorkWeekStart);
    }
    /**
     * @hidden
     */
    getNextDate(date, count, _numberOfDays) {
        return getDate(addDays(date, DAYS_IN_WEEK * count));
    }
}
WorkWeekViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WorkWeekViewComponent, deps: [{ token: i1$2.IntlService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
WorkWeekViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: WorkWeekViewComponent, isStandalone: true, selector: "kendo-scheduler-work-week-view", providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => WorkWeekViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <multi-day-view
                viewName="workWeekview"
                [allDaySlot]="viewAllDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [getStartDate]="getStartDate"
                [getNextDate]="getNextDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiDayViewRendererComponent, selector: "multi-day-view", inputs: ["allDaySlot", "name", "slotFill", "allDaySlotTemplate", "allDayEventTemplate"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: WorkWeekViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-work-week-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => WorkWeekViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <multi-day-view
                viewName="workWeekview"
                [allDaySlot]="viewAllDaySlot"
                [name]="name"
                [numberOfDays]="numberOfDays"
                [getStartDate]="getStartDate"
                [getNextDate]="getNextDate"
                [eventHeight]="viewEventHeight"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotFill]="viewSlotFill"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [allDaySlotTemplate]="allDaySlotTemplate?.templateRef"
                [allDayEventTemplate]="allDayEventTemplate?.templateRef"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MultiDayViewRendererComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; } });

const COLUMN_WIDTH = 'columnWidth';
/**
 * @hidden
 */
class TimelineBase extends DayTimeViewBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
    }
    /**
     * @hidden
     */
    get viewColumnWidth() {
        return this.optionValue(COLUMN_WIDTH);
    }
}
TimelineBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineBase, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Directive });
TimelineBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: TimelineBase, inputs: { columnWidth: "columnWidth" }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { columnWidth: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const createTasks$1 = (periodStart, periodEnd, items) => {
    const tasks = [];
    const utcStart = toUTCDate(periodStart);
    const utcEnd = toUTCDate(periodEnd);
    for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const event = item.event;
        const task = {
            index,
            start: item.start,
            end: item.end,
            event: event,
            isAllDay: false
        };
        const endTime = event.isAllDay ? roundAllDayEnd(item) : task.end;
        const startTime = event.isAllDay ? task.start.stripTime() : task.start;
        task.startTime = startTime.toUTCDate();
        task.endTime = endTime.toUTCDate();
        if (intersects(task.startTime, task.endTime, utcStart, utcEnd)) {
            tasks.push(task);
            task.head = task.endTime > periodEnd;
            task.tail = task.startTime < periodStart;
        }
    }
    return tasks;
};
/**
 * @hidden
 */
class SortPipe {
    transform(value, ..._args) {
        return value.sort((item1, item2) => (item1.startTime.getTime() - item2.startTime.getTime()));
    }
}
SortPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SortPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
SortPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: SortPipe, isStandalone: true, name: "sort" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SortPipe, decorators: [{
            type: Pipe,
            args: [{
                    // eslint-disable-next-line @angular-eslint/pipe-prefix
                    name: 'sort',
                    standalone: true
                }]
        }] });

/**
 * @hidden
 */
class TimelineMultiDayViewComponent extends DayTimeViewComponent {
    constructor(localization, changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, scrollBarWidthService) {
        super(changeDetector, viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, scrollBarWidthService);
        this.name = 'timeline';
        this.columnWidth = 100;
        this.viewName = 'timeline';
        this.verticalTime = false;
    }
    get classNames() {
        return `k-scheduler-${this.viewName}-view`;
    }
    get contentWidthPercentage() {
        const expectedWidth = this.columnWidth * this.slotsCount;
        const percentage = (expectedWidth / this.contentWidth) * 100;
        return Math.max(percentage, 100);
    }
    ngOnChanges(changes) {
        if (changes.columnWidth) {
            this.changes.next(null);
        }
        super.ngOnChanges(changes);
    }
    reflow() {
        if (!isDocumentAvailable()) {
            return;
        }
        const slotService = this.slotService;
        this.updateContentHeight();
        slotService.containerSize = this.content.nativeElement.scrollWidth;
        this.contentWidth = this.content.nativeElement.getBoundingClientRect().width;
        this.cdr.detectChanges();
        const verticalResourceRows = this.verticalResources.length ? this.verticalResourceRows.toArray() : [];
        slotService.layoutTimeline(this.eventHeight, verticalResourceRows);
        if (verticalResourceRows.length) {
            slotService.forEachGroup((group, index) => {
                verticalResourceRows[index].nativeElement.style.height = `${group.timeRanges[0].slots[0].height}px`;
            });
        }
        this.syncTables();
    }
    get allEventsMessage() {
        return this.localization.get('allEvents');
    }
    get slotsCount() {
        const resources = this.horizontalResources;
        let result = this.daySlots.length * this.timeSlots.length;
        for (let idx = 0; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    timeColspan(index) {
        if (this.minorTimeHeaderTemplateRef) {
            return 1;
        }
        const timeSlots = this.timeSlots.length;
        const remainder = timeSlots % this.slotDivisions;
        return remainder === 0 || (index < timeSlots - remainder) ? this.slotDivisions : 1;
    }
    horizontalColspan(resourceIndex) {
        const resources = this.horizontalResources;
        let result = this.daySlots.length * this.timeSlots.length;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    verticalRowspan(resourceIndex) {
        const resources = this.verticalResources;
        let result = 1;
        for (let idx = resourceIndex + 1; idx < resources.length; idx++) {
            result *= (resources[idx].data || []).length || 1;
        }
        return result;
    }
    handleScroll() {
        this.headerWrap.nativeElement.scrollLeft = this.content.nativeElement.scrollLeft;
    }
    createTasks(items, dateRange) {
        return createTasks$1(dateRange.start, dateRange.end, items);
    }
    onTasksChange() {
        this.items.next(this.tasks);
    }
    dragRanges(slot) {
        return this.slotService.dragRanges(slot, this.dragging.offset, true);
    }
    dragHintSize(firstSlot, lastSlot) {
        return {
            width: toPx(lastSlot.rect.left - firstSlot.rect.left + lastSlot.rect.width),
            height: toPx(firstSlot.height)
        };
    }
    updateResizeHints(ranges, start, end) {
        const last = ranges[ranges.length - 1];
        super.updateResizeHints([[ranges[0][0], last[last.length - 1]]], start, end);
    }
    pdfWidth() {
        const contentWidth = this.content.nativeElement.scrollWidth;
        const timesWidth = this.times.nativeElement.offsetWidth;
        return contentWidth + timesWidth;
    }
    currentTimeArrowOffset() {
        return this.headerWrap.nativeElement.querySelector('tr:last-child').offsetTop;
    }
}
TimelineMultiDayViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineMultiDayViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }, { token: DayTimeSlotService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: PDFService }, { token: i7.ScrollbarWidthService }], target: i0.ɵɵFactoryTarget.Component });
TimelineMultiDayViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: TimelineMultiDayViewComponent, isStandalone: true, selector: "timeline-multi-day-view", inputs: { name: "name", columnWidth: "columnWidth", viewName: "viewName" }, providers: [
        DayTimeSlotService
    ], viewQueries: [{ propertyName: "headerTable", first: true, predicate: ["headerTable"], descendants: true }, { propertyName: "verticalResourceRows", predicate: ["verticalResourceRows"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: `
        <table class="k-scheduler-layout" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr><th class="k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr><th class="k-slot-cell k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                    <div class="k-scheduler-header" #header >
                        <div class="k-scheduler-header-wrap" #headerWrap>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-down">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #headerTable aria-hidden="true" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                        <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                            class="k-slot-cell k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                        </th>
                                    </tr>
                                    <tr class="k-scheduler-date-group">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let index = index; trackBy: itemIndex;">
                                                <th [attr.colspan]="timeSlots.length" class="k-scheduler-cell k-heading-cell k-slot-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ daySlot.start | kendoDate: 'm'}}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: daySlot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                    <tr>
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <ng-container *ngFor="let timeSlot of timeSlots; let index = index; trackBy: itemIndex;">
                                                    <th *ngIf="timeSlot.isMajor" [attr.colspan]="timeColspan(index)" class="k-scheduler-cell k-heading-cell">
                                                        <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ timeSlot.start | kendoDate: 't' }}</ng-container>
                                                        <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }"></ng-container>
                                                    </th>
                                                    <th
                                                        *ngIf="!timeSlot.isMajor && minorTimeHeaderTemplateRef"
                                                        [ngStyle]="{'border-left-color': 'transparent', 'border-right-color': 'transparent'}"
                                                        class="k-scheduler-cell k-heading-cell"
                                                    >
                                                        <ng-container [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }">
                                                        </ng-container>
                                                    </th>
                                                </ng-container>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <tr *ngIf="!verticalResources.length">
                                        <th rowspan="1" #titleCell class="k-scheduler-cell k-heading-cell">
                                            {{ allEventsMessage }}
                                        </th>
                                    </tr>
                                    <ng-container *ngIf="verticalResources.length">
                                        <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                            <tr #verticalResourceRows>
                                                <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                    <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-scheduler-cell k-heading-cell">
                                                        <div>
                                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                                [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                        </div>
                                                    </th>
                                                </ng-container>
                                            </tr>
                                        </ng-container>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content"
                            #content
                            role="group"
                            tabindex="0"
                            (scroll)="handleScroll()"
                            [attr.aria-owns]="matchOwned(items | async | sort)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    class="k-current-time" #currentTimeMarker>
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let slot of timeSlots; let index = index; trackBy: itemIndex;"
                                                        [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                        timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        selectableSlot
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex ) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async | sort; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        dayTimeViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>
                                    <div *ngIf="resizeHints && resizeHints.length"
                                        kendoResizeHint
                                        [hint]="resizeHints[0]"
                                        [ngClass]="resizeHints[0].class"
                                        [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: TimeSlotDirective, selector: "[timeSlot]", inputs: ["invariantStart", "invariantEnd", "workDayStart", "workDayEnd", "workWeekStart", "workWeekEnd", "date"], exportAs: ["timeSlot"] }, { kind: "component", type: DayTimeViewItemComponent, selector: "[dayTimeViewItem]", inputs: ["vertical", "isAllDay"] }, { kind: "directive", type: FocusableDirective, selector: "[kendoSchedulerFocusIndex]", inputs: ["kendoSchedulerFocusIndex", "containerType"] }, { kind: "component", type: HintContainerComponent, selector: "kendo-hint-container" }, { kind: "component", type: ResizeHintComponent, selector: "[kendoResizeHint]", inputs: ["hint", "format"] }, { kind: "pipe", type: ResourceIteratorPipe, name: "resourceIterator" }, { kind: "pipe", type: DatePipe, name: "kendoDate" }, { kind: "pipe", type: AsyncPipe, name: "async" }, { kind: "pipe", type: SortPipe, name: "sort" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineMultiDayViewComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'timeline-multi-day-view',
                    providers: [
                        DayTimeSlotService
                    ],
                    template: `
        <table class="k-scheduler-layout" [ngClass]="classNames">
            <tbody>
                <tr class="k-scheduler-head">
                    <td>
                        <div class="k-scheduler-times" #timesHeader>
                            <table class="k-scheduler-table" aria-hidden="true">
                                <tbody>
                                    <tr><th class="k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr><th class="k-slot-cell k-scheduler-cell k-heading-cell"></th></tr>
                                    <tr *ngFor="let resource of horizontalResources; trackBy: itemIndex;">
                                        <th class="k-scheduler-cell k-heading-cell"></th>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                    <div class="k-scheduler-header" #header >
                        <div class="k-scheduler-header-wrap" #headerWrap>
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    #currentTimeArrow class="k-current-time k-current-time-arrow-down">
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #headerTable aria-hidden="true" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resource of horizontalResources; let resourceIndex = index; trackBy: itemIndex;">
                                        <th *ngFor="let item of horizontalResources | resourceIterator : resourceIndex; trackBy: itemIndex;"
                                            class="k-slot-cell k-scheduler-cell k-heading-cell" [attr.colspan]="horizontalColspan(resourceIndex)">
                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(item, resource.textField) }}</ng-container>
                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                [ngTemplateOutletContext]="{ resource: item }"></ng-container>
                                        </th>
                                    </tr>
                                    <tr class="k-scheduler-date-group">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let index = index; trackBy: itemIndex;">
                                                <th [attr.colspan]="timeSlots.length" class="k-scheduler-cell k-heading-cell k-slot-cell">
                                                    <span *ngIf="!dateHeaderTemplateRef" class="k-link k-nav-day" [attr.data-dayslot-index]="index">{{ daySlot.start | kendoDate: 'm'}}</span>
                                                    <ng-container *ngIf="dateHeaderTemplateRef" [ngTemplateOutlet]="dateHeaderTemplateRef" [ngTemplateOutletContext]="{ date: daySlot.start }"></ng-container>
                                                </th>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                    <tr>
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let resourceIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <ng-container *ngFor="let timeSlot of timeSlots; let index = index; trackBy: itemIndex;">
                                                    <th *ngIf="timeSlot.isMajor" [attr.colspan]="timeColspan(index)" class="k-scheduler-cell k-heading-cell">
                                                        <ng-container *ngIf="!majorTimeHeaderTemplateRef">{{ timeSlot.start | kendoDate: 't' }}</ng-container>
                                                        <ng-container *ngIf="majorTimeHeaderTemplateRef" [ngTemplateOutlet]="majorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }"></ng-container>
                                                    </th>
                                                    <th
                                                        *ngIf="!timeSlot.isMajor && minorTimeHeaderTemplateRef"
                                                        [ngStyle]="{'border-left-color': 'transparent', 'border-right-color': 'transparent'}"
                                                        class="k-scheduler-cell k-heading-cell"
                                                    >
                                                        <ng-container [ngTemplateOutlet]="minorTimeHeaderTemplateRef" [ngTemplateOutletContext]="{ date: timeSlot.start }">
                                                        </ng-container>
                                                    </th>
                                                </ng-container>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    </td>
                </tr>
                <tr class="k-scheduler-body">
                    <td>
                        <div class="k-scheduler-times" #times>
                            <table class="k-scheduler-table" #timesTable aria-hidden="true">
                                <tbody>
                                    <tr *ngIf="!verticalResources.length">
                                        <th rowspan="1" #titleCell class="k-scheduler-cell k-heading-cell">
                                            {{ allEventsMessage }}
                                        </th>
                                    </tr>
                                    <ng-container *ngIf="verticalResources.length">
                                        <ng-container *ngFor="let resourceItem of verticalResources | resourceIterator; let leafIndex = index; trackBy: itemIndex;">
                                            <tr #verticalResourceRows>
                                                <ng-container *ngFor="let resource of verticalResources; let resourceIndex = index; trackBy: itemIndex;">
                                                    <th *ngIf="verticalItem(leafIndex, resourceIndex)" [attr.rowspan]="verticalRowspan(resourceIndex)" class="k-slot-cell k-scheduler-cell k-heading-cell">
                                                        <div>
                                                            <ng-container *ngIf="!groupHeaderTemplateRef">{{ getField(verticalItem(leafIndex, resourceIndex), resource.textField) }}</ng-container>
                                                            <ng-container *ngIf="groupHeaderTemplateRef" [ngTemplateOutlet]="groupHeaderTemplateRef"
                                                                [ngTemplateOutletContext]="{ resource: verticalItem(leafIndex, resourceIndex) }"></ng-container>
                                                        </div>
                                                    </th>
                                                </ng-container>
                                            </tr>
                                        </ng-container>
                                    </ng-container>
                                </tbody>
                            </table>
                        </div>
                    </td>
                    <td>
                        <div
                            class="k-scheduler-content"
                            #content
                            role="group"
                            tabindex="0"
                            (scroll)="handleScroll()"
                            [attr.aria-owns]="matchOwned(items | async | sort)">
                            <ng-container *ngIf="showCurrentTime">
                                <div *ngFor="let resource of horizontalResources | resourceIterator; trackBy: itemIndex;"
                                    class="k-current-time" #currentTimeMarker>
                                </div>
                            </ng-container>
                            <table class="k-scheduler-table" #contentTable role="presentation" [style.width.%]="contentWidthPercentage">
                                <tbody>
                                    <tr *ngFor="let resourceItem of verticalResources | resourceIterator; let verticalIndex = index; trackBy: itemIndex;">
                                        <ng-container *ngFor="let resource of horizontalResources | resourceIterator; let horizontalIndex = index; trackBy: itemIndex;">
                                            <ng-container *ngFor="let daySlot of daySlots; let rangeIndex = index; trackBy: itemIndex;">
                                                <td *ngFor="let slot of timeSlots; let index = index; trackBy: itemIndex;"
                                                        [ngClass]="timeSlotClass(slot, daySlot.start, verticalResources.length ? verticalIndex : horizontalIndex)"
                                                        timeSlot #timeSlot="timeSlot"
                                                        [date]="daySlot.start"
                                                        [invariantStart]="slot.start"
                                                        [invariantEnd]="slot.end"
                                                        [workDayStart]="workDayStartTime"
                                                        [workDayEnd]="workDayEndTime"
                                                        [workWeekStart]="workWeekStart"
                                                        [workWeekEnd]="workWeekEnd"
                                                        selectableSlot
                                                        [id]="{ resourceIndex: verticalResources.length ? verticalIndex : horizontalIndex, rangeIndex: rangeIndex, index: index }"
                                                        [class.k-selected]="isSlotSelected({
                                                            start: toPlainDateTime(daySlot.start, slot.start),
                                                            end: toPlainDateTime(daySlot.start, slot.end),
                                                            isAllDay: false,
                                                            resources: resourcesByIndex(verticalResources.length ? verticalIndex : horizontalIndex)
                                                        })"
                                                        class="k-scheduler-cell"
                                                >
                                                    <ng-container *ngIf="timeSlotTemplateRef" [ngTemplateOutlet]="timeSlotTemplateRef"
                                                        [ngTemplateOutletContext]="{ date: timeSlot.startLocalTime, resources: resourcesByIndex(timeSlot.id.resourceIndex ) }">
                                                    </ng-container>
                                                </td>
                                            </ng-container>
                                        </ng-container>
                                    </tr>
                                </tbody>
                            </table>
                            <ng-container *ngFor="let item of items | async | sort; trackBy: itemIndex;">
                                <div *ngFor="let itemResource of item.resources; trackBy: itemIndex;"
                                    [ngClass]="getEventClasses(item, itemResource.resources)"
                                    [ngStyle]="getEventStyles(item, itemResource)"
                                    role="button"
                                    [kendoSchedulerFocusIndex]="itemResource.leafIdx"
                                    [id]="item.elementId + '_' + itemResource.leafIdx"
                                    dayTimeViewItem
                                        [editable]="editable"
                                        [item]="item"
                                        [index]="item.index"
                                        [rangeIndex]="item.rangeIndex"
                                        [eventTemplate]="eventTemplateRef"
                                        [resources]="itemResource.resources"
                                        [resourceIndex]="itemResource.leafIdx">
                                </div>
                            </ng-container>
                            <kendo-hint-container #hintContainer>
                                <ng-template>
                                    <div *ngFor="let hint of dragHints; trackBy: itemIndex;"
                                        class="k-event-drag-hint"
                                        dayTimeViewItem
                                            [ngStyle]="hint.style"
                                            [ngClass]="hint.class"
                                            [dragHint]="true"
                                            [eventTemplate]="eventTemplateRef"
                                            [item]="hint.item"
                                            [resources]="hint.resources">
                                    </div>
                                    <div *ngIf="resizeHints && resizeHints.length"
                                        kendoResizeHint
                                        [hint]="resizeHints[0]"
                                        [ngClass]="resizeHints[0].class"
                                        [format]="resizeHintFormat">
                                    </div>
                                </ng-template>
                            </kendo-hint-container>
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    `,
                    standalone: true,
                    imports: [NgClass, NgFor, NgIf, NgTemplateOutlet, NgStyle, TimeSlotDirective, DayTimeViewItemComponent, FocusableDirective, HintContainerComponent, ResizeHintComponent, ResourceIteratorPipe, DatePipe, AsyncPipe, SortPipe]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }, { type: DayTimeSlotService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: PDFService }, { type: i7.ScrollbarWidthService }]; }, propDecorators: { name: [{
                type: Input
            }], columnWidth: [{
                type: Input
            }], viewName: [{
                type: Input
            }], verticalResourceRows: [{
                type: ViewChildren,
                args: ['verticalResourceRows']
            }], headerTable: [{
                type: ViewChild,
                args: ['headerTable']
            }] } });

/**
 * The component for rendering the **Month** timeline view.
 */
class TimelineMonthViewComponent extends TimelineBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        this._numberOfMonths = 1;
        /**
         * The invariant name for this view.
         * @default 'timelineMonth'
         */
        this.name = 'timelineMonth';
        /**
         * @hidden
         */
        this.getStartDate = (selectedDate) => {
            return firstDayOfMonth(getDate(selectedDate));
        };
        /**
         * @hidden
         */
        this.getEndDate = (selectedDate) => {
            return addMonths(this.getStartDate(selectedDate), this.numberOfMonths);
        };
        /**
         * @hidden
         */
        this.getNextDate = (date, count) => {
            return addMonths(date, count);
        };
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('timelineMonthViewTitle');
    }
    /**
     * The long-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * > Note: If [numberOfMonths](#toc-numberofmonths) > 1, the default format value shows a range - `'{0:Y} - {1:Y}'`, where `0` is the start and `1` is the end date.
     * @default '{0:Y}'
     */
    set selectedDateFormat(format) {
        this._selectedDateFormat = format;
    }
    get selectedDateFormat() {
        if (this._selectedDateFormat) {
            return this._selectedDateFormat;
        }
        return this.numberOfMonths && this.numberOfMonths > 1 ? '{0:Y} - {1:Y}' : '{0:Y}';
    }
    /**
     * The short-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * > Note: If [numberOfMonths](#toc-numberofmonths) > 1, the default format value shows a range - `'{0:y} - {1:y}'`, where `0` is the start and `1` is the end date.
     * @default '{0:y}'
     */
    set selectedShortDateFormat(format) {
        this._selectedShortDateFormat = format;
    }
    get selectedShortDateFormat() {
        if (this._selectedShortDateFormat) {
            return this._selectedShortDateFormat;
        }
        return this.numberOfMonths && this.numberOfMonths > 1 ? '{0:y} - {1:y}' : '{0:y}';
    }
    /**
     * Specifies the number of months that the view will render.
     * > Normalized to `1` if the provided value is <= 0.
     * @default 1
     */
    set numberOfMonths(months) {
        this._numberOfMonths = months > 0 ? months : 1;
    }
    get numberOfMonths() {
        return this._numberOfMonths;
    }
}
TimelineMonthViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineMonthViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
TimelineMonthViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: TimelineMonthViewComponent, isStandalone: true, selector: "kendo-scheduler-timeline-month-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfMonths: "numberOfMonths" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => TimelineMonthViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-month"
                [name]="name"
                [getNextDate]="getNextDate"
                [getStartDate]="getStartDate"
                [getEndDate]="getEndDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: TimelineMultiDayViewComponent, selector: "timeline-multi-day-view", inputs: ["name", "columnWidth", "viewName"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineMonthViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-timeline-month-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => TimelineMonthViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-month"
                [name]="name"
                [getNextDate]="getNextDate"
                [getStartDate]="getStartDate"
                [getEndDate]="getEndDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfMonths: [{
                type: Input
            }] } });

/**
 * The component for rendering the **Timeline** view.
 */
class TimelineViewComponent extends TimelineBase {
    constructor(localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        this._numberOfDays = 1;
        /**
         * The invariant name for this view.
         * @default 'timeline'
         */
        this.name = 'timeline';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('timelineViewTitle');
    }
    /**
     * The long-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * > Note: If [numberOfDays](#toc-numberofdays) > 1, the default format value shows a range - `'{0:D} - {1:D}'`, where `0` is the start and `1` is the end date.
     * @default '{0:D}'
     */
    set selectedDateFormat(format) {
        this._selectedDateFormat = format;
    }
    get selectedDateFormat() {
        if (this._selectedDateFormat) {
            return this._selectedDateFormat;
        }
        return this.numberOfDays && this.numberOfDays > 1 ? '{0:D} - {1:D}' : '{0:D}';
    }
    /**
     * The short-date format for displaying the
     * selected date in the Scheduler toolbar.
     * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
     * > Note: If [numberOfDays](#toc-numberofdays) > 1, the default format value shows a range - `'{0:d} - {1:d}'`, where `0` is the start and `1` is the end date.
     * @default '{0:d}'
     */
    set selectedShortDateFormat(format) {
        this._selectedShortDateFormat = format;
    }
    get selectedShortDateFormat() {
        if (this._selectedShortDateFormat) {
            return this._selectedShortDateFormat;
        }
        return this.numberOfDays && this.numberOfDays > 1 ? '{0:d} - {1:d}' : '{0:d}';
    }
    /**
     * Specifies the number of days that the view will render.
     * > Normalized to `1` if the provided value is <= 0.
     * @default 1
     */
    set numberOfDays(days) {
        this._numberOfDays = days > 0 ? days : 1;
    }
    get numberOfDays() {
        return this._numberOfDays;
    }
}
TimelineViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
TimelineViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: TimelineViewComponent, isStandalone: true, selector: "kendo-scheduler-timeline-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfDays: "numberOfDays" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => TimelineViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <timeline-multi-day-view
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: TimelineMultiDayViewComponent, selector: "timeline-multi-day-view", inputs: ["name", "columnWidth", "viewName"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-timeline-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => TimelineViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <timeline-multi-day-view
                [name]="name"
                [numberOfDays]="numberOfDays"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfDays: [{
                type: Input
            }] } });

/**
 * The component for rendering the **Week** timeline view.
 */
class TimelineWeekViewComponent extends TimelineBase {
    constructor(_intl, localization, changeDetector, viewContext, viewState) {
        super(localization, changeDetector, viewContext, viewState);
        /**
         * The long-date format that will be used for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:D} - {1:D}`
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         * @default '{0:D} - {1:D}'
         */
        this.selectedDateFormat = '{0:D} - {1:D}';
        /**
         * The short date format that will be used for displaying the
         * selected date in the Scheduler toolbar.
         * Defaults to `{0:d} - {1:d}`
         * where `0` is the start and `1` is the end date
         * ([more information]({% slug parsingandformatting_intl %}#toc-date-formatting)).
         * @default '{0:d} - {1:d}'
         */
        this.selectedShortDateFormat = '{0:d} - {1:d}';
        this._numberOfWeeks = 1;
        /**
         * The invariant name for this view.
         * @default 'timelineWeek'
         */
        this.name = 'timelineWeek';
        /**
         * @hidden
         */
        this.getStartDate = (selectedDate) => {
            return firstDayInWeek(getDate(selectedDate), this.viewWeekStart);
        };
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('timelineWeekViewTitle');
    }
    /**
    * Specifies the number of weeks that the view will render.
    * @default 1
    */
    set numberOfWeeks(weeks) {
        this._numberOfWeeks = weeks > 0 ? weeks : 1;
    }
    get numberOfWeeks() {
        return this._numberOfWeeks;
    }
}
TimelineWeekViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineWeekViewComponent, deps: [{ token: i1$2.IntlService }, { token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }], target: i0.ɵɵFactoryTarget.Component });
TimelineWeekViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: TimelineWeekViewComponent, isStandalone: true, selector: "kendo-scheduler-timeline-week-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat", numberOfWeeks: "numberOfWeeks" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => TimelineWeekViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-week"
                [name]="name"
                [numberOfDays]="7 * numberOfWeeks"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: TimelineMultiDayViewComponent, selector: "timeline-multi-day-view", inputs: ["name", "columnWidth", "viewName"] }, { kind: "component", type: ViewFooterComponent, selector: "[viewFooter]", inputs: ["items"], outputs: ["itemClick"] }, { kind: "directive", type: WorkHoursFooterDirective, selector: "[kendoWorkHoursFooter]", inputs: ["showWorkHours"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineWeekViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-timeline-week-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => TimelineWeekViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <timeline-multi-day-view
                viewName="timeline-week"
                [name]="name"
                [numberOfDays]="7 * numberOfWeeks"
                [getStartDate]="getStartDate"
                [eventHeight]="viewEventHeight"
                [columnWidth]="viewColumnWidth"
                [currentTimeMarker]="viewCurrentTimeMarker"
                [highlightOngoingEvents]="viewHighlightOngoingEvents"
                [showWorkHours]="shouldShowWorkHours"
                [scrollTime]="viewScrollTime"
                [startTime]="viewStartTime"
                [endTime]="viewEndTime"
                [workDayStart]="viewWorkDayStart"
                [workDayEnd]="viewWorkDayEnd"
                [workWeekStart]="viewWorkWeekStart"
                [workWeekEnd]="viewWorkWeekEnd"
                [weekStart]="viewWeekStart"
                [slotDuration]="viewSlotDuration"
                [slotDivisions]="viewSlotDivisions"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [eventTemplate]="eventTemplate?.templateRef"
                [groupHeaderTemplate]="groupHeaderTemplate?.templateRef"
                [timeSlotTemplate]="timeSlotTemplate?.templateRef"
                [dateHeaderTemplate]="dateHeaderTemplate?.templateRef"
                [majorTimeHeaderTemplate]="majorTimeHeaderTemplate?.templateRef"
                [minorTimeHeaderTemplate]="minorTimeHeaderTemplate?.templateRef"
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat">
            </timeline-multi-day-view>
            <div *ngIf="viewShowFooter" viewFooter kendoWorkHoursFooter [showWorkHours]="shouldShowWorkHours" (itemClick)="showWorkHours = !shouldShowWorkHours"></div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [TimelineMultiDayViewComponent, ViewFooterComponent, WorkHoursFooterDirective, NgIf]
                }]
        }], ctorParameters: function () { return [{ type: i1$2.IntlService }, { type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }], numberOfWeeks: [{
                type: Input
            }] } });

/**
 * @hidden
 */
const createTasks = (periodStart, periodEnd, items, ranges) => {
    const tasks = [];
    const utcStart = toUTCDateTime(periodStart);
    const utcEnd = toUTCDateTime(periodEnd);
    for (let index = 0; index < items.length; index++) {
        const item = items[index];
        const data = {};
        const startTime = item.start.toUTCDate();
        const end = item.end;
        const endTime = (item.end.getTime() !== end.getTime() ? end.addDays(1) : end).toUTCDate();
        if (intersects(startTime, endTime, utcStart, utcEnd)) {
            for (let rangeIdx = 0; rangeIdx < ranges.length; rangeIdx++) {
                const range = ranges[rangeIdx];
                const rangeStart = toUTCDate(range);
                const rangeEnd = toUTCDate(addDays(range, 1));
                if (intersects(startTime, endTime, rangeStart, rangeEnd)) {
                    const task = {
                        index,
                        startTime: startTime > rangeStart ? startTime : rangeStart,
                        endTime: endTime < rangeEnd ? endTime : rangeEnd,
                        start: item.start,
                        end: item.end,
                        event: item.event,
                        isAllDay: item.event.isAllDay,
                        rangeIndex: rangeIdx,
                        data: data
                    };
                    task.head = endTime > rangeEnd && startTime > rangeStart;
                    task.tail = startTime < rangeStart && endTime < rangeEnd;
                    task.mid = endTime > rangeEnd && startTime < rangeStart;
                    task.isMultiDay = task.head || task.mid || task.tail;
                    tasks.push(task);
                }
            }
        }
    }
    return sortTasksByTime(tasks);
};
/**
 * @hidden
 */
const noop = (_) => { };
/**
 * @hidden
 */
const yearEnd = (year) => new Date(year, 11, 31, 23, 59, 59, 999);
/**
 * @hidden
 */
const yearStart = (year) => new Date(year, 0, 1, 0, 0, 0, 0);

const today = new Date(Date.now());
const getDateAttribute = (element) => element?.querySelector('span>span[date]')?.getAttribute('date');
/**
 * @hidden
 */
class YearViewInternalComponent extends BaseView {
    constructor(localization, focusService, intl, viewContext, viewState, zone, renderer, pdfService, element, slotService, scrollBarWidthService, changeDetector, localeId) {
        super(viewContext, viewState, intl, slotService, zone, renderer, element, pdfService, localization, changeDetector, scrollBarWidthService);
        this.localization = localization;
        this.focusService = focusService;
        this.intl = intl;
        this.localeId = localeId;
        this.caretAltLeftIcon = caretAltLeftIcon;
        this.caretAltRightIcon = caretAltRightIcon;
        this.eventsPerSelectedDay = [];
        this.days = [];
        this.tds = [];
        this.isTooltipClicked = false;
        this.slotByIndex = (slotIndex, args) => noop(slotIndex);
        this.dragHintSize = (startSlot, endSlot) => noop(startSlot);
        this.dragRanges = (slot) => noop(slot);
        this.slotByPosition = (x, y, container) => noop(x);
        this.cachedTds = [];
    }
    get arrowIcons() {
        return !this.localization.rtl
            ? ['caret-alt-left', 'caret-alt-right']
            : ['caret-alt-right', 'caret-alt-left'];
    }
    get arrowSVGIcons() {
        return !this.localization.rtl
            ? [this.caretAltLeftIcon, this.caretAltRightIcon]
            : [this.caretAltRightIcon, this.caretAltLeftIcon];
    }
    ngAfterViewInit() {
        this.updateTds();
        super.ngAfterViewInit();
        this.focusedDate = new Date(this.selectedDate.getFullYear(), today.getMonth(), today.getDate());
    }
    getSlotClass(date) {
        if (this.slotClass) {
            return this.slotClass({
                start: date,
                end: addDays(date, 1),
                events: this.eventsPerDay(date),
            });
        }
    }
    getEventClasses(item, resources, isAllDay) {
        if (this.eventClass) {
            return this.eventClass({
                event: item.event,
                resources,
                isAllDay,
            });
        }
    }
    onBlur() {
        if (!this.isTooltipClicked) {
            this.tooltip.hide();
        }
        this.isTooltipClicked = false;
    }
    getDate(element) {
        return new Date(getDateAttribute(element.nativeElement));
    }
    eventTitle(event) {
        const startTime = toLocalDate(event.startTime);
        const endTime = toLocalDate(event.endTime);
        const time = formatEventTime(startTime, endTime, event.isAllDay, this.localeId);
        return `${time}, ${event.event.title}`;
    }
    onClick(event) {
        if (event.target.tagName === 'SPAN') {
            const clickedDate = getDateAttribute(event.target.closest('td.k-calendar-td'));
            if (clickedDate === getDateAttribute(this.currentTd)) {
                this.tooltip.show(this.currentTd);
            }
        }
        else {
            this.tooltip.hide();
        }
    }
    onMouseDown() {
        this.isTooltipClicked = true;
    }
    onKeydown(event) {
        if (event.key === 'Backspace' || event.key === 'Delete') {
            this.tooltip.hide();
        }
        if (event.key === 'Enter' && !this.tooltip.popupRef) {
            this.tooltip.show(this.currentTd);
            return;
        }
        if (event.key === 'Enter' && this.tooltip.popupRef && (getDateAttribute(this.currentTd) === this.calendar.focusedDate.toString())) {
            this.navigateToDay(new Date(getDateAttribute(this.currentTd)));
        }
    }
    navigateToDay(date) {
        this.tooltip.hide();
        this.zone.run(() => {
            this.viewState.navigateTo({ viewName: 'day', date: new Date(date) });
        });
    }
    eventsPerDay(date) {
        return this.tasksPerDay(date)?.map((task) => task.event) || [];
    }
    tasksPerDay(date) {
        if (this.resources?.length > 0) {
            return this.tasks?.filter((event) => event.resources.length > 0 &&
                event.startTime.getUTCDate() === date.getDate() &&
                event.startTime.getUTCMonth() === date.getMonth());
        }
        else {
            return this.tasks?.filter((event) => event.startTime.getUTCDate() === date.getDate() && event.startTime.getUTCMonth() === date.getMonth());
        }
    }
    onValueChange(date) {
        this.eventsPerSelectedDay = this.tasksPerDay(date);
        this.currentTd = this.tds.find((td) => getDateAttribute(td) === date.toString());
        if (this.tooltip.popupRef) {
            this.tooltip.hide();
        }
    }
    hasEvent(date) {
        return this.tasksPerDay(date).length > 0;
    }
    createPDFElement() {
        const element = this.element.nativeElement.cloneNode(true);
        element.style.width = `${this.element.nativeElement.offsetWidth}px`;
        element.querySelector('.k-scheduler-layout').style.height = 'auto';
        this.pdfService.elementReady.emit({
            element: element,
        });
    }
    onSelectDate(date) {
        const year = date.getFullYear();
        const start = yearStart(year);
        this.focusedDate = new Date(year, start.getMonth(), today.getDate());
        this.selectedDate = start;
        const dateRange = this.dateRange(date);
        this.viewState.notifyDateRange(dateRange);
        this.days = this.createDaySlots(dateRange);
        if (this.calendar) {
            this.calendar.min = start;
            this.calendar.max = yearEnd(start.getFullYear());
            this.updateTds();
        }
    }
    onAction(e) {
        const now = this.selectedDate;
        if (e.type === 'next' || e.type === 'prev') {
            const offset = e.type === 'next' ? 1 : -1;
            const next = addYears(now, offset);
            this.viewState.notifyNextDate(next);
            this.calendar.min = next;
            this.calendar.max = yearEnd(next.getFullYear());
            this.focusedDate = new Date(next.getFullYear(), today.getMonth(), today.getDate());
        }
    }
    createTasks(items, dateRange) {
        this.days = this.createDaySlots(dateRange);
        return createTasks(dateRange.start, dateRange.end, items, this.days);
    }
    reflow() {
        this.updateContentHeight();
        const content = this.content.nativeElement;
        if (this.contentHeight === 'auto') {
            // bigger size changes cause the table to overflow the container and in horizontal scrollbars
            // this changes the table and slots size during rendering before the browser re-adjusts the 100% table width
            content.style.overflow = 'visible';
        }
        if (this.contentHeight === 'auto') {
            content.style.overflow = '';
        }
    }
    dateRange(date = this.selectedDate) {
        return this.dateRangeFn(date);
    }
    onTasksChange() {
        this.items.next(this.tasks);
    }
    createDaySlots({ start }) {
        const days = [];
        const monthsPerYear = 12;
        let date = start;
        for (let idx = 0; idx < monthsPerYear; idx++) {
            const monthTotalDays = this.getLastDayOfMonth(date.getFullYear(), date.getMonth());
            for (let dayIdx = 0; dayIdx < monthTotalDays; dayIdx++) {
                days.push(date);
                const nextDay = addDays(date, 1);
                date = nextDay;
            }
        }
        return days;
    }
    getLastDayOfMonth(year, month) {
        return new Date(year, month + 1, 0).getDate();
    }
    updateTds() {
        this.cachedTds.forEach((td) => {
            this.renderer.setAttribute(td, 'class', 'k-calendar-td');
        });
        this.cachedTds = [];
        this.tds = Array.from(this.calendar.element.nativeElement.querySelectorAll('.k-calendar-td:not(.k-empty)'));
        if (this.slotClass) {
            this.tds.forEach((td) => {
                const date = toUTCDate(new Date(getDateAttribute(td)));
                const userClass = this.getSlotClass(date);
                if (userClass) {
                    this.renderer.addClass(td, userClass);
                    this.cachedTds.push(td);
                }
            });
        }
    }
}
YearViewInternalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: YearViewInternalComponent, deps: [{ token: i1$1.LocalizationService }, { token: FocusService }, { token: i1$2.IntlService }, { token: ViewContextService }, { token: ViewStateService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: PDFService }, { token: i0.ElementRef }, { token: MonthSlotService }, { token: i7.ScrollbarWidthService }, { token: i0.ChangeDetectorRef }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
YearViewInternalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: YearViewInternalComponent, isStandalone: true, selector: "year-view-internal", inputs: { newRange: "newRange", dateRangeFn: "dateRangeFn", selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [MonthSlotService], viewQueries: [{ propertyName: "calendar", first: true, predicate: MultiViewCalendarComponent, descendants: true }, { propertyName: "tooltip", first: true, predicate: TooltipDirective, descendants: true }], usesInheritance: true, ngImport: i0, template: `
        <div #content class="k-scheduler-layout k-scheduler-layout-flex k-scheduler-yearview">
            <div class="k-scheduler-body">
                <kendo-multiviewcalendar
                    [showOtherMonthDays]="false"
                    [showCalendarHeader]="false"
                    [showViewHeader]="true"
                    [views]="12"
                    [focusedDate]="focusedDate"
                    kendoTooltip
                    filter=".k-calendar-td"
                    showOn="none"
                    [tooltipTemplate]="template"
                    position="right"
                    tooltipContentClass="k-scheduler-tooltip"
                    [tooltipWidth]="220"
                    [collision]="{ horizontal: 'flip', vertical: 'flip' }"
                    (valueChange)="onValueChange($event)"
                    (blur)="onBlur()"
                >
                    <ng-template kendoCalendarMonthCellTemplate let-date let-context="cellContext">
                        <span *ngIf="!context.isOtherMonth" [attr.date]="date">{{ date.getDate() }}</span>
                        <span *ngIf="!context.isOtherMonth && hasEvent(date)" class="k-day-indicator"></span>
                    </ng-template>
                </kendo-multiviewcalendar>
            </div>
        </div>
        <ng-template #template let-anchor>
            <div
                class="k-tooltip-title k-text-center"
                (click)="navigateToDay(getDate(anchor))"
                (mousedown)="onMouseDown()"
            >
                <div class="k-month">{{ intl.formatDate(getDate(anchor), 'MMM') }}</div>
                <div class="k-link k-day k-text-primary">{{ intl.formatDate(getDate(anchor), 'dd') }}</div>
            </div>
            <div class="k-tooltip-events-container" (mousedown)="onMouseDown()">
                <div class="k-tooltip-events">
                    <div
                        *ngFor="let event of eventsPerSelectedDay"
                        class="k-tooltip-event k-event"
                        [title]="eventTitle(event)"
                        [ngClass]="getEventClasses(event, event.resources)"
                        [ngStyle]="getEventStyles(event, event.resources[0], event.isAllDay)"
                    >
                        <kendo-icon-wrapper
                            *ngIf="event.tail || event.mid"
                            [name]="arrowIcons[0]"
                            [svgIcon]="arrowSVGIcons[0]"
                        >
                        </kendo-icon-wrapper>
                        <div class="k-event-title k-text-ellipsis">{{ event.event.title }}</div>
                        <span class="k-spacer"></span>
                        <span
                            class="k-event-time"
                            *ngIf="(event.isMultiDay && event.head && !event.isAllDay) || !event.isMultiDay"
                            >{{ intl.formatDate(event.start, 't') }}</span
                        >
                        <kendo-icon-wrapper
                            *ngIf="event.head || event.mid"
                            [name]="arrowIcons[1]"
                            [svgIcon]="arrowSVGIcons[1]"
                        >
                        </kendo-icon-wrapper>
                    </div>
                </div>
            </div>
            <div *ngIf="eventsPerSelectedDay.length === 0" class="k-no-data k-text-center">
                {{ localization.get('yearViewNoEvents') }}
            </div>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: MultiViewCalendarComponent, selector: "kendo-multiviewcalendar", inputs: ["showOtherMonthDays", "showCalendarHeader", "size", "id", "focusedDate", "footer", "min", "max", "rangeValidation", "disabledDatesRangeValidation", "selection", "allowReverse", "value", "disabled", "tabindex", "tabIndex", "weekDaysFormat", "isActive", "disabledDates", "activeView", "bottomView", "topView", "showViewHeader", "animateNavigation", "weekNumber", "activeRangeEnd", "selectionRange", "views", "orientation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "footerTemplate", "headerTitleTemplate", "headerTemplate"], outputs: ["activeViewChange", "navigate", "cellEnter", "cellLeave", "valueChange", "rangeSelectionChange", "blur", "focus", "focusCalendar", "onClosePopup", "onTabPress", "onShiftTabPress"], exportAs: ["kendo-multiviewcalendar"] }, { kind: "directive", type: TooltipDirective, selector: "[kendoTooltip]", inputs: ["filter", "position", "titleTemplate", "showOn", "showAfter", "callout", "closable", "offset", "tooltipWidth", "tooltipHeight", "tooltipClass", "tooltipContentClass", "collision", "closeTitle", "tooltipTemplate"], exportAs: ["kendoTooltip"] }, { kind: "directive", type: MonthCellTemplateDirective, selector: "[kendoCalendarMonthCellTemplate]" }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: YearViewInternalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'year-view-internal',
                    providers: [MonthSlotService],
                    template: `
        <div #content class="k-scheduler-layout k-scheduler-layout-flex k-scheduler-yearview">
            <div class="k-scheduler-body">
                <kendo-multiviewcalendar
                    [showOtherMonthDays]="false"
                    [showCalendarHeader]="false"
                    [showViewHeader]="true"
                    [views]="12"
                    [focusedDate]="focusedDate"
                    kendoTooltip
                    filter=".k-calendar-td"
                    showOn="none"
                    [tooltipTemplate]="template"
                    position="right"
                    tooltipContentClass="k-scheduler-tooltip"
                    [tooltipWidth]="220"
                    [collision]="{ horizontal: 'flip', vertical: 'flip' }"
                    (valueChange)="onValueChange($event)"
                    (blur)="onBlur()"
                >
                    <ng-template kendoCalendarMonthCellTemplate let-date let-context="cellContext">
                        <span *ngIf="!context.isOtherMonth" [attr.date]="date">{{ date.getDate() }}</span>
                        <span *ngIf="!context.isOtherMonth && hasEvent(date)" class="k-day-indicator"></span>
                    </ng-template>
                </kendo-multiviewcalendar>
            </div>
        </div>
        <ng-template #template let-anchor>
            <div
                class="k-tooltip-title k-text-center"
                (click)="navigateToDay(getDate(anchor))"
                (mousedown)="onMouseDown()"
            >
                <div class="k-month">{{ intl.formatDate(getDate(anchor), 'MMM') }}</div>
                <div class="k-link k-day k-text-primary">{{ intl.formatDate(getDate(anchor), 'dd') }}</div>
            </div>
            <div class="k-tooltip-events-container" (mousedown)="onMouseDown()">
                <div class="k-tooltip-events">
                    <div
                        *ngFor="let event of eventsPerSelectedDay"
                        class="k-tooltip-event k-event"
                        [title]="eventTitle(event)"
                        [ngClass]="getEventClasses(event, event.resources)"
                        [ngStyle]="getEventStyles(event, event.resources[0], event.isAllDay)"
                    >
                        <kendo-icon-wrapper
                            *ngIf="event.tail || event.mid"
                            [name]="arrowIcons[0]"
                            [svgIcon]="arrowSVGIcons[0]"
                        >
                        </kendo-icon-wrapper>
                        <div class="k-event-title k-text-ellipsis">{{ event.event.title }}</div>
                        <span class="k-spacer"></span>
                        <span
                            class="k-event-time"
                            *ngIf="(event.isMultiDay && event.head && !event.isAllDay) || !event.isMultiDay"
                            >{{ intl.formatDate(event.start, 't') }}</span
                        >
                        <kendo-icon-wrapper
                            *ngIf="event.head || event.mid"
                            [name]="arrowIcons[1]"
                            [svgIcon]="arrowSVGIcons[1]"
                        >
                        </kendo-icon-wrapper>
                    </div>
                </div>
            </div>
            <div *ngIf="eventsPerSelectedDay.length === 0" class="k-no-data k-text-center">
                {{ localization.get('yearViewNoEvents') }}
            </div>
        </ng-template>
    `,
                    standalone: true,
                    imports: [MultiViewCalendarComponent, TooltipDirective, MonthCellTemplateDirective, NgIf, NgFor, NgClass, NgStyle, IconWrapperComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: FocusService }, { type: i1$2.IntlService }, { type: ViewContextService }, { type: ViewStateService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: PDFService }, { type: i0.ElementRef }, { type: MonthSlotService }, { type: i7.ScrollbarWidthService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { newRange: [{
                type: Input
            }], dateRangeFn: [{
                type: Input
            }], calendar: [{
                type: ViewChild,
                args: [MultiViewCalendarComponent]
            }], tooltip: [{
                type: ViewChild,
                args: [TooltipDirective]
            }], selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }] } });

/**
 * The component for rendering the **Year** view.
 */
class YearViewComponent extends ConfigurationViewBase {
    constructor(localization, changeDetector, viewContext, viewState, intl) {
        super(localization, changeDetector, viewContext, viewState);
        this.intl = intl;
        /**
         * The long-date format for displaying the
         * selected year in the Scheduler toolbar.
         * For more information, see [Parsing and Formatting Dates and Numbers]({% slug parsingandformatting_intl %}#toc-date-formatting).
         * @default '{0:yyy}'
         */
        this.selectedDateFormat = '{0:yyy}';
        /**
         * The short-date format for displaying the
         * selected year in the Scheduler toolbar.
         * For more information, see [Parsing and Formatting Dates and Numbers]({% slug parsingandformatting_intl %}#toc-date-formatting).
         * @default '{0:yyy}'
         */
        this.selectedShortDateFormat = '{0:yyy}';
        /**
         * The invariant name for this view.
         * @default 'year'
         */
        this.name = 'year';
    }
    /**
     * @hidden
     */
    get title() {
        return this.localization.get('yearViewTitle');
    }
    /**
     * @hidden
     */
    dateRange(date) {
        const year = date.getFullYear();
        const start = yearStart(year);
        const end = yearEnd(year);
        const text = this.intl.format(this.selectedDateFormat, start);
        const shortText = this.intl.format(this.selectedShortDateFormat, start);
        return { start, end, text, shortText };
    }
    /**
     * @hidden
     */
    newRange(date, direction = 1) {
        return new Date(addYears(date, direction));
    }
}
YearViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: YearViewComponent, deps: [{ token: i1$1.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: ViewContextService }, { token: ViewStateService }, { token: i1$2.IntlService }], target: i0.ɵɵFactoryTarget.Component });
YearViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: YearViewComponent, isStandalone: true, selector: "kendo-scheduler-year-view", inputs: { selectedDateFormat: "selectedDateFormat", selectedShortDateFormat: "selectedShortDateFormat" }, providers: [{
            provide: SchedulerView,
            useExisting: forwardRef(() => YearViewComponent)
        }], usesInheritance: true, ngImport: i0, template: `
        <ng-template #content>
            <year-view-internal
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </year-view-internal>
        </ng-template>
    `, isInline: true, dependencies: [{ kind: "component", type: YearViewInternalComponent, selector: "year-view-internal", inputs: ["newRange", "dateRangeFn", "selectedDateFormat", "selectedShortDateFormat"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: YearViewComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'kendo-scheduler-year-view',
                    providers: [{
                            provide: SchedulerView,
                            useExisting: forwardRef(() => YearViewComponent)
                        }],
                    template: `
        <ng-template #content>
            <year-view-internal
                [selectedDateFormat]="selectedDateFormat"
                [selectedShortDateFormat]="selectedShortDateFormat"
                [slotClass]="viewSlotClass"
                [eventClass]="viewEventClass"
                [eventStyles]="viewEventStyles"
                [dateRangeFn]="dateRange"
                [newRange]="newRange">
            </year-view-internal>
        </ng-template>
    `,
                    standalone: true,
                    imports: [YearViewInternalComponent]
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: ViewContextService }, { type: ViewStateService }, { type: i1$2.IntlService }]; }, propDecorators: { selectedDateFormat: [{
                type: Input
            }], selectedShortDateFormat: [{
                type: Input
            }] } });

const isRecurrenceMaster = (ev) => !!(ev.id && ev.recurrenceRule);
/**
 * @hidden
 */
class LocalEditService {
    constructor(scheduler, localDataChangesService) {
        this.scheduler = scheduler;
        this.localDataChangesService = localDataChangesService;
    }
    get fields() {
        return this.scheduler.modelFields;
    }
    get hasLocalData() {
        return isPresent(this.localDataChangesService.data);
    }
    get data() {
        if (this.hasLocalData) {
            return this.localDataChangesService.data;
        }
        return this.scheduler.events;
    }
    create(item) {
        const idField = this.fields.id;
        const id = getField(item, idField);
        if (!isPresent(id)) {
            setField(item, idField, this.nextId());
        }
        this.data.push(item);
        this.dataChanged();
    }
    createException(item, value) {
        const exception = this.buildException(value);
        this.removeOccurrenceInternal(item);
        this.create(exception);
    }
    update(item, value) {
        assignValues(item, value);
        this.dataChanged();
    }
    remove(item) {
        const idField = this.fields.id;
        const itemId = getField(item, idField);
        const data = this.data;
        for (let idx = 0; idx < data.length; idx++) {
            if (itemId === getField(data[idx], idField)) {
                data.splice(idx, 1);
                break;
            }
        }
        this.dataChanged();
    }
    removeSeries(item) {
        const event = readEvent(item, this.fields);
        const isHead = isRecurrenceMaster(event);
        this.removeItemAndExceptions(isHead ? event.id : event.recurrenceId);
        this.dataChanged();
    }
    removeOccurrence(item) {
        this.removeOccurrenceInternal(item);
        this.dataChanged();
    }
    findRecurrenceMaster(item) {
        const fields = this.scheduler.modelFields;
        const event = readEvent(item, fields);
        const headId = isRecurrenceMaster(event) ? event.id : event.recurrenceId;
        return this.data.find((dataItem) => getField(dataItem, fields.id) === headId);
    }
    isRecurring(event) {
        return isRecurring(event, this.scheduler.modelFields);
    }
    isException(event) {
        return isException(event, this.scheduler.modelFields);
    }
    nextId() {
        return guid();
    }
    buildException(item) {
        const fields = this.fields;
        const head = this.findRecurrenceMaster(item);
        if (!head) {
            if (isDevMode()) {
                throw new Error('Unable to find recurrence head for event. Please check that recurrenceId is set and refers to an existing event.');
            }
            return;
        }
        const exception = clone(item);
        setField(exception, fields.id, this.nextId());
        setField(exception, fields.recurrenceId, getField(head, fields.id));
        setField(exception, fields.recurrenceRule, null);
        return exception;
    }
    removeItemAndExceptions(itemId) {
        const data = this.data;
        const fields = this.scheduler.modelFields;
        for (let idx = data.length - 1; idx >= 0; idx--) {
            if (itemId === getField(data[idx], fields.recurrenceId) || itemId === getField(data[idx], fields.id)) {
                data.splice(idx, 1);
            }
        }
    }
    removeOccurrenceInternal(item) {
        const fields = this.fields;
        const head = this.findRecurrenceMaster(item);
        const exceptionDate = getField(item, fields.start);
        const currentExceptions = getField(head, fields.recurrenceExceptions) || [];
        setField(head, fields.recurrenceExceptions, [...currentExceptions, exceptionDate]);
    }
    dataChanged() {
        if (this.hasLocalData) {
            this.localDataChangesService.changes.emit();
        }
    }
}

/**
 * @hidden
 */
const markAllAsTouched = (control) => {
    control.markAsTouched();
    if (control.hasOwnProperty('controls')) {
        const controls = control.controls;
        for (const inner in controls) {
            if (controls.hasOwnProperty(inner)) {
                markAllAsTouched(controls[inner]);
            }
        }
    }
};
/**
 * @hidden
 */
function diff(obj1, obj2, fields) {
    for (let idx = 0; idx < fields.length; idx++) {
        const field = fields[idx];
        if (!areEqual(getField(obj1, field), getField(obj2, field))) {
            return true;
        }
    }
    return false;
}
/**
 * @hidden
 */
function areEqual(value1, value2) {
    if (value1 && value1.getTime && value2 && value2.getTime) {
        return value1.getTime() === value2.getTime();
    }
    else if (Array.isArray(value1)) {
        if (!Array.isArray(value2) || value1.length !== value2.length) {
            return false;
        }
        for (let idx = 0; idx < value1.length; idx++) {
            if (value1[idx] !== value2[idx]) {
                return false;
            }
        }
        return true;
    }
    return value1 == value2;
}
const DATE_ACCESSORS = ['getFullYear', 'getMonth', 'getDate', 'getHours', 'getMinutes', 'getSeconds', 'getMilliseconds'];
/**
 * @hidden
 */
function seriesDate(head, occurrence, current, field) {
    const values = [];
    const headDate = getField(head, field);
    const occurrenceDate = getField(occurrence, field);
    const currentDate = getField(current, field);
    DATE_ACCESSORS.forEach(accessor => {
        values.push(occurrenceDate[accessor]() === currentDate[accessor]() ? headDate[accessor]() : currentDate[accessor]());
    });
    return new Date(...values);
}
/**
 * @hidden
 */
function updateRecurrenceRule(valueSrc, valueGoal) {
    const rrule = parseRule({ recurrenceRule: valueSrc.recurrenceRule });
    // parseRule sets weekStart to 0 if not present which then adds it to the serialized rule
    if (!valueSrc.recurrenceRule.includes("WKST")) {
        rrule.weekStart = undefined;
    }
    if (valueSrc.start?.getDate() !== valueGoal.start?.getDate()) {
        if (rrule.byYearDay?.length > 0) {
            // when the event is recurring on more than one day of the year
            const itemIndex = rrule.byYearDay.findIndex(yearDay => yearDay === valueSrc.start?.getDate());
            if (itemIndex !== -1) {
                rrule.byYearDay[itemIndex] = valueGoal.start?.getDate();
            }
        }
        if (rrule.byMonthDay?.length > 0) {
            // when the event is recurring on more than one day of the month
            const itemIndex = rrule.byMonthDay.findIndex(monthDay => monthDay === valueSrc.start?.getDate());
            if (itemIndex !== -1) {
                rrule.byMonthDay[itemIndex] = valueGoal.start?.getDate();
            }
        }
    }
    if (valueSrc.start?.getDay() !== valueGoal.start?.getDay() && rrule.byWeekDay?.length > 0) {
        // when the event is recurring on more than one day of the week
        const itemIndex = rrule.byWeekDay.findIndex(weekDayRule => weekDayRule.day === valueSrc.start?.getDay());
        if (itemIndex !== -1) {
            rrule.byWeekDay[itemIndex].day = valueGoal.start?.getDay();
        }
    }
    if (valueSrc.start?.getMonth() !== valueGoal.start?.getMonth() && rrule.byMonth?.length > 0) {
        // when the event is recurring on more than one month of the year
        const itemIndex = rrule.byMonth.findIndex(month => month === valueSrc.start?.getMonth());
        if (itemIndex !== -1) {
            rrule.byMonth[itemIndex] = valueGoal.start?.getMonth();
        }
    }
    return serializeRule(rrule);
}

/**
 * @hidden
 */
class EditingDirectiveBase {
    constructor(scheduler, localDataChangesService, dialogsService, focusService) {
        this.scheduler = scheduler;
        this.localDataChangesService = localDataChangesService;
        this.dialogsService = dialogsService;
        this.focusService = focusService;
        /**
         * Fires before the editing directive renders the **Add** dialog.
         */
        this.add = new EventEmitter();
        /**
         * Fires before the editing directive renders the **Edit** dialog.
         */
        this.edit = new EventEmitter();
        this.defaultTitle = 'No title';
        this.defaultEditService = this.createDefaultService();
        this.scheduler.editable = true;
    }
    /**
     * The edit service that will handle the editing operations.
     */
    set editService(value) {
        this.userEditService = value;
    }
    get editService() {
        return this.userEditService || this.defaultEditService;
    }
    /**
     * @hidden
     */
    ngOnInit() {
        this.subscriptions = merge(this.scheduler.slotDblClick, this.scheduler.create).subscribe(this.addHandler.bind(this));
        this.subscriptions.add(this.scheduler.removeConfirmed.subscribe(this.removeHandler.bind(this)));
        this.subscriptions.add(this.scheduler.cancel.subscribe(this.cancelHandler.bind(this)));
        this.subscriptions.add(this.scheduler.resizeEndConfirmed.subscribe(this.resizeEndHandler.bind(this)));
        this.subscriptions.add(this.scheduler.dragEndConfirmed.subscribe(this.dragEndHandler.bind(this)));
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
    createDefaultService() {
        return new LocalEditService(this.scheduler, this.localDataChangesService);
    }
    addHandler(args) {
        this.closeEditor();
        if (!this.isEnabled('add')) {
            return;
        }
        const fields = this.scheduler.modelFields;
        const dataItem = {};
        setField(dataItem, fields.start, args.start);
        setField(dataItem, fields.end, args.end);
        setField(dataItem, fields.isAllDay, args.isAllDay);
        setField(dataItem, fields.title, args.title);
        const resources = groupResources(this.scheduler.group, this.scheduler.resources);
        const slotResources = args.resources;
        for (let idx = 0; idx < resources.length; idx++) {
            const resource = resources[idx];
            const value = getField(slotResources[idx], resource.valueField);
            setField(dataItem, resource.field, resource.multiple ? [value] : value);
        }
        const addArgs = new AddEvent(this.scheduler, { dataItem });
        this.add.emit(addArgs);
        if (!addArgs.isDefaultPrevented()) {
            this.scheduler.addEvent(this.createModel({
                action: 'add',
                isNew: true,
                dataItem,
                sender: this.scheduler,
            }));
        }
    }
    removeHandler({ dataItem }) {
        if (!this.isEnabled('remove')) {
            return;
        }
        if (this.editService.isRecurring(dataItem)) {
            this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Remove)
                .subscribe((editMode) => {
                if (editMode !== undefined) {
                    this.handleRemove(dataItem, editMode);
                    this.focusService.focusContent();
                }
            });
        }
        else {
            this.dialogsService.openRemoveConfirmationDialog()
                .subscribe((shouldRemove) => {
                if (shouldRemove) {
                    this.handleRemove(dataItem, EditMode.Event);
                    this.focusService.focusContent();
                }
            });
        }
    }
    cancelHandler() {
        this.closeEditor();
    }
    closeEditor() {
        this.scheduler.closeEvent();
    }
    handleUpdate(item, value, mode) {
        const svc = this.editService;
        if (mode === EditMode.Occurrence) {
            // eslint-disable-next-line no-unused-expressions
            svc.isException(item) ?
                svc.update(item, value) :
                svc.createException(item, value);
        }
        else {
            // Item is not recurring or we're editing the entire series
            svc.update(item, value);
        }
    }
    handleRemove(item, mode) {
        const svc = this.editService;
        if (mode === EditMode.Series) {
            svc.removeSeries(item);
        }
        else if (mode === EditMode.Occurrence) {
            svc.isException(item) ?
                svc.remove(item) :
                svc.removeOccurrence(item);
        }
        else {
            // Item is not recurring
            svc.remove(item);
        }
    }
    resizeEndHandler({ event, start, end }) {
        if (areEqual(start, event.start) && areEqual(end, event.end)) {
            return;
        }
        const dataItem = event.dataItem;
        const fields = this.scheduler.modelFields;
        let value = {};
        setField(value, fields.start, start);
        setField(value, fields.end, end);
        if (this.editService.isRecurring(dataItem)) {
            this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit)
                .subscribe((result) => {
                let target = dataItem;
                if (result === EditMode.Series) {
                    target = this.editService.findRecurrenceMaster(dataItem);
                    setField(value, fields.start, seriesDate(target, dataItem, value, fields.start));
                    setField(value, fields.end, seriesDate(target, dataItem, value, fields.end));
                }
                else if (result !== undefined) {
                    value = assignValues(clone(dataItem), value);
                }
                this.handleUpdate(target, value, result);
            });
        }
        else {
            this.editService.update(dataItem, value);
        }
    }
    dragEndHandler({ event: { dataItem }, start, end, resources, isAllDay }) {
        const modelFields = this.scheduler.modelFields;
        const resourceFields = groupResources(this.scheduler.group, this.scheduler.resources).map(r => r.field);
        const fields = [modelFields.start, modelFields.end, modelFields.isAllDay].concat(resourceFields);
        let value = clone(resources);
        setField(value, modelFields.start, start);
        setField(value, modelFields.end, end);
        setField(value, modelFields.isAllDay, isAllDay);
        if (!diff(dataItem, value, fields)) {
            return;
        }
        if (this.editService.isRecurring(dataItem)) {
            this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit)
                .subscribe((result) => {
                let target = dataItem;
                if (result === EditMode.Series) {
                    target = this.editService.findRecurrenceMaster(dataItem);
                    if (dataItem.recurrenceRule) {
                        const newRecurrenceRule = updateRecurrenceRule(dataItem, value);
                        if (newRecurrenceRule !== dataItem?.recurrenceRule) {
                            setField(value, modelFields.recurrenceRule, newRecurrenceRule);
                        }
                    }
                    setField(value, modelFields.start, seriesDate(target, dataItem, value, modelFields.start));
                    setField(value, modelFields.end, seriesDate(target, dataItem, value, modelFields.end));
                }
                else if (result !== undefined) {
                    value = assignValues(clone(dataItem), value);
                }
                this.handleUpdate(target, value, result);
            });
        }
        else {
            this.editService.update(dataItem, value);
        }
    }
    isEnabled(action) {
        const editable = this.scheduler.editable;
        return editable && editable[action] !== false;
    }
}
EditingDirectiveBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditingDirectiveBase, deps: [{ token: SchedulerComponent }, { token: LocalDataChangesService }, { token: DialogsService }, { token: FocusService }], target: i0.ɵɵFactoryTarget.Directive });
EditingDirectiveBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: EditingDirectiveBase, inputs: { editService: "editService" }, outputs: { add: "add", edit: "edit" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: EditingDirectiveBase, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: SchedulerComponent }, { type: LocalDataChangesService }, { type: DialogsService }, { type: FocusService }]; }, propDecorators: { add: [{
                type: Output
            }], edit: [{
                type: Output
            }], editService: [{
                type: Input
            }] } });

/**
 * A directive which encapsulates the editing operations when the Scheduler
 * uses the [Reactive Angular Forms](link:site.data.urls.angular['reactiveforms']) ([see example](slug:editing_directives_scheduler)).
 */
class ReactiveEditingDirective extends EditingDirectiveBase {
    constructor(scheduler, localDataChangesService, dialogsService, focusService) {
        super(scheduler, localDataChangesService, dialogsService, focusService);
        this.scheduler = scheduler;
        this.localDataChangesService = localDataChangesService;
        this.dialogsService = dialogsService;
    }
    ngOnInit() {
        super.ngOnInit();
        this.subscriptions.add(this.scheduler.eventDblClick.subscribe(this.editHandler.bind(this)));
        this.subscriptions.add(this.scheduler.save.subscribe(this.saveHandler.bind(this)));
    }
    editHandler(args) {
        if (!this.isEnabled('edit')) {
            return;
        }
        const editArgs = new EditEvent(this.scheduler, { dataItem: args.event.dataItem, event: args.event });
        this.edit.emit(editArgs);
        if (editArgs.isDefaultPrevented()) {
            return;
        }
        let dataItem = args.event.dataItem;
        if (this.editService.isRecurring(dataItem)) {
            this.dialogsService.openRecurringConfirmationDialog(CrudOperation.Edit)
                .pipe(filter(mode => mode !== undefined))
                .subscribe((mode) => {
                if (mode === EditMode.Series) {
                    dataItem = this.editService.findRecurrenceMaster(dataItem);
                }
                const group = this.createModel({
                    action: 'edit',
                    isNew: false,
                    mode,
                    dataItem,
                    sender: this.scheduler,
                });
                this.scheduler.editEvent(dataItem, { group, mode });
            });
        }
        else {
            const group = this.createModel({
                action: 'edit',
                isNew: false,
                mode: EditMode.Event,
                dataItem,
                sender: this.scheduler,
            });
            this.scheduler.editEvent(dataItem, { group });
        }
    }
    saveHandler(args) {
        if (this.isFormValid(args)) {
            const formValue = args.formGroup.getRawValue();
            if (args.isNew) {
                this.editService.create(formValue);
            }
            else {
                this.handleUpdate(args.dataItem, formValue, args.mode);
            }
        }
        this.closeEditor();
    }
    createModel(args) {
        return this.createFormGroup(args);
    }
    isFormValid({ formGroup, isNew }) {
        if (formGroup.valid) {
            return true;
        }
        if (!formGroup.dirty && !isNew) {
            return false;
        }
        markAllAsTouched(formGroup);
        return false;
    }
}
ReactiveEditingDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ReactiveEditingDirective, deps: [{ token: SchedulerComponent }, { token: LocalDataChangesService }, { token: DialogsService }, { token: FocusService }], target: i0.ɵɵFactoryTarget.Directive });
ReactiveEditingDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: ReactiveEditingDirective, isStandalone: true, selector: "[kendoSchedulerReactiveEditing]", inputs: { createFormGroup: ["kendoSchedulerReactiveEditing", "createFormGroup"] }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ReactiveEditingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoSchedulerReactiveEditing]',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SchedulerComponent }, { type: LocalDataChangesService }, { type: DialogsService }, { type: FocusService }]; }, propDecorators: { createFormGroup: [{
                type: Input,
                args: ['kendoSchedulerReactiveEditing']
            }] } });

const isContentWrapper = element => hasClasses(element, 'k-scheduler-content');
const CALENDAR_TAG = 'KENDO-CALENDAR-HORIZONTAL';
/**
 * @hidden
 */
class ShortcutsDirective {
    constructor(scheduler, domEvents, focusService, zone, changeDetector, viewState, dialogsService) {
        this.scheduler = scheduler;
        this.domEvents = domEvents;
        this.focusService = focusService;
        this.zone = zone;
        this.changeDetector = changeDetector;
        this.viewState = viewState;
        this.dialogsService = dialogsService;
        this.shortcuts = [{
                match: e => e.keyCode === Keys.KeyC && noModifiers(e),
                action: e => {
                    const scheduler = this.scheduler;
                    const hours = new Date().getHours();
                    const selected = scheduler.selectedDate;
                    const start = new Date(selected.getFullYear(), selected.getMonth(), selected.getDate(), hours + 1);
                    const end = new Date(selected.getFullYear(), selected.getMonth(), selected.getDate(), hours + 2);
                    let firstResource;
                    if (scheduler.group) {
                        const resources = scheduler.resources || [];
                        const group = scheduler.group || {};
                        const grouped = groupResources(group, resources);
                        if (grouped.length > 0) {
                            firstResource = grouped[0].data[0];
                        }
                    }
                    scheduler.create.emit({
                        start: ZonedDate.fromLocalDate(start, scheduler.timezone).toLocalDate(),
                        end: ZonedDate.fromLocalDate(end, scheduler.timezone).toLocalDate(),
                        isAllDay: false,
                        resources: [firstResource],
                        originalEvent: e,
                        sender: scheduler
                    });
                }
            }, {
                match: e => e.keyCode >= Keys.Digit1 && e.keyCode <= Keys.Digit9 && withModifiers(e, Modifiers.AltKey),
                action: e => {
                    const scheduler = this.scheduler;
                    const viewIndex = e.keyCode - Keys.Digit0 - 1;
                    const views = scheduler.views.toArray();
                    const view = views[viewIndex];
                    if (view) {
                        this.zone.run(() => {
                            const prevented = scheduler.onNavigationAction({ type: 'view-change', view });
                            if (!prevented) {
                                this.changeDetector.markForCheck();
                                this.focusWait();
                            }
                        });
                    }
                }
            }, {
                match: e => e.keyCode === Keys.F10 && noModifiers(e),
                action: (e) => {
                    this.zone.run(() => {
                        e.preventDefault();
                        this.scheduler.onNavigationAction({ type: 'focus-toolbar' });
                        this.focusWait();
                    });
                }
            }, {
                match: e => e.keyCode === Keys.KeyT && noModifiers(e),
                action: () => {
                    this.zone.run(() => {
                        this.scheduler.onNavigationAction({ type: 'today' });
                        this.focusWait();
                    });
                }
            }, {
                match: e => e.keyCode === Keys.KeyB && noModifiers(e),
                action: () => {
                    this.zone.run(() => {
                        this.scheduler.onNavigationAction({ type: 'toggle-business-hours' });
                        this.focusWait();
                    });
                }
            }, {
                match: (e) => (e.keyCode === Keys.ArrowLeft || e.keyCode === Keys.ArrowRight) && withModifiers(e, Modifiers.ShiftKey),
                action: (e) => {
                    const type = e.keyCode === Keys.ArrowLeft ? 'prev' : 'next';
                    this.zone.run(() => {
                        this.scheduler.onNavigationAction({ type });
                        this.focusWait();
                    });
                }
            }, {
                match: e => (e.keyCode === Keys.ArrowUp || e.keyCode === Keys.ArrowLeft) && noModifiers(e) && !isContentWrapper(e.target),
                action: e => {
                    //use the MultiViewCalendar navigation for Year View
                    if (e.target.tagName === CALENDAR_TAG) {
                        return;
                    }
                    // do nothing if the shortcut is executed on an element inside the kendoSchedulerToolbarTemplate
                    if (this.isInToolbarTemplate(e.target)) {
                        return;
                    }
                    const prevented = this.scheduler.onNavigationAction({ type: 'focus-prev' });
                    if (!prevented) {
                        const item = this.focusService.activeItem;
                        const isFirstEvent = item.containerType === 'content' && item.element.nativeElement.matches(':first-of-type');
                        const isUpArrow = e.keyCode === Keys.ArrowUp;
                        // eslint-disable-next-line no-unused-expressions
                        isFirstEvent && isUpArrow ? this.focusService.focusToolbar() : this.focusService.focusNext({ offset: -1 });
                        e.preventDefault();
                    }
                }
            }, {
                match: e => (e.keyCode === Keys.ArrowDown || e.keyCode === Keys.ArrowRight) && noModifiers(e) && !isContentWrapper(e.target),
                action: e => {
                    //use the MultiViewCalendar navigation for Year View
                    if (e.target.tagName === CALENDAR_TAG) {
                        return;
                    }
                    // do nothing if the shortcut is executed on an element inside the kendoSchedulerToolbarTemplate
                    if (this.isInToolbarTemplate(e.target)) {
                        return;
                    }
                    const prevented = this.scheduler.onNavigationAction({ type: 'focus-next' });
                    if (!prevented) {
                        const isInToolbar = this.focusService.activeItem.containerType === 'toolbar';
                        const offset = 1;
                        if (e.keyCode === Keys.ArrowDown && isInToolbar) {
                            const focusableElementsArray = Array.from(this.focusService.focusableItems);
                            const firstFocusableContentElementIndex = focusableElementsArray.findIndex(item => item.containerType === 'content');
                            if (firstFocusableContentElementIndex > -1) {
                                this.focusService.focusByIndex(firstFocusableContentElementIndex);
                                e.preventDefault();
                                return;
                            }
                        }
                        this.focusService.focusNext({ offset });
                        e.preventDefault();
                    }
                }
            }];
        this.taskShortcuts = [{
                match: e => (e.keyCode === Keys.Delete || e.keyCode === Keys.Backspace) && noModifiers(e),
                action: (e, event) => {
                    this.viewState.emitEvent('remove', { event: event, dataItem: event.dataItem });
                    e.preventDefault();
                }
            }, {
                match: e => e.keyCode === Keys.Enter && noModifiers(e),
                action: (e, event) => {
                    this.viewState.emitEvent('eventDblClick', { type: 'dblclick', event: event, originalEvent: e });
                    e.preventDefault();
                }
            }];
        this.subs = new Subscription();
        this.subs.add(this.domEvents.keydown.subscribe(e => this.onKeydown(e)));
        this.subs.add(this.scheduler.eventKeydown.subscribe(e => this.onEventKeydown(e)));
    }
    onKeydown(e) {
        const match = this.shortcuts.find(shortcut => shortcut.match(e));
        if (match && !this.dialogsService.isOpen) {
            match.action(e);
        }
    }
    onEventKeydown(e) {
        const match = this.taskShortcuts.find(shortcut => shortcut.match(e.originalEvent));
        if (match && !this.dialogsService.isOpen) {
            match.action(e.originalEvent, e.event);
        }
    }
    focusWait() {
        this.viewState.layoutEnd.pipe(take(1)).subscribe(() => this.focusService.focus());
    }
    isInToolbarTemplate(element) {
        const isInToolbar = element.closest('.k-scheduler-toolbar');
        const isInBuiltInElement = element.closest('.k-toolbar-group') ||
            element.closest('.k-scheduler-views') ||
            element.closest('.k-views-dropdown');
        return isInToolbar && !isInBuiltInElement;
    }
}
ShortcutsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ShortcutsDirective, deps: [{ token: SchedulerComponent }, { token: DomEventsService }, { token: FocusService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: ViewStateService }, { token: DialogsService }], target: i0.ɵɵFactoryTarget.Directive });
ShortcutsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "15.2.10", type: ShortcutsDirective, isStandalone: true, selector: "kendo-scheduler", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ShortcutsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'kendo-scheduler',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: SchedulerComponent }, { type: DomEventsService }, { type: FocusService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: ViewStateService }, { type: DialogsService }]; } });

/**
 * Utility array that contains all Scheduler PDF related components and directives
 */
const KENDO_SCHEDULERPDF = [
    PDFComponent,
    PDFCommandDirective
];
/**
 * Utility array that contains all `@progress/kendo-angular-scheduler` related components and directives
 */
const KENDO_SCHEDULER = [
    SchedulerComponent,
    SchedulerCustomMessagesComponent,
    SchedulerViewDirective,
    DataBindingDirective,
    SlotSelectableDirective,
    PDFComponent,
    PDFCommandDirective,
    ShortcutsDirective,
    // views
    AgendaViewComponent,
    DayViewComponent,
    MonthViewComponent,
    MultiDayViewComponent,
    MultiWeekViewComponent,
    TimelineMonthViewComponent,
    TimelineViewComponent,
    TimelineWeekViewComponent,
    WeekViewComponent,
    WorkWeekViewComponent,
    YearViewComponent,
    // editing
    ReactiveEditingDirective,
    RecurrenceEditorComponent,
    TimeZoneEditorComponent,
    // toolbar
    ToolbarNavigationComponent,
    ToolbarTemplateDirective,
    ToolbarViewSelectorComponent,
    // templates
    AgendaDateTemplateDirective,
    AgendaTimeTemplateDirective,
    AllDayEventTemplateDirective,
    AllDaySlotTemplateDirective,
    DateHeaderTemplateDirective,
    EventTemplateDirective,
    EditDialogTemplateDirective,
    GroupHeaderTemplateDirective,
    MajorTimeHeaderTemplateDirective,
    MinorTimeHeaderTemplateDirective,
    MonthDaySlotTemplateDirective,
    MultiWeekDaySlotTemplateDirective,
    TimeSlotTemplateDirective,
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](link:site.data.urls.angular['ngmoduleapi'])
 * definition for the Scheduler component.
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { SchedulerModule } from '@progress/kendo-angular-scheduler';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, SchedulerModule],
 *     bootstrap:    [AppComponent]
 * })
 *
 * export class AppModule {}
 * ```
 */
class SchedulerModule {
}
SchedulerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SchedulerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: SchedulerModule, imports: [SchedulerComponent, SchedulerCustomMessagesComponent, SchedulerViewDirective, DataBindingDirective, SlotSelectableDirective, PDFComponent, PDFCommandDirective, ShortcutsDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, ReactiveEditingDirective, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarTemplateDirective, ToolbarViewSelectorComponent, AgendaDateTemplateDirective, AgendaTimeTemplateDirective, AllDayEventTemplateDirective, AllDaySlotTemplateDirective, DateHeaderTemplateDirective, EventTemplateDirective, EditDialogTemplateDirective, GroupHeaderTemplateDirective, MajorTimeHeaderTemplateDirective, MinorTimeHeaderTemplateDirective, MonthDaySlotTemplateDirective, MultiWeekDaySlotTemplateDirective, TimeSlotTemplateDirective], exports: [SchedulerComponent, SchedulerCustomMessagesComponent, SchedulerViewDirective, DataBindingDirective, SlotSelectableDirective, PDFComponent, PDFCommandDirective, ShortcutsDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, ReactiveEditingDirective, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarTemplateDirective, ToolbarViewSelectorComponent, AgendaDateTemplateDirective, AgendaTimeTemplateDirective, AllDayEventTemplateDirective, AllDaySlotTemplateDirective, DateHeaderTemplateDirective, EventTemplateDirective, EditDialogTemplateDirective, GroupHeaderTemplateDirective, MajorTimeHeaderTemplateDirective, MinorTimeHeaderTemplateDirective, MonthDaySlotTemplateDirective, MultiWeekDaySlotTemplateDirective, TimeSlotTemplateDirective] });
SchedulerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerModule, providers: [
        ToolbarService,
        ViewContextService,
        ViewStateService,
        EditService,
        IconsService,
        PopupService,
        ResizeBatchService,
        // DateInputsModule providers
        CalendarDOMService,
        CenturyViewService,
        DecadeViewService,
        MonthViewService,
        YearViewService,
        NavigationService,
        TimePickerDOMService,
        HoursService,
        MinutesService,
        SecondsService,
        MillisecondsService,
        DayPeriodService,
        // DropDownsModule providers
        DialogContainerService,
        DialogService,
        WindowService,
        WindowContainerService,
    ], imports: [SchedulerComponent, SchedulerCustomMessagesComponent, PDFComponent, PDFCommandDirective, AgendaViewComponent, DayViewComponent, MonthViewComponent, MultiDayViewComponent, MultiWeekViewComponent, TimelineMonthViewComponent, TimelineViewComponent, TimelineWeekViewComponent, WeekViewComponent, WorkWeekViewComponent, YearViewComponent, RecurrenceEditorComponent, TimeZoneEditorComponent, ToolbarNavigationComponent, ToolbarViewSelectorComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SchedulerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_SCHEDULER],
                    exports: [...KENDO_SCHEDULER],
                    providers: [
                        ToolbarService,
                        ViewContextService,
                        ViewStateService,
                        EditService,
                        IconsService,
                        PopupService,
                        ResizeBatchService,
                        // DateInputsModule providers
                        CalendarDOMService,
                        CenturyViewService,
                        DecadeViewService,
                        MonthViewService,
                        YearViewService,
                        NavigationService,
                        TimePickerDOMService,
                        HoursService,
                        MinutesService,
                        SecondsService,
                        MillisecondsService,
                        DayPeriodService,
                        // DropDownsModule providers
                        DialogContainerService,
                        DialogService,
                        WindowService,
                        WindowContainerService,
                    ],
                }]
        }] });

/**
 * @hidden
 *
 * As of package v17, the `MonthViewModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class MonthViewModule {
}
MonthViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MonthViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: MonthViewModule, imports: [MonthViewComponent,
        MultiWeekViewComponent], exports: [MonthViewComponent,
        MultiWeekViewComponent] });
MonthViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewModule, providers: [
        IconsService,
        PopupService,
        ResizeBatchService
    ], imports: [MonthViewComponent,
        MultiWeekViewComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MonthViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        MonthViewComponent,
                        MultiWeekViewComponent
                    ],
                    exports: [
                        MonthViewComponent,
                        MultiWeekViewComponent
                    ],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

const PUBLIC_DIRECTIVES$1 = [
    DayViewComponent,
    MultiDayViewComponent,
    WeekViewComponent,
    WorkWeekViewComponent
];
/**
 * @hidden
 *
 * As of package v17, the `MultiDayViewModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class MultiDayViewModule {
}
MultiDayViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MultiDayViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewModule, imports: [DayViewComponent,
        MultiDayViewComponent,
        WeekViewComponent,
        WorkWeekViewComponent], exports: [DayViewComponent,
        MultiDayViewComponent,
        WeekViewComponent,
        WorkWeekViewComponent] });
MultiDayViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewModule, providers: [
        IconsService,
        PopupService,
        ResizeBatchService
    ], imports: [PUBLIC_DIRECTIVES$1] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: MultiDayViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [PUBLIC_DIRECTIVES$1],
                    exports: [PUBLIC_DIRECTIVES$1],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

const PUBLIC_DIRECTIVES = [
    TimelineViewComponent,
    TimelineWeekViewComponent,
    TimelineMonthViewComponent
];
/**
 * @hidden
 *
 * As of package v17, the `TimelineViewModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class TimelineViewModule {
}
TimelineViewModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TimelineViewModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewModule, imports: [TimelineViewComponent,
        TimelineWeekViewComponent,
        TimelineMonthViewComponent], exports: [TimelineViewComponent,
        TimelineWeekViewComponent,
        TimelineMonthViewComponent] });
TimelineViewModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewModule, providers: [
        IconsService,
        PopupService,
        ResizeBatchService
    ], imports: [PUBLIC_DIRECTIVES] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: TimelineViewModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [PUBLIC_DIRECTIVES],
                    exports: [PUBLIC_DIRECTIVES],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

/**
 * @hidden
 * Custom component messages override default component messages.
 */
class RecurrenceEditorCustomMessagesComponent extends Messages$1 {
    constructor(service) {
        super();
        this.service = service;
    }
    get override() {
        return true;
    }
}
RecurrenceEditorCustomMessagesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorCustomMessagesComponent, deps: [{ token: i1$1.LocalizationService }], target: i0.ɵɵFactoryTarget.Component });
RecurrenceEditorCustomMessagesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.10", type: RecurrenceEditorCustomMessagesComponent, isStandalone: true, selector: "kendo-recurrence-editor-messages", providers: [
        {
            provide: Messages$1,
            useExisting: forwardRef(() => RecurrenceEditorCustomMessagesComponent)
        }
    ], usesInheritance: true, ngImport: i0, template: ``, isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: RecurrenceEditorCustomMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    providers: [
                        {
                            provide: Messages$1,
                            useExisting: forwardRef(() => RecurrenceEditorCustomMessagesComponent)
                        }
                    ],
                    selector: 'kendo-recurrence-editor-messages',
                    template: ``,
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i1$1.LocalizationService }]; } });

const DATE_FORMATS = [
    "yyyyMMddTHHmmssSSSXXX",
    "yyyyMMddTHHmmssXXX",
    "yyyyMMddTHHmmss",
    "yyyyMMddTHHmm",
    "yyyyMMddTHH",
    "yyyyMMdd"
];
/**
 * A base implementation of the [edit service]({% slug api_scheduler_editservice %}) which persists data to traditional CRUD services such as OData.
 *
 * To support custom models, the `BaseEditService` class requires a [field map]({% slug api_scheduler_schedulermodelfields %}) as a constructor parameter. Subclasses require you to
 * implement the `read` operation, which is not called directly by the base class, and the `save` method which persists the created,
 * updated, and deleted entities.
 *
 * The [`events`](#toc-events) observable will publish the current data which is set upon subscription by using, for example, an [async pipe](https://angular.io/api/common/AsyncPipe)
 * ([more information]({% slug editing_directives_scheduler %}#toc-custom-service)).
 *
 * Implementations which utilize dedicated services, such as Google Calendar and Microsoft Exchange, will typically implement the
 * [`EditService`]({% slug api_scheduler_editservice %}) of the Scheduler directly.
 *
 * See example in [this article]({% slug custom_reactive_editing_scheduler %}).
 */
class BaseEditService {
    /**
     * Initializes the base edit service.
     *
     * @param fields - A field map that will be used for reading and modifying model objects. Defaults to the [`SchedulerEvent`]({% slug api_scheduler_schedulerevent %}) fields.
     */
    constructor(fields) {
        /**
         * An array of the currently loaded events which is populated by the derived class.
         */
        this.data = [];
        /**
         * The source subject for the `events` observable.
         */
        this.source = new BehaviorSubject([]);
        this.createdItems = [];
        this.updatedItems = [];
        this.deletedItems = [];
        this.events = this.source.asObservable();
        this.fields = { ...defaultModelFields, ...fields };
        this.getId = getter(this.fields.id);
        this.getRecurrenceId = getter(this.fields.recurrenceId);
        this.getRecurrenceRule = getter(this.fields.recurrenceRule);
        this.getRecurrenceExceptions = getter(this.fields.recurrenceExceptions);
        this.getStart = getter(this.fields.start);
        this.setId = setter(this.fields.id);
        this.setRecurrenceRule = setter(this.fields.recurrenceRule);
        this.setRecurrenceExceptions = setter(this.fields.recurrenceExceptions);
        this.setRecurrenceId = setter(this.fields.recurrenceId);
    }
    create(event) {
        this.logCreate(event);
        this.saveChanges();
    }
    /*
     * Creates an exception to a recurring series.
     *
     * The `createException` method performs the following operations:
     * * Adds the start date of the event to the `recurrenceExceptions` of the master event (recurrence head).
     * * Creates a new event that stores the recurrence exception itself.
     */
    createException(event, value) {
        const exception = this.buildException(value);
        this.logRemoveOccurrence(event);
        this.logCreate(exception);
        this.saveChanges();
    }
    update(event, value) {
        this.assignValues(event, value);
        this.logUpdate(event);
        this.saveChanges();
    }
    remove(event) {
        this.logRemove(event);
        this.saveChanges();
    }
    removeSeries(event) {
        const id = this.getId(event);
        const recurrenceId = this.getRecurrenceId(event);
        const isHead = this.isRecurrenceHead(event);
        this.removeItemAndExceptions(isHead ? id : recurrenceId);
        this.saveChanges();
    }
    removeOccurrence(event) {
        this.logRemoveOccurrence(event);
        this.saveChanges();
    }
    /**
     * Returns the master recurring event for a specified recurring event.
     *
     * @param event - An event from the recurrence series.
     * @returns the master recurring event for the series.
     */
    findRecurrenceMaster(event) {
        const id = this.getId(event);
        const recurrenceId = this.getRecurrenceId(event);
        const headId = this.isRecurrenceHead(event) ? id : recurrenceId;
        const index = this.itemIndex(headId, this.data);
        return this.data[index];
    }
    /**
     * Checks if the event is part of the recurrence series.
     *
     * @param event - The event that will be checked.
     * @returns `true` if the event is an occurrence, an exception, or a master event. Otherwise, returns `false`.
     */
    isRecurring(event) {
        return isRecurring(event, this.fields);
    }
    /**
     * Checks if the event is a recurrence exception.
     *
     * @param event - The event that will be checked.
     * @returns `true` if the event is a unique event which belongs to a recurrence series. Otherwise, returns `false`.
     */
    isException(event) {
        return isException(event, this.fields);
    }
    /**
     * Returns a Boolean value which indicates if the event is new.
     * If the `ID` field is defined, the default implementation returns `true`.
     * Can be overridden to implement different conditions.
     *
     * @param event - The event that will be checked.
     */
    isNew(event) {
        const id = this.getId(event);
        return !isPresent(id);
    }
    /**
     * Returns the next `ID` that will be used for new events.
     * The default implementation returns `undefined`.
     */
    nextId() {
        return undefined;
    }
    /**
     * Copies values to the target model instance.
     * To copy the top-level fields, the base implementation uses
     * [`Object.assign`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).
     * To copy nested fields, override `assignValues` and handle the model-specific cases.
     *
     * @param target - The target object that will receive the field values.
     * @param source - The source object from which the fields will be read.
     */
    assignValues(target, source) {
        cloneTo(source, target);
    }
    /**
     * Clones an existing model object.
     * To copy the top-level model fields, the base creates an empty object and calls [`assignValues`](#toc-assignvalues).
     * To create models of the correct type, override `cloneEvent`.
     *
     * @param event - The model instance to copy.
     * @returns TEvent - The new model instance.
     */
    cloneEvent(event) {
        const result = {};
        this.assignValues(result, event);
        return result;
    }
    /**
     * A utility method which parses recurrence exception dates in an ISO format.
     *
     * @example
     * ```ts-no-run
     *   const exdates = '20180614T060000Z;20180615T060000Z';
     *   const result = super.parseExceptions(exdates);
     *
     *   // console.log(result);
     *   // Array [ Date 2018-06-14T03:00:00.000Z, Date 2018-06-15T03:00:00.000Z ]
     * ```
     *
     * @param value - A comma-separated list of ISO-formatted dates.
     * @returns Date[] - The recurrence exceptions as local dates.
     */
    parseExceptions(value) {
        if (!isPresent(value) || value === '') {
            return [];
        }
        return value
            .split(';')
            .map(ex => parseDate(ex, DATE_FORMATS) || undefined);
    }
    /**
     * A utility method which serializes recurrence exception dates in an ISO format.
     *
     * @example
     * ```ts-no-run
     *   const exdates = [ new Date(2018, 5, 14, 3, 0, 0), new Date(2018, 5, 15, 3, 0, 0) ];
     *   const result = super.serializeExceptions(exdates);
     *
     *   // console.log(result);
     *   // '20180614T060000Z;20180615T060000Z'
     * ```
     *
     * @param value - An array of `Date` instances.
     * @returns string - A comma-separated list of ISO-formatted dates.
     */
    serializeExceptions(exceptions) {
        if (!exceptions || exceptions.length === 0) {
            return '';
        }
        return exceptions.map(date => formatDate(toLocalDate(date), 'yyyyMMddTHHmmss') + 'Z').join(';');
    }
    reset() {
        this.data = [];
        this.deletedItems = [];
        this.updatedItems = [];
        this.createdItems = [];
    }
    itemIndex(id, items) {
        for (let idx = 0; idx < items.length; idx++) {
            if (this.getId(items[idx]) === id) {
                return idx;
            }
        }
        return -1;
    }
    buildException(item) {
        const fields = this.fields;
        const head = this.findRecurrenceMaster(item);
        const copy = this.cloneEvent(item);
        assignField(copy, head, fields.id);
        this.setId(copy, this.nextId());
        this.setRecurrenceRule(copy, undefined);
        this.setRecurrenceId(copy, this.getId(head));
        return copy;
    }
    isRecurrenceHead(item) {
        const id = this.getId(item);
        const recurrenceRule = this.getRecurrenceRule(item);
        return !!(id && recurrenceRule);
    }
    logCreate(item) {
        this.data = [...this.data, item];
        this.source.next(this.data);
        this.createdItems.push(item);
    }
    logUpdate(item) {
        const id = this.getId(item);
        if (!this.isNew(item)) {
            const index = this.itemIndex(id, this.updatedItems);
            if (index !== -1) {
                this.updatedItems.splice(index, 1, item);
            }
            else {
                this.updatedItems.push(item);
            }
        }
        else {
            const index = this.createdItems.indexOf(item);
            this.createdItems.splice(index, 1, item);
        }
    }
    logRemove(item) {
        const id = this.getId(item);
        let index = this.itemIndex(id, this.data);
        this.data = this.data.filter((_, i) => i !== index);
        this.source.next(this.data);
        index = this.itemIndex(id, this.createdItems);
        if (index >= 0) {
            this.createdItems.splice(index, 1);
        }
        else {
            this.deletedItems.push(item);
        }
        index = this.itemIndex(id, this.updatedItems);
        if (index >= 0) {
            this.updatedItems.splice(index, 1);
        }
    }
    logRemoveOccurrence(event) {
        const head = this.findRecurrenceMaster(event);
        const exceptionDate = this.getStart(event);
        const currentExceptions = this.getRecurrenceExceptions(head) || [];
        this.setRecurrenceExceptions(head, [...currentExceptions, exceptionDate]);
        this.logUpdate(head);
    }
    removeItemAndExceptions(itemId) {
        this.deletedItems = this.deletedItems.concat(this.data.filter(ev => this.getRecurrenceId(ev) === itemId || this.getId(ev) === itemId));
    }
    hasChanges() {
        return this.deletedItems.length + this.updatedItems.length + this.createdItems.length > 0;
    }
    saveChanges() {
        if (!this.hasChanges()) {
            return;
        }
        this.save(this.createdItems, this.updatedItems, this.deletedItems);
        this.reset();
    }
}

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [NgModule](https://angular.io/api/core/NgModule)
 * definition for the Scheduler PDF component.
 *
 * ```ts
 * import { NgModule } from '@angular/core';
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { SchedulerModule, PDFModule } from '@progress/kendo-angular-scheduler';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, SchedulerModule, PDFModule],
 *     bootstrap:    [AppComponent]
 * })
 *
 * export class AppModule {}
 * ```
 */
class PDFModule {
}
PDFModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PDFModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: PDFModule, imports: [PDFComponent, PDFCommandDirective], exports: [PDFComponent, PDFCommandDirective] });
PDFModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFModule, providers: [IconsService], imports: [KENDO_SCHEDULERPDF] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: PDFModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [...KENDO_SCHEDULERPDF],
                    exports: [...KENDO_SCHEDULERPDF],
                    providers: [IconsService]
                }]
        }] });

/**
 * @hidden
 *
 * As of package v17, the `SharedModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class SharedModule {
    static exports() {
        return [
            FocusableDirective,
            SortPipe
        ];
    }
}
SharedModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
SharedModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: SharedModule, imports: [FocusableDirective,
        SortPipe], exports: [FocusableDirective,
        SortPipe] });
SharedModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SharedModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: SharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        FocusableDirective,
                        SortPipe
                    ],
                    exports: [
                        FocusableDirective,
                        SortPipe
                    ]
                }]
        }] });

const DECLARATIONS = [
    ViewFooterComponent,
    WorkHoursFooterDirective,
    RepeatPipe,
    ResourceIteratorPipe,
    HintContainerComponent,
    ResizeHintComponent
];
/**
 * @hidden
 *
 * As of package v17, the `ViewsSharedModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class ViewsSharedModule {
}
ViewsSharedModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewsSharedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ViewsSharedModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: ViewsSharedModule, imports: [ViewFooterComponent,
        WorkHoursFooterDirective,
        RepeatPipe,
        ResourceIteratorPipe,
        HintContainerComponent,
        ResizeHintComponent], exports: [ViewFooterComponent,
        WorkHoursFooterDirective,
        RepeatPipe,
        ResourceIteratorPipe,
        HintContainerComponent,
        ResizeHintComponent] });
ViewsSharedModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewsSharedModule, providers: [
        IconsService,
        PopupService,
        ResizeBatchService
    ], imports: [ViewFooterComponent,
        HintContainerComponent,
        ResizeHintComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: ViewsSharedModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [DECLARATIONS],
                    exports: [DECLARATIONS],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

const DIRECTIVES = [TimeSlotDirective, DaySlotDirective, DayTimeViewItemComponent];
/**
 * @hidden
 *
 * As of package v17, the `DayTimeModule` is deprecated and can
 * be removed in a future major version. We recommend using `SchedulerModule`.
 */
class DayTimeModule {
}
DayTimeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DayTimeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.10", ngImport: i0, type: DayTimeModule, imports: [TimeSlotDirective, DaySlotDirective, DayTimeViewItemComponent], exports: [TimeSlotDirective, DaySlotDirective, DayTimeViewItemComponent] });
DayTimeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeModule, providers: [
        IconsService,
        PopupService,
        ResizeBatchService
    ], imports: [DayTimeViewItemComponent] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.10", ngImport: i0, type: DayTimeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [DIRECTIVES],
                    exports: [DIRECTIVES],
                    providers: [
                        IconsService,
                        PopupService,
                        ResizeBatchService
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AddEvent, AgendaDateTemplateDirective, AgendaTimeTemplateDirective, AgendaViewComponent, AllDayEventTemplateDirective, AllDaySlotTemplateDirective, BaseEditService, CancelEvent, CrudOperation, DataBindingDirective, DateChangeEvent, DateHeaderTemplateDirective, DaySlotDirective, DayTimeModule, DayTimeSlotService, DayTimeViewItemComponent, DayViewComponent, DragEndEvent, DragEvent, DragStartEvent, EditDialogComponent, EditDialogTemplateDirective, EditEvent, EditEventBase, EditMode, EndRuleRadioButtonDirective, EventClickEvent, EventKeydownEvent, EventTemplateDirective, FocusService, FocusableDirective, GroupHeaderTemplateDirective, HintContainerComponent, IsSlotSelectedArgs, KENDO_SCHEDULER, KENDO_SCHEDULERPDF, LoadingComponent, LocalizedMessagesDirective, MajorTimeHeaderTemplateDirective, MinorTimeHeaderTemplateDirective, MonthDaySlotTemplateDirective, MonthViewComponent, MonthViewModule, MultiDayViewComponent, MultiDayViewModule, MultiWeekDaySlotTemplateDirective, MultiWeekViewComponent, MultipleResourceEditorComponent, NavigateEvent, PDFCommandDirective, PDFComponent, PDFExportEvent, PDFModule, PDFService, ReactiveEditingDirective, RecurrenceEditorComponent, RecurrenceEditorCustomMessagesComponent, RecurrenceEditorLocalizedMessagesDirective, RecurrenceEndRuleEditorComponent, RecurrenceFrequencyEditorComponent, RecurrenceIntervalEditorComponent, RecurrenceMonthlyYearlyEditorComponent, RecurrenceWeekdayRuleEditorComponent, RemoveEvent, RepeatOnRadioButtonDirective, RepeatPipe, ResizeEndEvent, ResizeEvent, ResizeHintComponent, ResizeStartEvent, ResourceIteratorPipe, SaveEvent, SchedulerComponent, SchedulerCustomMessagesComponent, SchedulerDateTimePickerComponent, SchedulerModule, SchedulerView, SchedulerViewDirective, SharedModule, ShortcutsDirective, SingleResourceEditorComponent, SlotClickEvent, SlotDragEndEvent, SlotDragEvent, SlotDragStartEvent, SlotSelectableDirective, SortPipe, TimeSlotDirective, TimeSlotTemplateDirective, TimeZoneEditorComponent, TimelineBase, TimelineMonthViewComponent, TimelineMultiDayViewComponent, TimelineViewComponent, TimelineViewModule, TimelineWeekViewComponent, ToolbarNavigationComponent, ToolbarService, ToolbarTemplateDirective, ToolbarViewSelectorComponent, VIEW_EVENT_MAP, ViewContextService, ViewFooterComponent, ViewStateService, ViewsSharedModule, WeekViewComponent, WorkHoursFooterDirective, WorkWeekViewComponent, YearViewComponent, YearViewInternalComponent };

