/**-----------------------------------------------------------------------------------------
* Copyright Â© 2024 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { focusableSelector } from '@progress/kendo-angular-common';
/**
 * @hidden
 */
let idx = 0;
/**
 * @hidden
 */
let popoverTitleIdx = 0;
/**
 * @hidden
 */
let popoverBodyIdx = 0;
/**
 * @hidden
 */
export const getId = (prefix, idSource) => {
    switch (idSource) {
        case 'popoverTitle':
            return `${prefix}-${++popoverTitleIdx}`;
        case 'popoverBody':
            return `${prefix}-${++popoverBodyIdx}`;
        default:
            return `${prefix}-${++idx}`;
    }
};
/**
 * @hidden
 */
export function align(position, offset) {
    let anchorAlign = {};
    let popupAlign = {};
    let popupMargin = {};
    switch (position) {
        case 'top':
            anchorAlign = { horizontal: 'center', vertical: 'top' };
            popupAlign = { horizontal: 'center', vertical: 'bottom' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'bottom':
            anchorAlign = { horizontal: 'center', vertical: 'bottom' };
            popupAlign = { horizontal: 'center', vertical: 'top' };
            popupMargin = { horizontal: 0, vertical: offset };
            break;
        case 'right':
            anchorAlign = { horizontal: 'right', vertical: 'center' };
            popupAlign = { horizontal: 'left', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        case 'left':
            anchorAlign = { horizontal: 'left', vertical: 'center' };
            popupAlign = { horizontal: 'right', vertical: 'center' };
            popupMargin = { horizontal: offset, vertical: 0 };
            break;
        default: break;
    }
    return {
        anchorAlign,
        popupAlign,
        popupMargin
    };
}
/**
 * @hidden
 */
export function collision(inputcollision, position) {
    if (inputcollision) {
        return inputcollision;
    }
    if (position === 'top' || position === 'bottom') {
        return { horizontal: 'fit', vertical: 'flip' };
    }
    return { horizontal: 'flip', vertical: 'fit' };
}
function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
export function closestBySelector(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    const matches = Element.prototype.matches ?
        (el, sel) => el.matches(sel)
        : (el, sel) => el.msMatchesSelector(sel);
    let node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
export function contains(container, child) {
    if (!container) {
        return false;
    }
    if (isDocumentNode(container)) {
        return false;
    }
    if (container.contains) {
        return container.contains(child);
    }
    if (container.compareDocumentPosition) {
        return !!(container.compareDocumentPosition(child) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    }
}
/**
 * @hidden
 */
export const hasParent = (node, parent) => {
    while (node && node !== parent) {
        node = node.parentNode;
    }
    return node;
};
/**
 * @hidden
 */
export function getCenterOffset(item, dir, size) {
    const rect = item.getBoundingClientRect();
    return rect[dir] + (rect[size] / 2);
}
/**
 * @hidden
 */
export function containsItem(collection, item) {
    return collection.indexOf(item) !== -1;
}
/**
 * @hidden
 */
export function getAllFocusableChildren(parent) {
    return parent.querySelectorAll(focusableSelector);
}
/**
 * @hidden
 */
export function getFirstAndLastFocusable(parent) {
    const all = getAllFocusableChildren(parent);
    const firstFocusable = all.length > 0 ? all[0] : parent;
    const lastFocusable = all.length > 0 ? all[all.length - 1] : parent;
    return [firstFocusable, lastFocusable];
}
